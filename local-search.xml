<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>拷贝</title>
    <link href="/cblog/2024/10/22/%E6%8B%B7%E8%B4%9D/"/>
    <url>/cblog/2024/10/22/%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul><li><strong>概念</strong>：浅拷贝是指创建一个新对象，但对象中的属性（如果是基本数据类型）会直接复制原对象的值，而对于引用数据类型属性，只是复制引用地址，指向相同的内存位置。</li></ul><p>浅拷贝在 Java 中意味着复制一个对象时，<strong>仅复制该对象的基本字段</strong>，但如果对象内部有引用类型字段（例如数组、集合、对象），那么这些引用类型字段不会被复制，它们只是被共享。</p><p><strong>特点</strong>：</p><ul><li>拷贝的是对象的引用，不是对象本身。</li><li>改变原对象引用类型的属性时，浅拷贝的对象也会跟着变化，因为它们指向同一块内存区域。</li></ul><p><strong>使用方式</strong>：Java 中可以通过实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法来实现浅拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    Address address; <span class="hljs-comment">// 引用类型属性</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-comment">// 浅拷贝</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;, address=&quot;</span> + address + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    String city;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShallowCopyExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;New York&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>, address);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> (Person) person1.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;Before modification:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Person 1: &quot;</span> + person1);<br>        System.out.println(<span class="hljs-string">&quot;Person 2: &quot;</span> + person2);<br><br>        <span class="hljs-comment">// 修改引用类型属性的值</span><br>        person2.address.city = <span class="hljs-string">&quot;San Francisco&quot;</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;\nAfter modification:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Person 1: &quot;</span> + person1); <span class="hljs-comment">// 引用类型属性也被修改</span><br>        System.out.println(<span class="hljs-string">&quot;Person 2: &quot;</span> + person2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输出<br>Before modification:<br>Person <span class="hljs-number">1</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;&#125;<br>Person <span class="hljs-number">2</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;&#125;<br><br>After modification:<br>Person <span class="hljs-number">1</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;San Francisco&#x27;</span>&#125;&#125;<br>Person <span class="hljs-number">2</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;San Francisco&#x27;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p><strong>概念</strong>：深拷贝是指不仅要复制对象本身，还要复制对象中的引用类型属性所指向的对象，递归地创建对象的完整副本。</p><p><strong>特点</strong>：</p><ul><li>创建了完全独立的对象，修改拷贝对象不会影响原对象。</li><li>深拷贝需要手动实现，因为 <code>clone()</code> 方法默认是浅拷贝。</li></ul><p><strong>使用方式</strong>：可以通过重写 <code>clone()</code> 方法，并在其中调用引用类型属性的 <code>clone()</code> 方法来实现深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    Address address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-comment">// 深拷贝</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">clonedPerson</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        clonedPerson.address = (Address) <span class="hljs-built_in">this</span>.address.clone(); <span class="hljs-comment">// 深拷贝引用类型属性</span><br>        <span class="hljs-keyword">return</span> clonedPerson;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&quot;, address=&quot;</span> + address + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    String city;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;city=&#x27;&quot;</span> + city + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopyExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;New York&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>, address);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> (Person) person1.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;Before modification:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Person 1: &quot;</span> + person1);<br>        System.out.println(<span class="hljs-string">&quot;Person 2: &quot;</span> + person2);<br><br>        <span class="hljs-comment">// 修改引用类型属性的值</span><br>        person2.address.city = <span class="hljs-string">&quot;San Francisco&quot;</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;\nAfter modification:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Person 1: &quot;</span> + person1); <span class="hljs-comment">// 原对象未受影响</span><br>        System.out.println(<span class="hljs-string">&quot;Person 2: &quot;</span> + person2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">输出<br>Before modification:<br>Person <span class="hljs-number">1</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;&#125;<br>Person <span class="hljs-number">2</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;&#125;<br><br>After modification:<br>Person <span class="hljs-number">1</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;&#125;<br>Person <span class="hljs-number">2</span>: Person&#123;name=<span class="hljs-string">&#x27;John&#x27;</span>, age=<span class="hljs-number">30</span>, address=Address&#123;city=<span class="hljs-string">&#x27;San Francisco&#x27;</span>&#125;&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/cblog/2024/10/22/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/cblog/2024/10/22/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>十进制转其他进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Main;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">123</span>;<br>        String s1=Integer.toBinaryString(a);  <span class="hljs-comment">//将整数a转换成二进制字符串并输出</span><br>        System.out.println(s1);<br>        String s2=Integer.toOctalString(a);   <span class="hljs-comment">//将整数a转换成八进制字符串并输出</span><br>        System.out.println(s2);<br>        String s3=Integer.toHexString(a);     <span class="hljs-comment">//将整数a转换成十六进制字符串并输出</span><br>        System.out.println(s3);<br>        <span class="hljs-comment">//Integer.toString(i,x),将i转换成任意x进制</span><br>        String s4=Integer.toString(a,<span class="hljs-number">7</span>);      <span class="hljs-comment">//将整数a转换成7进制并输出</span><br>        System.out.println(s4);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是其他进制转换成10进制:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Main;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-comment">// Integer.valueof(&quot;s&quot;,x);  s是对应的某个进制的字符串，x对应当前字符串的进制</span><br>            System.out.println(<span class="hljs-string">&quot;其它制转换到十进制：&quot;</span>);<br>            <span class="hljs-type">int</span> y1= Integer.valueOf(<span class="hljs-string">&quot;FFFF&quot;</span>,<span class="hljs-number">16</span>);     <span class="hljs-comment">///16进制转换成10进制</span><br>            System.out.println(y1);<br>            <span class="hljs-type">int</span> y2=Integer.valueOf(<span class="hljs-string">&quot;776&quot;</span>,<span class="hljs-number">8</span>);        <span class="hljs-comment">///8进制转换成10进制</span><br>            System.out.println(y2);<br>            <span class="hljs-type">int</span> y3=Integer.valueOf(<span class="hljs-string">&quot;0101&quot;</span>,<span class="hljs-number">2</span>);       <span class="hljs-comment">//2进制转换成10进制</span><br>            System.out.println(y3);<br>            <span class="hljs-type">int</span> y4=Integer.valueOf(<span class="hljs-string">&quot;101&quot;</span>,<span class="hljs-number">7</span>);        <span class="hljs-comment">//7进制转换成10进制</span><br>            System.out.println(y4);<br><br>            System.out.println(<span class="hljs-string">&quot;其它的可能用到的函数：&quot;</span>);<br>            <span class="hljs-comment">//static int parseInt(String s, int radix) //使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;776&quot;</span>, <span class="hljs-number">8</span>) ; <span class="hljs-comment">///8进制转换成10进制</span><br>            System.out.println(n);<br>            <span class="hljs-comment">///Integer.valueOf()返回一个“integer对象”和Integer.parseInt()返回一个“int值”的区别在于，返回值不同</span><br>            <span class="hljs-comment">///基本常识，其他的非10进制的数的保存，基本都是以字符串的形式</span><br><br><br>            <span class="hljs-comment">///例子：7进制到8进制的转换</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;6523&quot;</span> ; <span class="hljs-comment">///7进制的字符串</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.toString(Integer.valueOf(q,<span class="hljs-number">7</span>),<span class="hljs-number">8</span>) ;<span class="hljs-comment">///这样7进制就变成8进制了</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>键盘输入</title>
    <link href="/cblog/2024/10/22/%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/"/>
    <url>/cblog/2024/10/22/%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>导入该类所在包，java.util.*</li><li>创建对象</li><li>调用功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> input.next();<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> input.nextInt();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运算符</title>
    <link href="/cblog/2024/10/22/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/cblog/2024/10/22/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法 - 相加运算符两侧的值</td><td align="left">A + B 等于 30</td></tr><tr><td align="left">-</td><td align="left">减法 - 左操作数减去右操作数</td><td align="left">A – B 等于 -10</td></tr><tr><td align="left">*</td><td align="left">乘法 - 相乘操作符两侧的值</td><td align="left">A * B等于200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除法 - 左操作数除以右操作数</td><td align="left">B &#x2F; A等于2</td></tr><tr><td align="left">％</td><td align="left">取余 - 左操作数除以右操作数的余数</td><td align="left">B%A等于0</td></tr><tr><td align="left">++</td><td align="left">自增: 操作数的值增加1</td><td align="left">B++ 或 ++B 等于 21（区别详见下文）</td></tr><tr><td align="left">–</td><td align="left">自减: 操作数的值减少1</td><td align="left">B– 或 –B 等于 19（区别详见下文）</td></tr></tbody></table><h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">（A &#x3D;&#x3D; B）为假。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td align="left">(A !&#x3D; B) 为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt; B）为假。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td align="left">（A &lt;B）为真。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt; &#x3D; B）为假。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A &lt;&#x3D; B）为真。</td></tr></tbody></table><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">如果相对应位都是1，则结果为1，否则为0</td><td align="left">（A＆B），得到12，即0000 1100</td></tr><tr><td align="left">|</td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td><td align="left">（A | B）得到61，即 0011 1101</td></tr><tr><td align="left">^</td><td align="left">如果相对应位值相同，则结果为0，否则为1</td><td align="left">（A ^ B）得到49，即 0011 0001</td></tr><tr><td align="left">〜</td><td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td align="left">（〜A）得到-61，即1100 0011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td align="left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td align="left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td align="left">（A &amp;&amp; B）为假。</td></tr><tr><td align="left">| |</td><td align="left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td align="left">（A | | B）为真。</td></tr><tr><td align="left">！</td><td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td align="left">！（A &amp;&amp; B）为真。</td></tr></tbody></table><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td align="left">C &#x3D; A + B将把A + B得到的值赋给C</td></tr><tr><td align="left">+ &#x3D;</td><td align="left">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td align="left">C + &#x3D; A等价于C &#x3D; C + A</td></tr><tr><td align="left">- &#x3D;</td><td align="left">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td align="left">C - &#x3D; A等价于C &#x3D; C - A</td></tr><tr><td align="left">* &#x3D;</td><td align="left">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td align="left">C * &#x3D; A等价于C &#x3D; C * A</td></tr><tr><td align="left">&#x2F; &#x3D;</td><td align="left">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td align="left">C &#x2F; &#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A</td></tr><tr><td align="left">（％）&#x3D;</td><td align="left">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td align="left">C％&#x3D; A等价于C &#x3D; C％A</td></tr><tr><td align="left">&lt;&lt; &#x3D;</td><td align="left">左移位赋值运算符</td><td align="left">C &lt;&lt; &#x3D; 2等价于C &#x3D; C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt; &#x3D;</td><td align="left">右移位赋值运算符</td><td align="left">C &gt;&gt; &#x3D; 2等价于C &#x3D; C &gt;&gt; 2</td></tr><tr><td align="left">＆&#x3D;</td><td align="left">按位与赋值运算符</td><td align="left">C＆&#x3D; 2等价于C &#x3D; C＆2</td></tr><tr><td align="left">^ &#x3D;</td><td align="left">按位异或赋值操作符</td><td align="left">C ^ &#x3D; 2等价于C &#x3D; C ^ 2</td></tr><tr><td align="left">| &#x3D;</td><td align="left">按位或赋值操作符</td><td align="left">C | &#x3D; 2等价于C &#x3D; C | 2</td></tr></tbody></table><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">variable</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (expression) ? value <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> : value <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h1><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;James&quot;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> name <span class="hljs-keyword">instanceof</span> String; <span class="hljs-comment">// 由于 name 是 String 类型，所以返回真</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java API 文档</title>
    <link href="/cblog/2024/10/22/Java-API-%E6%96%87%E6%A1%A3/"/>
    <url>/cblog/2024/10/22/Java-API-%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>网址</p><p><a href="https://www.matools.com/">码工具 - 代码在线工具箱 (matools.com)</a></p><p>java组织形式</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410221124745.png" alt="image-20241022112405613"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/cblog/2024/10/22/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/cblog/2024/10/22/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><table><thead><tr><th align="left">数据类型</th><th align="left">默认值</th><th>大小（字节）</th></tr></thead><tbody><tr><td align="left">int（整型默认int）</td><td align="left">0</td><td>4</td></tr><tr><td align="left">long（long常量后加’l’或’L’）</td><td align="left">0L</td><td>8</td></tr><tr><td align="left">short</td><td align="left">0</td><td>2</td></tr><tr><td align="left">char</td><td align="left">‘\u0000’</td><td>2</td></tr><tr><td align="left">byte</td><td align="left">0</td><td>1</td></tr><tr><td align="left">float（float常量须后加’f’或’F’）</td><td align="left">0.0f</td><td>4</td></tr><tr><td align="left">double（常量默认）</td><td align="left">0.0d</td><td>8</td></tr><tr><td align="left">boolean</td><td align="left">false</td><td></td></tr><tr><td align="left">引用类型（类、接口、数组）</td><td align="left">null</td><td></td></tr></tbody></table><h2 id="浮点数陷阱"><a href="#浮点数陷阱" class="headerlink" title="浮点数陷阱"></a>浮点数陷阱</h2><p>2.7和8.1&#x2F;2.7</p><p>8.1&#x2F;2.8&#x3D;2.69999999999999997</p><p><strong>注：浮点数比较时，对运行结果是小数进行相等判断要小心</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自己确定一个精度就可以，差值非常小就判断相等</span><br><span class="hljs-keyword">if</span>(Math.abs(nums11-nums12) &lt; <span class="hljs-number">0.0001</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符型本质-整数"><a href="#字符型本质-整数" class="headerlink" title="字符型本质-整数"></a>字符型本质-整数</h2><p>Unicode编码</p><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>自动类型转换：</strong>精度小的类型自动转换为精度大的数据类型</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">char</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">int</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">long</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">float</span>-&gt;</span>double<br><span class="hljs-function"><span class="hljs-title">byte</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">short</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">int</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">long</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">float</span>-&gt;</span>double<br></code></pre></td></tr></table></figure><p><strong>细节</strong>：（byte，short）和char之间不会相互自动转换；可以计算，计算时首先转为int</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，会损失精度或者溢出</p><p>需要加上强制转换符——<strong>（）</strong></p><h2 id="基本数据类型和String转换"><a href="#基本数据类型和String转换" class="headerlink" title="基本数据类型和String转换"></a>基本数据类型和String转换</h2><h3 id="基本数据类型转String"><a href="#基本数据类型转String" class="headerlink" title="基本数据类型转String"></a>基本数据类型转String</h3><p>基本数据类型+””即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Stting</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="String转基本数据类型"><a href="#String转基本数据类型" class="headerlink" title="String转基本数据类型"></a>String转基本数据类型</h3><p>基本数据类型的包装类调用parseXXX方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> Integer.parseInt(s1);<br></code></pre></td></tr></table></figure><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><table><thead><tr><th align="left">符号</th><th align="left">字符含义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行 (0x0a)</td></tr><tr><td align="left">\r</td><td align="left">回车 (0x0d)</td></tr><tr><td align="left">\f</td><td align="left">换页符(0x0c)</td></tr><tr><td align="left">\b</td><td align="left">退格 (0x08)</td></tr><tr><td align="left">\0</td><td align="left">空字符 (0x0)</td></tr><tr><td align="left">\s</td><td align="left">空格 (0x20)</td></tr><tr><td align="left">\t</td><td align="left">制表符</td></tr><tr><td align="left">&quot;</td><td align="left">双引号</td></tr><tr><td align="left">&#39;</td><td align="left">单引号</td></tr><tr><td align="left">\</td><td align="left">反斜杠</td></tr><tr><td align="left">\ddd</td><td align="left">八进制字符 (ddd)</td></tr><tr><td align="left">\uxxxx</td><td align="left">16进制Unicode字符 (xxxx)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOS</title>
    <link href="/cblog/2024/10/22/DOS/"/>
    <url>/cblog/2024/10/22/DOS/</url>
    
    <content type="html"><![CDATA[<h1 id="DOS原理"><a href="#DOS原理" class="headerlink" title="DOS原理"></a>DOS原理</h1><ol><li>命令行输入命令</li><li>命令被发给DOS系统</li><li>DOS系统接收指令，解析指令，执行指令</li></ol><p>常用DOS命令</p><p>　　（1）查看目录内容命令 DIR<br>　　（2）指定可执行文件搜索目录 PATH<br>　　（3）创建目录命令 MD<br>　　（4）打开指定目录命令 CD<br>　　（5）删除当前指定的子目录命令 RD<br>　　（6）改变当前盘符命令 C:<br>　　（7）文件复制命令 COPY<br>　　（8）显示文本文件内容命令 TYPE<br>　　（9）更改文件名命令 REN<br>　　（10）删除文件命令 DEL<br>        （11）清除屏幕命令 CLS<br>        （12）tree命令   查看目录树</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注释</title>
    <link href="/cblog/2024/10/22/%E6%B3%A8%E9%87%8A/"/>
    <url>/cblog/2024/10/22/%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="单行注释："><a href="#单行注释：" class="headerlink" title="单行注释：&#x2F;&#x2F;"></a>单行注释：&#x2F;&#x2F;</h1><h1 id="多行注释："><a href="#多行注释：" class="headerlink" title="多行注释：&#x2F;*   *&#x2F;"></a>多行注释：&#x2F;*   *&#x2F;</h1><h1 id="文档注释："><a href="#文档注释：" class="headerlink" title="文档注释：&#x2F;**    **&#x2F;"></a>文档注释：&#x2F;**    **&#x2F;</h1><p>文档注释负责描述类、接口、方法、构造器、成员属性。可以被JDK提供的工具 javadoc 所解析，自动生成一套以网页文件形式体现该程序说明文档的注释。</p><p><strong>写在类上面的JavaDoc</strong><br>写在类上的文档标注一般分为三段：</p><p>第一段：概要描述，通常用一句或者一段话简要描述该类的作用，以英文句号作为结束<br>第二段：详细描述，通常用一段或者多段话来详细描述该类的作用，一般每段话都以英文句号作为结束<br>第三段：文档标注，用于标注作者、创建时间、参阅类等信息</p><h2 id="javadoc-标签"><a href="#javadoc-标签" class="headerlink" title="javadoc 标签"></a>javadoc 标签</h2><p>javadoc 工具软件识别以下标签：</p><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author描述</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated描述</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">目录路径</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception 异常名称说明</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">从 immediate surperclass 继承 Comment。</td></tr><tr><td align="left">{@link}</td><td align="center">插入一个到另一个主题的链接</td><td align="center">{@link 名称文本}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">插入指向另一个主题的内嵌链接。</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param 参数名称说明</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return说明</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see锚</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial描述</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过 writeObject（ ） 和 writeExternal（ ）方法写的数据</td><td align="center">@serialData描述</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField 名称 类型 描述</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since 版本</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">@throws 标签与 @exception 标签具有相同的含义。</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">显示常量的值，该常量必须是静态字段。</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version 信息</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>203-移除链表元素</title>
    <link href="/cblog/2024/10/06/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <url>/cblog/2024/10/06/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410061624549.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,6,3,4,5,6]</span>, val = <span class="hljs-number">6</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>, val = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[7,7,7,7]</span>, val = 7<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>自己想的</p><p>从头到尾遍历链表，但是这个题目描述有点问题，说是head是头节点，实际上不是，因为题解中说明head是有val值的，那么head应该是首元结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummyHead;<br>        <span class="hljs-keyword">while</span> (p.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p.next.val == val)&#123;<br>                p.next = p.next.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                p = p.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>官方题解，递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        head.next = removeElements(head.next, val);<br>        <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>59-螺旋矩阵Ⅱ</title>
    <link href="/cblog/2024/10/06/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/"/>
    <url>/cblog/2024/10/06/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><p>Related Topics</p><p>数组</p><p>矩阵</p><p>模拟</p><p>👍 1332</p><p>👎 0</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>模拟数组填充方式，围绕数组外圈不断向内填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> matrix[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> n * n;<br>        <span class="hljs-keyword">while</span> (num &lt;= target) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                matrix[top][i] = num++;<br>            &#125;<br>            top++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>                matrix[i][right] = num++;<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>                matrix[bottom][i] = num++;<br>            &#125;<br>            bottom--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                matrix[i][left] = num++;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度<em>O</em>(<em>n</em>2)</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>57 插入区间</title>
    <link href="/cblog/2024/09/29/57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <url>/cblog/2024/09/29/57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 按照 <code>starti</code> 升序排列。同样给定一个区间 <code>newInterval = [start, end]</code> 表示另一个区间的开始和结束。</p><p>在 <code>intervals</code> 中插入区间 <code>newInterval</code>，使得 <code>intervals</code> 依然按照 <code>starti</code> 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p><p>返回插入之后的 <code>intervals</code>。</p><p><strong>注意</strong> 你不需要原地修改 <code>intervals</code>。你可以创建一个新数组然后返回它。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[12,16]</span>]</span>, newInterval = <span class="hljs-comment">[4,8]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,10]</span>,<span class="hljs-comment">[12,16]</span>]</span><br>解释：这是因为新的区间 <span class="hljs-comment">[4,8]</span> 与 <span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span> 重叠。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 105</code></li><li><code>intervals</code> 根据 <code>starti</code> 按 <strong>升序</strong> 排列</li><li><code>newInterval.length == 2</code></li><li><code>0 &lt;= start &lt;= end &lt;= 105</code></li></ul><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>不重叠，需满足：绿区间的右端，位于蓝区间的左端的左边，如 [1,2]。</p><p>则当前绿区间，推入 res 数组，指针 +1，考察下一个绿区间。<br>循环结束时，当前绿区间的屁股，就没落在蓝区间之前，有重叠了，如 [3,5]。<br>现在看重叠的。我们反过来想，没重叠，就要满足：绿区间的左端，落在蓝区间的屁股的后面，反之就有重叠：绿区间的左端 &lt;&#x3D; 蓝区间的右端，极端的例子就是 [8,10]。</p><p>和蓝有重叠的区间，会合并成一个区间：左端取蓝绿左端的较小者，右端取蓝绿右端的较大者，不断更新给蓝区间。<br>循环结束时，将蓝区间（它是合并后的新区间）推入 res 数组。<br>剩下的，都在蓝区间右边，不重叠。不用额外判断，依次推入 res 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>            List&lt;<span class="hljs-type">int</span>[]&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br><br>            <span class="hljs-comment">//左侧区间</span><br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>]) &#123;<br><br>                ret.add(intervals[i]);<br>                i++;<br><br>            &#125;<br><br>            <span class="hljs-comment">//区间重叠 开始节点 一定小于等于newInterval的结束值 结束结点一定大于等于newInterval的开始值</span><br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>] &amp;&amp; intervals[i][<span class="hljs-number">1</span>] &gt;= newInterval[<span class="hljs-number">0</span>]) &#123;<br>                newInterval[<span class="hljs-number">0</span>] = Math.min(intervals[i][<span class="hljs-number">0</span>], newInterval[<span class="hljs-number">0</span>]);<br>                newInterval[<span class="hljs-number">1</span>] = Math.max(newInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>                i++;<br>            &#125;<br>            ret.add(newInterval);<br><br><br>            <span class="hljs-comment">//右侧区间</span><br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &gt; newInterval[<span class="hljs-number">1</span>]) &#123;<br>                ret.add(intervals[i]);<br>                i++;<br>            &#125;<br><br><br>            <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ret.size()][];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; ret.size(); ++k) &#123;<br>                ans[k] = ret.get(k);<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LE</title>
    <link href="/cblog/2024/09/28/LEDA/"/>
    <url>/cblog/2024/09/28/LEDA/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>LEAD: Learning Decomposition for Source-free Universal Domain Adaptation</p><p>LEAD：无源通用域适应的学习分解</p><p>2024 CVPR</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>1.无源通用域适应存在<strong>协变量</strong>偏移。</p><p>2.现有解决方法聚焦于手动设计阈值或采用迭代聚类解决问题。阈值法不够灵活，聚类耗时长。</p><p>协变量转移是指<strong>源域和目标域的特征（输入数据）的分布不同，但给定特征的条件标签分布相同</strong>。<br> 标签转移是指<strong>源域和目标域的标签分布不同，但给定特征的条件标签分布是相同的</strong>。</p><h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><p>1.提出了一种用于无源通用域适应（SF-UniDA）的特征分解框架（LEAD），通过将特征分解为源已知和源未知部分来识别目标域的私有数据。</p><p>2.计算开销大大降低，对比其他传统聚类方法，LEAD在DomainNet数据集 仅需0.29秒计算伪标签决策边界，GLC 方法平均需要 897.65 秒 。</p><p>3.在四个数据集（Office-Home， Office-31， VisDA， DomainNet ）上进行广泛实验。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231615956.png" alt="image-20241023161548792"></p><p>其基本原理是，尽管特征空间可能发生变化，但目标私有数据预计将包含来自源模型的正交补（源未知）空间的更多组件。</p><ol><li>LEAD 首先执行正交分解，将目标特征分解为源已知和源未知部分</li><li>接下来，LEAD 采用二分量高斯混合模型来估计源未知特征分布</li><li>LEAD 设计了一个名为“共同得分”εi,c 的指标，该指标考虑了到目标原型和源锚点（从 ht θ 导出）的距离，以方便导出实例级决策边界ρi,c。</li></ol><h2 id="正交特征分解"><a href="#正交特征分解" class="headerlink" title="正交特征分解"></a>正交特征分解</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231618850.png" alt="image-20241023161818833"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231618264.png" alt="image-20241023161829243"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231618420.png" alt="image-20241023161841399"></p><h2 id="构建目标原型"><a href="#构建目标原型" class="headerlink" title="构建目标原型"></a>构建目标原型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231618421.png" alt="image-20241023161850403"></p><p><strong>Top-K</strong> <strong>采样</strong>：目标原型通过 <strong>Top-K</strong> <strong>采样</strong>的方法构建。具体来说，通过选择与特定类别特征最相似的 K 个样本来构建目标原型。<strong>目标原型****代表类别中心</strong>：目标原型可以被看作是目标域中某个类别的“典型代表”，它提供了一种方式来聚合目标域中同一类别的数据特征，以帮助模型更好地理解和分类。</p><h2 id="目标原型和源锚点距离"><a href="#目标原型和源锚点距离" class="headerlink" title="目标原型和源锚点距离"></a>目标原型和源锚点距离</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231618580.png" alt="image-20241023161854557"></p><h2 id="伪标签"><a href="#伪标签" class="headerlink" title="伪标签"></a>伪标签</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231618580.png"></p><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><ol><li><p>伪标签学习</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231620017.png" alt="image-20241023162013996"></p><p><strong>伪标签学习：</strong>使用从等式导出的伪标签。 我们应用交叉熵损失来进行模型自适应。尽管如此，我们并没有对所有伪标签赋予同等的重要性，而是引入了学生 t 分布来表征与每个伪标签相关的确定性，同时考虑了 ∥zt i,unk ∥2 和 ρi,c 之间的距离</p></li><li><p>特征分解正则化</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231620376.png" alt="image-20241023162036352"></p><p><strong>特征分解正则化（<strong><strong>Feature Decomposition Regularization</strong></strong>）</strong>：在文章中提到的这种正则化用于将目标域特征分为源已知部分和源未知部分，以便模型能够识别出目标域中特有的类别，从而减少对源域知识的过度依赖。</p><p>yt i &#x3D; 1或0表示伪标记为私有&#x2F;公共数据。</p></li><li><p>特征一致性正则化</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231621921.png" alt="image-20241023162116904"></p><p>通过增加特征空间中样本与其最近邻的相似性，使模型对目标域中的相似样本有一致的特征表示。</p></li><li><p>总损失函数</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231621576.png"></p></li></ol><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><ol><li>Office31：包含真实办公场景中的三个域（Amazon（A）、Dslr（D）和Webcam（W）），每个域有31个类（包含 4,652 个图像）。</li><li>Office-Home：分为艺术 (Ar)、剪贴画 (Cl)、产品 (Pr) 和现实世界 (Rw) 4个域的65个类别。（总计 15,500 张图像）</li><li>VisDA-C ： 包含 12 个类别。包括合成域（ Synthesis Domain, S ）和真实域（eal Domain, R）。其源域包括 152,397 个合成图像，目标域包括55,388 个真实世界图像。</li><li>DomainNet：包含 345 个类别的大约 60 万张图像。实验集中在三个域上（真实、素描、绘画）。</li></ol><p><strong>实验场景</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231622983.png" alt="image-20241023162251958"></p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><h2 id="结果评估"><a href="#结果评估" class="headerlink" title="结果评估"></a>结果评估</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231623299.png" alt="image-20241023162331274"></p><p><strong>H-score</strong> 的公式通常为<strong>公共类别分类准确率</strong>与<strong>私有类别识别准确率</strong>的<strong>调和平均值</strong></p><h2 id="OPDA"><a href="#OPDA" class="headerlink" title="OPDA"></a>OPDA</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231624711.png" alt="image-20241023162416682"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231624885.png" alt="image-20241023162426855"></p><h2 id="OSDA"><a href="#OSDA" class="headerlink" title="OSDA"></a>OSDA</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231624333.png" alt="image-20241023162444299"></p><h2 id="PDA"><a href="#PDA" class="headerlink" title="PDA"></a>PDA</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231624333.png"></p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231625889.png" alt="image-20241023162501868"></p><h2 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231625291.png" alt="image-20241023162506260"></p><h2 id="决策边界方法分析"><a href="#决策边界方法分析" class="headerlink" title="决策边界方法分析"></a>决策边界方法分析</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231625080.png" alt="image-20241023162546054"></p><h2 id="消融实验可视化"><a href="#消融实验可视化" class="headerlink" title="消融实验可视化"></a>消融实验可视化</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231626306.png" alt="image-20241023162607274"></p><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231626509.png" alt="image-20241023162615479"></p><h2 id="目标推理"><a href="#目标推理" class="headerlink" title="目标推理"></a>目标推理</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231626325.png" alt="image-20241023162631307"></p><h2 id="近邻分析"><a href="#近邻分析" class="headerlink" title="近邻分析"></a>近邻分析</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231626855.png" alt="image-20241023162646813"></p><h2 id="特征可视化"><a href="#特征可视化" class="headerlink" title="特征可视化"></a>特征可视化</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202410231626670.png" alt="image-20241023162656636"></p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>209.长度最小的子数组</title>
    <link href="/cblog/2024/09/28/209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/cblog/2024/09/28/209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p><p>找出该数组中满足其总和大于等于<strong> </strong><code>target</code><strong> </strong>的长度最小的 <strong><span data-keyword="subarray-nonempty">子数组</span></strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]<strong>输出：</strong>2<strong>解释：</strong>子数组&nbsp;<span><code>[4,3]</code></span>&nbsp;是该条件下的长度最小的子数组。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>target = 4, nums = [1,4,4]<strong>输出：</strong>1</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>  <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>  <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li> </ul><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>  <li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li> </ul><div><div>Related Topics</div><div><li>数组</li><li>二分查找</li><li>前缀和</li><li>滑动窗口</li></div></div><br><div><li>👍 2236</li><li>👎 0</li></div><h1 id="解法1-暴力"><a href="#解法1-暴力" class="headerlink" title="解法1 暴力"></a>解法1 暴力</h1><p>暴力求解</p><p>O(n2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123; <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.size(); j++) &#123; <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) &#123; <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="解法2-滑动窗口"><a href="#解法2-滑动窗口" class="headerlink" title="解法2 滑动窗口"></a>解法2 滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>                sum += nums[right];<br>                <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                    result = Math.min(result, right - left + <span class="hljs-number">1</span>);<br>                    sum -= nums[left++];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>977有序数组的平方</title>
    <link href="/cblog/2024/09/28/977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <url>/cblog/2024/09/28/977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [-4,-1,0,3,10]<strong>输出：</strong>[0,1,9,16,100]<strong>解释：</strong>平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [-7,-3,2,3,11]<strong>输出：</strong>[4,9,9,49,121]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code><span>1 &lt;= nums.length &lt;= </span>10<sup>4</sup></code></li>  <li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>  <li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li> </ul><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>  <li>请你<span style="color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</span></li> </ul><div><div>Related Topics</div><div><li>数组</li><li>双指针</li><li>排序</li></div></div><br><div><li>👍 1041</li><li>👎 0</li></div><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力求解，先平方再排序</p><p>复杂度 O(n + nlog n)</p><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>双指针，新建一个数组，前后两个指针，分别比较大小，添加到新数组。</p><p>我觉得原理有点像有序数组合并，只不过这个需要平方之后比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> sqrt[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;<br>                    sqrt[k] = nums[j] * nums[j];<br>                    j = j - <span class="hljs-number">1</span>;<br>                    k = k - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123;<br>                    sqrt[k] = nums[i] * nums[i];<br>                    i = i + <span class="hljs-number">1</span>;<br>                    k = k - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sqrt;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27.移除元素</title>
    <link href="/cblog/2024/09/27/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <url>/cblog/2024/09/27/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个数组 <code>nums</code><em>&nbsp;</em>和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地</a></strong> 移除所有数值等于&nbsp;<code>val</code><em>&nbsp;</em>的元素。元素的顺序可能发生改变。然后返回&nbsp;<code>nums</code>&nbsp;中与&nbsp;<code>val</code>&nbsp;不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul>  <li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>  <li>返回 <code>k</code>。</li> </ul><p><strong>用户评测：</strong></p><p>评测机将使用以下代码测试您的解决方案：</p><pre>int[] nums = [...]; // 输入数组int val = ...; // 要移除的值int[] expectedNums = [...]; // 长度正确的预期答案。                            // 它以不等于 val 的值排序。int k = removeElement(nums, val); // 调用你的实现assert k == expectedNums.length;sort(nums, 0, k); // 排序 nums 的前 k 个元素for (int i = 0; i &lt; actualLength; i++) {    assert nums[i] == expectedNums[i];}</pre><p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [3,2,2,3], val = 3<strong>输出：</strong>2, nums = [2,2,_,_]<strong>解释：</strong>你的函数函数应该返回 k = 2, 并且 nums<em> </em>中的前两个元素均为 2。你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [0,1,2,2,3,0,4,2], val = 2<strong>输出：</strong>5, nums = [0,1,4,0,3,_,_,_]<strong>解释：</strong>你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。注意这五个元素可以任意顺序返回。你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>  <li><code>0 &lt;= nums.length &lt;= 100</code></li>  <li><code>0 &lt;= nums[i] &lt;= 50</code></li>  <li><code>0 &lt;= val &lt;= 100</code></li> </ul><div><div>Related Topics</div><div><li>数组</li><li>双指针</li></div></div><br><div><li>👍 2300</li><li>👎 0</li></div><h1 id="解法1-前后位置交换"><a href="#解法1-前后位置交换" class="headerlink" title="解法1 前后位置交换"></a>解法1 前后位置交换</h1><p>我的解题思路：前后指针，类似于二分法，前后同时开始查找，如果前面找到与target相同的值，那就从后面找不同值，跟前面的值交换。直到前指针大于后指针，退出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>               <span class="hljs-keyword">if</span> (nums[start] == val &amp;&amp; nums[end] != val) &#123;<br>                   nums[start] = nums[end];<br>                   end = end - <span class="hljs-number">1</span>;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[start] == val &amp;&amp; nums[end] == val) &#123;<br>                   end = end - <span class="hljs-number">1</span>;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[start] != val) &#123;<br>                   start = start + <span class="hljs-number">1</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> start;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="解法2-快慢指针"><a href="#解法2-快慢指针" class="headerlink" title="解法2 快慢指针"></a>解法2 快慢指针</h1><p>题解中的方法思路：一个快指针，一个慢指针。慢指针搜索到与target相同的值就停下，快指针找到与target不同的值就赋值给慢指针的值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> removeElement(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> val) &#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>                nums[slow] = nums[fast];<br>                slow = slow + <span class="hljs-number">1</span>;<br>            &#125;<br>            fast = fast + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode</title>
    <link href="/cblog/2024/09/07/leetcode/"/>
    <url>/cblog/2024/09/07/leetcode/</url>
    
    <content type="html"><![CDATA[<h1 id="intellij-leetcode-editor-github"><a href="#intellij-leetcode-editor-github" class="headerlink" title="intellij+leetcode-editor+github"></a>intellij+leetcode-editor+github</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>打开idea的插件市场，搜索leetcode-editor下载安装</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072053437.png" alt="image-20240907205327390"></p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>创建新项目选择创建git仓库</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072055698.png" alt="image-20240907205532666"></p><h2 id="打开项目"><a href="#打开项目" class="headerlink" title="打开项目"></a>打开项目</h2><p>左侧有leetcode标记</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072056207.png" alt="image-20240907205649171"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在src目录下新建一个软件包，取名为：<code>leetcode.editor.cn</code>，这个软件包的名字请<strong>不要变动</strong>。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072058016.png" alt="image-20240907205828974"></p><p><code>Main.java</code>可以删除</p><h2 id="配置插件属性"><a href="#配置插件属性" class="headerlink" title="配置插件属性"></a>配置插件属性</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072059033.png" alt="image-20240907205938971"></p><ol><li><p>点击左侧边栏leetcode标志</p></li><li><p>点击打开leetcode-editor设置页面</p></li><li><p>选择CodeType为你的常用编程语言，这里选择Java</p></li><li><p>输入Leetcode登陆用户名</p></li><li><p>输入Leetcode登陆密码</p></li><li><p>TempFilePath请输入&#x2F;你的项目根目录&#x2F;src&#x2F;，这里是 ~&#x2F;leetcode_codeworks&#x2F;src，这样能确保以后所有的代码文件都保存在我们创建好的软件包leetcode.editor.cn内，这是插件规定好的缓存目录。</p></li><li><p>勾选 Custom Template</p></li><li><p>勾选 Cookie</p></li><li><p>勾选 HtmlContent</p></li><li><p>点击确定</p></li></ol><h2 id="登录leetcode"><a href="#登录leetcode" class="headerlink" title="登录leetcode"></a>登录leetcode</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072103881.png" alt="image-20240907210327844"></p><h3 id="解决cookie-is-null"><a href="#解决cookie-is-null" class="headerlink" title="解决cookie is null"></a>解决cookie is null</h3><p>网上说可以通过在网页版复制cookie粘贴，然后登录，但是我没找到复制到哪里，所以我在设置里取消了勾选cookie，然后点击登陆的时候，会弹出类似网页版的登录，在这里也可以登录成功。</p><h2 id="怎么做题？"><a href="#怎么做题？" class="headerlink" title="怎么做题？"></a>怎么做题？</h2><p>以下是随便打开一道题目的界面，左边仍然是题目列表，中间是题目描述，右边是我们的编码窗口，其中已经给出了题目描述和Solution类以及其成员方法。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072116520.png" alt="image-20240907211617405"></p><p>下图中，圆圈所指示的分别是<strong>运行用例</strong>，以及<strong>保存提交</strong>。点击这两个按钮后，代码并不会在本地运行，而是会将<code>--BEGIN--</code>和<code>--END--</code>之间的代码提交到<code>leetcode.cn</code>，在线编译运行。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072117814.png" alt="image-20240907211754784"></p><p>点击左边侧边栏的项目按钮，先前新建的<code>leetcode.editor.cn</code>软件包下已经创建了一个<code>doc</code>文件夹(存放题目信息、提交信息等文件)，<code>***.java</code>这是代码编辑栏里的代码所保存的文件。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072119810.png" alt="image-20240907211930774"></p><p>但是文件报红，显然不能正常调试</p><p>为了让插件能生成出我们能直接运行的文件的样子，我们需要<strong>自定义生成模板</strong>。请打开<strong>插件设置</strong>页面。需要设置的是<code>Code FileName</code>以及<code>Code Template</code>栏。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/202409072121256.png" alt="image-20240907212103219"></p><p>这里有博主已经调好了，非常感谢！！</p><p><strong>Code FileName:</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">ID<span class="hljs-variable">$&#123;</span>question.frontendQuestionId&#125;<span class="hljs-variable">$!</span>velocityTool.camelCaseName(<span class="hljs-variable">$&#123;</span>question.titleSlug&#125;)<br></code></pre></td></tr></table></figure><p><strong>Code Template:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode.editor.cn;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ID$</span>&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ID$</span>&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br><span class="hljs-comment">//执行测试</span><br><br>System.out.println(sb);<br>&#125;<br>$&#123;question.code&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>保存后，再打开双击一道题</strong>，我们发现这已经是可以调试的样子了，可以打断点，也有intelli的自动补全等等功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>如何在IDEA优雅刷leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uncertainty-Aware Pseudo-Label Filtering for Source-Free Unsupervised Domain Adaptation</title>
    <link href="/cblog/2024/07/22/Uncertainty-Aware-Pseudo-Label-Filtering-for-Source-Free-Unsupervised-Domain-Adaptation/"/>
    <url>/cblog/2024/07/22/Uncertainty-Aware-Pseudo-Label-Filtering-for-Source-Free-Unsupervised-Domain-Adaptation/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><strong>Uncertainty-Aware Pseudo-Label Filtering for Source-Free Unsupervised Domain Adaptation</strong></p><p><strong>用于无源无监督域适应的不确定性感知伪标签过滤</strong></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p><strong>现有的启发式噪声伪标签过滤方法都涉及引入额外的模型，这些模型对模型假设敏感并且可能引入额外的错误或错误标签。</strong></p><p>（启发式噪声（heuristic noise）是指在数据标签中引入的基于启发式方法而产生的错误或不准确标签。</p><p>使用启发式规则或算法对数据进行标注，但这些规则或算法可能并不总是准确，从而导致噪声标签的产生。）</p><p><strong>在这项工作中，我们提出了一种称为不确定性感知伪标签过滤适应（UPA）的方法，以从粗到细的方式有效地解决这个问题。</strong></p><ol><li><p><strong>首先介绍一个名为自适应伪标签选择（APS）的样本选择模块，它负责过滤嘈杂的伪标签。</strong></p><p>APS 利用简单的样本不确定性估计方法，通过聚合邻近样本的知识，并选择置信样本作为干净的伪标记。</p></li><li><p><strong>此外，我们结合了类感知对比学习（CACL），通过学习由伪标签监督的鲁棒的成对表示来减轻伪标签噪声的记忆。</strong></p></li><li><p><strong>通过在三个广泛使用的基准上进行的大量实验，我们证明了我们提出的方法实现了与最先进的 SFUDA 方法相当的竞争性能。</strong></p></li></ol><h1 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h1><p>SFUDA 的目标是将预训练模型（最初在源域的标记训练集上进行训练）转移到仅提供对未标记训练数据的访问的目标域。</p><p>通常，SFUDA 方法旨在最大限度地利用类感知信息，前提是只能访问目标数据。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1.SFUDA 中，自训练可以迭代选择置信目标样本作为伪标记样本来指导目标模型学习。</p><p>2.现有的启发式噪声伪标签过滤方法引入额外的模型，可能会引入额外的错误标签。</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>1.提出UPA伪标签过滤框架，能够有效解决高伪标签噪声的挑战，而不需要额外的模型来进行不确定性估计。引入了一种不确定性感知机制——APS，有效过滤嘈杂伪标签。</p><p>2.引入了一种语义一致性学习策略，该策略结合了伪标记集的类对比学习。这种策略可以防止标签噪声的记忆并确保稳健的学习。</p><p>3.在三个标准数据集（Office、Office-Home 和 VisDA-C）进行了广泛的实验。</p><h1 id="2、Related-Work"><a href="#2、Related-Work" class="headerlink" title="2、Related Work"></a>2、Related Work</h1><h2 id="2-1-UDA"><a href="#2-1-UDA" class="headerlink" title="2.1 UDA"></a>2.1 UDA</h2><p>UDA 方法的开发是为了减少源域和目标域之间的分布差异。这些方法大致可分为两大类。</p><p>第一种方法侧重于通过执行特征变换来最小化跨域分布散度的各种指标。</p><p>第二种方法采用自学习方案。在该方案中，利用源域的标记数据来标记未标记的数据，然后采用自训练或伪标记方法。</p><h2 id="2-2-SFUDA"><a href="#2-2-SFUDA" class="headerlink" title="2.2 SFUDA"></a>2.2 SFUDA</h2><p>SFUDA 专注于将知识从预训练的源模型转移到目标域，而不需要标记源数据。现有的 SFUDA 方法可分为两大类。</p><p>第一组方法侧重于“跨域对齐”策略。这些方法在源域假设下或通过利用源模型信息再现虚假源知识。</p><p>第二组方法由自学习方法组成，解决模型预测不可靠的问题。不确定性估计的基础是模型不确定性或数据不确定性 。</p><h2 id="2-3-使用嘈杂的标签学习"><a href="#2-3-使用嘈杂的标签学习" class="headerlink" title="2.3 使用嘈杂的标签学习"></a>2.3 使用嘈杂的标签学习</h2><p>最近，监督对比学习 Supervised Contrastive Learning (SCL) 也被用于带有噪声标签的学习 </p><h1 id="3、Method"><a href="#3、Method" class="headerlink" title="3、Method"></a>3、Method</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240805001307235.png" alt="image-20240805001307235"></p><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h2 id="问题设置"><a href="#问题设置" class="headerlink" title="问题设置"></a>问题设置</h2><h2 id="伪标签介绍（SHOT筛选）"><a href="#伪标签介绍（SHOT筛选）" class="headerlink" title="伪标签介绍（SHOT筛选）"></a>伪标签介绍（SHOT筛选）</h2><p>伪标签生成过程的概述：它使用模型的<strong>预测概率</strong>和<strong>类别样本数量</strong>作为权重来估计类别特征分布。</p><h3 id="伪标签生成过程的详细步骤"><a href="#伪标签生成过程的详细步骤" class="headerlink" title="伪标签生成过程的详细步骤"></a>伪标签生成过程的详细步骤</h3><p>伪标签生成过程首先根据分配给目标训练样本的预测概率聚合特征。</p><h3 id="类别特征聚合公式"><a href="#类别特征聚合公式" class="headerlink" title="类别特征聚合公式"></a>类别特征聚合公式</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804163432925.png" alt="image-20240804163432925"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804164048541.png" alt="image-20240804164048541"></p><h3 id="中间伪标签的生成"><a href="#中间伪标签的生成" class="headerlink" title="中间伪标签的生成"></a>中间伪标签的生成</h3><p>然后，通过将样本分配给特征表示空间中最近的类别中心（根据余弦相似性度量）来生成中间伪标签 ：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804163830413.png" alt="image-20240804163830413"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804164105265.png" alt="image-20240804164105265"></p><h3 id="最终类别质心的计算"><a href="#最终类别质心的计算" class="headerlink" title="最终类别质心的计算"></a>最终类别质心的计算</h3><p>这部分描述了最终类别质心的计算过程，并生成最终的伪标签。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804212204513.png" alt="image-20240804212204513"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804212248032.png" alt="image-20240804212248032"></p><h3 id="更新伪标签"><a href="#更新伪标签" class="headerlink" title="更新伪标签"></a>更新伪标签</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804212351925.png" alt="image-20240804212351925"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804212402639.png" alt="image-20240804212402639"></p><h2 id="3-2-自适应伪标签选择"><a href="#3-2-自适应伪标签选择" class="headerlink" title="3.2 自适应伪标签选择"></a>3.2 自适应伪标签选择</h2><p>在生成伪标签时会考虑整体数据表示分布，这可能导致噪声。</p><p><strong>假设：</strong></p><ol><li><strong>易于聚类的样本</strong>：在特征空间g(xt) 中，容易聚类的样本由于同类样本特征相似，包含较高程度的领域共享信息。</li><li><strong>不确定样本</strong>：大量不确定样本位于聚类中心之间，这主要是由于领域之间的分布偏移引起的。</li></ol><p>受到上述假设的启发，作者提出了一种新的伪标签选择机制，称为<strong>APS（Adaptive Pseudo-Label Selection）</strong>。该机制通过迭代地通过附近邻居来估计样本的不确定性。</p><p>先验概率：在没有抽牌之前，我们认为抽到红桃（或任何一种花色）的概率是均等的，即 P(红桃)&#x3D;1&#x2F;4</p><p>后验概率：现在我们知道抽到的牌是红色的，我们要计算这张牌是红桃的概率。红桃和方块各占26张牌中的一半。</p><p>根据余弦距离构造最近邻Nt，利用Nt进行基于距离的投票，估计样本xt的后验概率。</p><p>（4）<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804215442418.png" alt="image-20240804215442418"></p><p>伪标签更新公式</p><p>（5）<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804215559173.png" alt="image-20240804215559173"></p><p>根据经验观察，(4)——(5)——(4) 两次迭代就可以收敛。</p><p>置信度得分 qt 定义如下：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804215831150.png" alt="image-20240804215831150"></p><h3 id="网络结构图"><a href="#网络结构图" class="headerlink" title="网络结构图"></a>网络结构图</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804220112017.png" alt="image-20240804220112017"></p><p>图 2. 用于解决 SFUDA 任务的 UPA 综合框架。 LIM 适用于所有样品。 APS 模块执行两轮不确定性估计，样本 Ixk∈Nt [ˆ yk &#x3D; e yt] 对 qt 有用。 qt 在每个类内进行排序，形成置信样本集 H，然后将 LCE 和 LCL 应用于 H。具体来说，每个样本 xi 及其强增强视图 x′ i 用于类对比（由彩色矩阵表示）块）拼箱。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804220158569.png" alt="image-20240804220158569"></p><p>图 3. 使用余弦相似度 s 计算置信度得分 qt。</p><h3 id="伪标签选择标准"><a href="#伪标签选择标准" class="headerlink" title="伪标签选择标准"></a>伪标签选择标准</h3><p>基于模型预测不确定性假设，为了避免在伪标签选择中遗漏类别，每个伪类中的样本首先根据每个时期的置信度得分 qt 进行排序。然后，选择每个伪类的前 γ% 置信样本。然后将这些选定的样本分组为置信样本集 H。</p><h2 id="3-3-类感知对比学习"><a href="#3-3-类感知对比学习" class="headerlink" title="3.3 类感知对比学习"></a>3.3 类感知对比学习</h2><h3 id="类感知对比学习的基本概念"><a href="#类感知对比学习的基本概念" class="headerlink" title="类感知对比学习的基本概念"></a>类感知对比学习的基本概念</h3><ol><li><strong>类感知（Class-Aware）</strong>：在对比学习过程中，考虑样本所属的类别信息。通过引入类别标签，增强模型对同类样本和不同类样本的区分能力。</li><li><strong>对比学习（Contrastive Learning）</strong>：通过对比样本对之间的相似性和差异性来学习数据的表示。通常使用正样本对和负样本对来训练模型，使相似的样本对靠近，不相似的样本对分开。</li></ol><h3 id="3-3-1损失函数"><a href="#3-3-1损失函数" class="headerlink" title="3.3.1损失函数"></a>3.3.1损失函数</h3><p>具体来说，在大小为 B 的小批量内，我们将 i ∈ I &#x3D; {1, · · · , 2B} 定义为任意增强训练样本的索引。考虑如图 4 所示的强增强视图。为了创建正对，如果所选置信样本共享相同的伪类，则将它们彻底耦合。形式上，锚点 i 的正对集形成为：</p><p><strong>正样本对</strong>：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804222023412.png" alt="image-20240804222023412"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804222504654.png" alt="image-20240804222504654"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804222717194.png" alt="image-20240804222717194"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>1、类对比损失公式为：</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804222602662.png" alt="image-20240804222602662"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804223027617.png" alt="image-20240804223027617"></p><p><strong>2、交叉熵损失</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804224808127.png" alt="image-20240804224808127"></p><p><strong>3、信息最大化损失</strong></p><p>信息最大化损失LIM[22]旨在从输入数据中提取和利用相关信息并对所有目标数据进行聚类。</p><p><strong>4、最终损失函数</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804231201975.png" alt="image-20240804231201975"></p><p>其中 β &gt; 0 作为平衡因子。</p><h2 id="3-4渐进式伪标签选择"><a href="#3-4渐进式伪标签选择" class="headerlink" title="3.4渐进式伪标签选择"></a>3.4渐进式伪标签选择</h2><p>考虑到源域和目标域之间经常存在大量域转移，在单次迭代中准确确定完整的真实伪标签集是不切实际的。因此，我们采用渐进策略，在两个步骤之间交替：（1）选择干净的伪标记样本，（2）相应地调整模型。这种方法与深度学习中常用的基于时代的协议非常吻合。算法 1 概述了 UPA 的完整训练过程。</p><h1 id="4、实施"><a href="#4、实施" class="headerlink" title="4、实施"></a>4、实施</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><strong>Office：</strong>Office 是一个小型数据集，包含真实办公场景中的三个域（Amazon（A）、Dslr（D）和Webcam（W）），每个域有31个类。</p><p><strong>Office-Home：</strong>Office-Home是一个媒体大小的数据集，包含 65 个类别，跨越四个领域：艺术 (Ar)、剪贴画 (Cl)、产品 (Pr) 和现实世界 (Rw)。 </p><p><strong>VisDA-C</strong>：VisDA-C 是一个包含 12 个类别的大型数据集，具有从源合成（S）域到目标真实（R）域的适应任务。</p><p><strong>DomainNet-126</strong>：DomainNet-126 是先前工作使用的 DomainNet [28] 的子集。它有来自 4 个领域（真实、素描、剪贴画、绘画）的 126 个类，我们评估从 4 个领域构建的 7 个领域转换。</p><h2 id="Baselines"><a href="#Baselines" class="headerlink" title="Baselines"></a>Baselines</h2><p>对于源可用的无监督域适应，我们将我们提出的方法与许多基线进行比较：CDAN [23]、MCC [13]、MDD [48]、BCDM [20]、FixBi [25]、CAN [14] 和 SRDC [37]。对于无源无监督域适应，我们与以下基线进行比较：3C-GAN [19]、U-SFAN [32]、DIPE [43]、HCL [12]、NRC [46]、CoWA-JMDS [16]、 AdaContrast [2]、CDCL [44]、Tent [42]、D-MCD [5]、VDMDA [38]、SSNLL [3] 和 SHOT [22]。</p><h2 id="在源域上进行预训练"><a href="#在源域上进行预训练" class="headerlink" title="在源域上进行预训练"></a>在源域上进行预训练</h2><p>为了确保与以前的方法[3,16,22,32,38,43,44,46]进行全面比较，我们使用相同的ResNet[10]模型。特别是，我们将 ResNet-50 用于 Office、Office-Home 和 DomainNet126，用于 Visda-C 的 ResNet101。采用 ResNet 的特征提取器组件作为主干，而最终的全连接 (FC) 层则替换为瓶颈层和特定于任务的 FC 层。</p><h2 id="目标域的适应"><a href="#目标域的适应" class="headerlink" title="目标域的适应"></a>目标域的适应</h2><p>目标模型使用预先训练的源模型进行初始化，并且分类器权重在整个 SFUDA 阶段保持固定。采用随机梯度下降优化器，动量为 0.9，权重衰减为 1e-3。训练批量大小设置为 64。对于 Office、Office-Home 和 DomainNet-126 数据集，初始学习率 η0 配置为 1e-2，而对于 VisDA-C，则设置为 1e-3。在训练过程中，瓶颈层的学习率确定为骨干层的10倍。训练过程跨越 15 个 epoch，从第一个 epoch 期间的线性学习率预热开始。在预热阶段之后，学习率根据余弦衰减时间表逐渐降低，没有任何重新启动。为了确保训练期间的收敛，我们根据经验将损失权重设置为 β &#x3D; 0.3。此外，还定义了以下超参数：Office、Office-Home、DomainNet-126 和 VisDAC 数据集的温度 τ &#x3D; 0.1、邻域大小 K &#x3D; 4 和比率 γ &#x3D; 0.6&#x2F;0.6&#x2F;0.6&#x2F;0.8。对比学习中的数据增强遵循与 MoCov2 [4] 相同的设置。</p><h1 id="5、实验"><a href="#5、实验" class="headerlink" title="5、实验"></a>5、实验</h1><h2 id="5-1实验结果"><a href="#5-1实验结果" class="headerlink" title="5.1实验结果"></a>5.1实验结果</h2><h3 id="VisDA-C-结果"><a href="#VisDA-C-结果" class="headerlink" title="VisDA-C 结果"></a>VisDA-C 结果</h3><p>如表 1 所示，我们的方法比基本方法 SHOT (82.9%) 取得了显着的改进，显着提高了 5.8%。此外，我们的方法超越了之前最先进的 SFUDA 方法 1.2%。与其他 UDA 方法相比，显着提高了 1.5%。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804233116466.png" alt="image-20240804233116466"></p><h3 id="Office-Home结果"><a href="#Office-Home结果" class="headerlink" title="Office-Home结果"></a>Office-Home结果</h3><p>表 2 显示了 Office-Home 数据集上的实验结果。我们的方法显示出显着的改进，与 SHOT 基线相比实现了 1.2% 的大幅提升。值得注意的是，我们的方法优于现有最先进的 SFUDA 和 UDA 方法，建立了新的基准。具体来说，在 5 个域转移任务中实现了最高精度，包括 Cl→Pr 和 Cl→Rw。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804233129250.png" alt="image-20240804233129250"></p><h3 id="Office结果"><a href="#Office结果" class="headerlink" title="Office结果"></a>Office结果</h3><p>Office 数据集的结果如表 3 所示。尽管训练数据集的大小有限，但我们的方法表现出与最先进的 SFUDA 方法相当的性能。具体来说，我们观察到与基线 SHOT 方法相比，显着提高了 1.3% 以上。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804233247972.png" alt="image-20240804233247972"></p><h3 id="Domainnet-126-结果"><a href="#Domainnet-126-结果" class="headerlink" title="Domainnet-126 结果"></a>Domainnet-126 结果</h3><p>表 4 报告了 7 个域转移任务的结果。在这些方法中，我们的 UPA 遵循 SFUDA 方法，以 68.0% 的平均准确率脱颖而出。与其他方法相比，UPA 不仅超出基线 SHOT 0.9%，而且优于其他竞争方法。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804234103392.png" alt="image-20240804234103392"></p><h2 id="5-2-消融实验"><a href="#5-2-消融实验" class="headerlink" title="5.2 消融实验"></a>5.2 消融实验</h2><p>我们进行了一系列消融研究实验，以更好地阐明我们方法的有效性。子模块的消融。我们进行了一系列全面的消融研究实验，以进一步研究我们提出的方法的有效性。在表 5 中，我们展示了对三个数据集的子组件消融研究的结果。具体来说，我们将我们的方法 (Methods.3) 与其他两个变体进行比较：Methods.1（指的是 SHOT 方法）和Methods.2（包括 APS 模块，其中交叉熵损失 (LCE) 仅应用于置信样本集H.</p><p>仅考虑 APS 时，我们观察到 Office、OfficeHome 和 VisDA-C 数据集分别显着提高了 0.9%、0.9% 和 1.3%。</p><p>通过结合对比学习来减轻噪声标签记忆的影响，我们的方法在 Office 和 Office-Home 数据集上分别实现了 0.4% 和 0.3% 的额外性能改进。值得注意的是，CACL 模块在 VisDA-C 数据集上表现出 4.5% 的显着性能提升。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804234551403.png" alt="image-20240804234551403"></p><p>伪标签选择的有效性。进行消融研究以验证我们的 APS 模块中伪标签不确定性估计方法的有效性。表 6 比较了估计伪标签不确定性的三种不同方法：(1) 与相应伪标签 (Prob) 相关的模型概率 φ(xt)，(2) 预测 φ(xt) 的负熵 (Ent) ，(3) 与聚类中心 d(g(xt), μ(1)) 的余弦相似度 (Cossim)。结果表明，我们的 APS 模块在 VisDA-C 数据集的传输任务 S→R 和 Office-Home 数据集的 Ar→Pr 任务上实现了最高性能。这表明使用 KNN 近邻的不确定性估计优于其他方法。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804234752129.png" alt="image-20240804234752129"></p><p>APS 的迭代细化。 APS中不确定性估计的迭代细化旨在提高伪标签分布感知的准确性。为了验证我们的迭代设计，我们进行了实验并在表 7 中列出了结果。该表表明，合并第二次迭代可以使 VisDA-C 数据集显着提高 1.5%，使 Office 数据集显着提高 0.4%。然而，额外的迭代不会带来进一步的改进，这表明两次迭代为置信度得分估计提供了最佳数量。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804234846039.png" alt="image-20240804234846039"></p><p>防止标签噪音记忆。所提出的方法 CACL 通过利用选定的干净伪标签来合并类别对比学习 [15]。这种集成的目的是促进同一类样本的不同视图中一致的概率输出。为了评估它在减轻伪标签噪音记忆方面的功效，我们进行了一项比较实验。图 7 所示的结果说明了所选伪标签的准确性。很明显，CACL 显着提高了选择过程的精度，凸显了其在提高 APS 整体性能方面的有效性。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804235013697.png" alt="image-20240804235013697"></p><p>超参数的影响。我们进行了一项评估，以评估我们的方法 UPA 中三个关键超参数对 Office 和 VisDA-C 数据集的敏感性。这些超参数如下：（1）置信样本选择比，表示为γ，（2）LCL中的温度参数τ，（3）最近邻居的数量，表示为K。公平比较，所有其他参数均保持默认值。</p><p>结果如图 5 所示，表明这些超参数对模型性能的敏感性较低。这一特性在实际应用中非常有利。尽管 VisDA-C 数据集上 γ 的选择更为关键，因为它取决于源模型的性能和目标数据集的特征，但我们的方法在各种 γ 值上始终优于先前的方法，范围从0.5至0.9。值得注意的是，我们使用的默认训练参数对于 VisDA-C 数据集可能不是最佳的。然而，当面对这些参数的变化时，UPA 表现出相对稳定性。这使我们能够选择广泛的参数用于测试目的，同时尽可能在多个数据集上保持一致的训练参数。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804235354268.png" alt="image-20240804235354268"></p><h2 id="5-3可视化和分析"><a href="#5-3可视化和分析" class="headerlink" title="5.3可视化和分析"></a>5.3可视化和分析</h2><h3 id="模型行为可视化"><a href="#模型行为可视化" class="headerlink" title="模型行为可视化"></a>模型行为可视化</h3><p>为了评估我们提出的方法 UPA 的视觉效果，我们使用 t-SNE 可视化对 Office-Home 数据集的 Ar→Pr 基准进行了全面分析 [40]。比较两个角度的结果：域转移（图6a与图6b）和类别辨别能力（图6c与图6d）。图 6a 显示，对目标域数据的初始预测表现出聚类特征，但具有显着的类重叠。然而，随着UPA的整合，结构域偏移显着减少，导致更明显的聚类结构（图6b）。此外，UPA 实现了清晰的类边界，如视觉比较所示（图 6c 与图 6d）。这些视觉见解为我们提出的方法的辨别能力提供了令人信服的证据，突出了其在增强领域适应性能方面的有效性。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240804235919125.png" alt="image-20240804235919125"></p><p>图 6. 使用 ResNet50 对 SFUDA 任务 Ar→Pr（办公室-家庭）进行 t-SNE 可视化。 (a)(b)：适应前后的源特征（即红点）和目标特征（即蓝点）可视化； (c)(d)：适应前后目标特征的类分布（即不同颜色）。</p><p><strong>训练曲线</strong></p><p>UPA（无 CACL）和 UPA 方法在两个适应任务中的准确性进展如图 8a 和图 8b 所示。结果明确地证明了我们的方法所实现的准确率的快速且持续的增长。值得注意的是，我们的方法在这两项任务上表现出快速收敛，通常在大约 10 个时期内，进一步证实了其有效性并验证了其性能。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/1-s2.0-S0925231223013139-gr8_lrg.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>肺癌生存期预测</title>
    <link href="/cblog/2024/07/02/%E8%82%BA%E7%99%8C%E7%94%9F%E5%AD%98%E6%9C%9F%E9%A2%84%E6%B5%8B/"/>
    <url>/cblog/2024/07/02/%E8%82%BA%E7%99%8C%E7%94%9F%E5%AD%98%E6%9C%9F%E9%A2%84%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h1><p>基于18F-氟脱氧葡萄糖正电子发射断层扫描&#x2F;计算机断层扫描和临床病理因素的放射组学列线图的开发与验证，用于预测非小细胞肺癌患者的生存结局</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><strong>患者与数据收集</strong>：<ul><li>研究纳入了315名NSCLC患者（221名用于训练队列，94名用于验证队列）。</li><li>从CT和PET图像中提取了840个放射组学特征。</li></ul></li><li><strong>特征选择与建模</strong>：<ul><li>使用LASSO Cox回归分析计算基于CT、PET和PET&#x2F;CT特征的三个放射组学评分（rad-scores）。</li><li>结合临床病理因素，进行多变量Cox回归分析，以确定独立的风险因素，并基于这些因素构建OS列线图。</li></ul></li><li><strong>模型验证</strong>：<ul><li>使用C指数评估模型在训练和验证队列中的预测性能。</li><li>校准曲线验证预测的生存时间与实际观察到的生存时间之间的差异。</li></ul></li></ul><h1 id="2、题目"><a href="#2、题目" class="headerlink" title="2、题目"></a>2、题目</h1><p>放射组学结合临床特征预测EGFR突变的晚期非小细胞肺癌患者一线靶向治疗的无进展生存时间</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者招募</strong>：<ul><li>纳入了100名在广州医科大学附属肿瘤医院接受EGFR-TKIs一线治疗的IIIB-IV期EGFR阳性NSCLC患者。</li></ul></li><li><strong>影像获取和特征提取</strong>：<ul><li>在治疗前进行CT扫描，并使用3D-slicer软件进行体积兴趣区（VOI）的分割。</li><li>使用开源Python包PyRadiomics从CT图像中提取107个放射组学特征和7个临床特征（包括性别、年龄、分期、吸烟状况、突变类型、TKI治疗和治疗结果）。</li></ul></li><li><strong>特征选择与预测建模</strong>：<ul><li>为了提高分类模型的准确性，在建模之前进行特征选择。</li><li>结合22种特征选择方法和8种分类器，共构建了176个预测模型。</li><li>使用重复的五折交叉验证（5x5-fold CV）评估模型的性能，使用SMOTE技术处理训练集中的数据不平衡问题。</li><li>通过AUC（受试者工作特征曲线下面积）、ACC（准确率）、SEN（敏感性）和SPE（特异性）来量化预测模型的性能。</li></ul></li><li><strong>统计分析</strong>：<ul><li>使用SPSS进行统计分析，包括卡方检验、Kaplan-Meier算法、Kolmogorov-Smirnov检验、学生t检验和Mann-Whitney U检验。</li><li>P值小于0.05被认为具有统计学意义。</li></ul></li></ol><h1 id="3、题目"><a href="#3、题目" class="headerlink" title="3、题目"></a>3、题目</h1><p><strong>Combined radiomics of primary tumour and bone metastasis improve the prediction of EGFR mutation status and response to EGFR-TKI therapy for NSCLC</strong></p><p><strong>原发肿瘤和骨转移的联合放射组学改善了EGFR突变状态和EGFR-TKI治疗反应预测在非小细胞肺癌中的应用</strong></p><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者招募</strong>：<ul><li>研究纳入了203名在2017年12月至2021年9月期间确诊为脊柱转移的非小细胞肺癌（NSCLC）患者。</li><li>通过病理学评估使用苏木精-伊红（H&amp;E）染色确定EGFR突变状态。</li><li>根据RECIST 1.1标准评估EGFR-TKI治疗的反应。</li></ul></li><li><strong>影像获取与肿瘤分割</strong>：<ul><li>所有患者在治疗前接受胸部CT和脊柱MRI扫描。</li><li>使用ITK-SNAP软件手动分割原发肿瘤和脊柱转移的感兴趣区域（ROI）。</li></ul></li><li><strong>放射组学特征提取</strong>：<ul><li>使用PyRadiomics从CT和MRI图像中提取特征。</li><li>提取的特征包括一阶统计、形状特征、灰度共生矩阵（GLCM）、灰度级别运行长度矩阵（GLRLM）等。</li></ul></li><li><strong>特征选择与预测模型构建</strong>：<ul><li>使用最小绝对收缩和选择算子（LASSO）回归进行特征选择。</li><li>构建基于原发肿瘤（RS-Pri）和转移（RS-Met）的放射组学签名，以及结合原发肿瘤和转移的综合放射组学签名（RS-Com）。</li><li>使用10折交叉验证评估模型性能，并通过受试者工作特征（ROC）曲线分析量化模型性能。</li></ul></li><li><strong>统计分析</strong>：<ul><li>使用R语言进行统计分析，评估特征的重现性和区分EGFR突变状态和治疗反应的能力。</li><li>通过ROC曲线和AUC值量化模型性能，使用Delong检验比较不同模型的性能差异。</li></ul></li></ol><h1 id="4、题目"><a href="#4、题目" class="headerlink" title="4、题目"></a>4、题目</h1><p><strong>Evaluating the Potential of Delta Radiomics for Assessing Tyrosine Kinase Inhibitor Treatment Response in Non-Small Cell Lung Cancer Patients</strong></p><p><strong>评估Delta放射组学在评估非小细胞肺癌患者酪氨酸激酶抑制剂治疗反应中的潜力</strong></p><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者选择</strong>：<ul><li>研究回顾性纳入了226名在2018至2019年期间在台北荣民总医院接受靶向治疗的NSCLC患者。</li><li>根据AJCC第八版分期系统，所有患者均为IIIB期以上，并且通过病理学确认为NSCLC。</li><li>患者必须接受高质量对比CT扫描，并在治疗前和治疗后6至16周内进行随访CT扫描。</li></ul></li><li><strong>CT数据和图像预处理</strong>：<ul><li>所有CT图像在放射组学分析前进行了多步骤预处理，包括像素大小标准化、强度归一化和小波滤波。</li><li>使用小波滤波器对图像进行处理，生成八组图像集（如LLL, LLH, LHL, LHH, HHL, HLH, HLL, HHH）。</li></ul></li><li><strong>放射组学特征提取</strong>：<ul><li>有经验的放射科医生和肺科医生评估CT图像质量，并识别感兴趣区域（ROI）。</li><li>从所有图像集中提取放射组学特征，包括直方图、几何特征和纹理特征（如GLCM、GLRLM、LBP）。</li><li>共提取了593个放射组学特征。</li></ul></li><li><strong>特征选择与预测建模</strong>：<ul><li>采用两阶段特征选择策略：<ol><li>单变量Cox比例风险回归筛选显著特征。</li><li>多变量Cox比例风险回归保留具有显著性的变量。</li></ol></li><li>对于放射组学变量，使用三阶段特征选择策略：<ol><li>初步统计测试，采用Cox比例风险回归模型筛选显著特征。</li><li>排除方差膨胀因子大于5的特征。</li><li>多变量Cox比例风险回归模型选择前五个特征。</li></ol></li><li>评估模型性能，使用5折交叉验证，重复10次，计算AUC值。</li></ul></li><li><strong>统计分析</strong>：<ul><li>使用卡方检验和log-rank检验评估分类变量和生存分析的统计差异。</li><li>计算ROC曲线下面积（AUC）和一致性指数（C-index），评估模型在不同时间点的预测性能（如6, 9, 12和15个月）。</li><li>采用Bootstrap重采样技术和配对t检验进行统计比较。</li></ul></li></ol><h1 id="5、题目"><a href="#5、题目" class="headerlink" title="5、题目"></a>5、题目</h1><p><strong>CT-based radiomics signatures can predict the tumor response of non-small cell lung cancer patients treated with first-line chemotherapy and targeted therapy</strong></p><p><strong>基于CT的放射组学特征可以预测接受一线化疗和靶向治疗的非小细胞肺癌患者的肿瘤反应</strong></p><h2 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者招募</strong>：<ul><li>研究回顾性纳入了322名在2014年6月至2019年5月期间在山东大学附属肿瘤医院接受一线化疗、靶向治疗或两者结合治疗的NSCLC患者。</li></ul></li><li><strong>CT数据获取与图像分割</strong>：<ul><li>所有患者在治疗前接受对比增强CT扫描。</li><li>使用Medical Imaging Interaction Toolkit (MITK)软件手动分割肿瘤体积感兴趣区（VOI），由具有8年和15年经验的两位放射科医生分别进行分割，并通过讨论达成最终一致。</li></ul></li><li><strong>放射组学特征提取</strong>：<ul><li>使用PyRadiomics从CT图像中提取1967个放射组学特征，包括14个形状特征、18个统计特征和75个纹理特征。</li><li>纹理特征包括灰度共生矩阵（GLCM）、灰度大小区矩阵（GLSZM）、灰度运行长度矩阵（GLRLM）、灰度依赖矩阵（GLDM）和邻域灰度调子差异矩阵（NGTDM）的特征。</li></ul></li><li><strong>特征选择与分类器建模</strong>：<ul><li>通过计算特征的类间和类内相关系数（ICC），筛选出ICC低于0.75的低重复性特征。</li><li>使用Pearson相关性分析排除均值绝对相关性高于0.9的特征。</li><li>使用最小冗余最大相关（MRMR）特征排序方法选择重要特征，并应用随机森林（RF）分类器构建放射组学签名。</li><li>将前15个特征和140棵决策树结合，构建轻量级放射组学签名。</li><li>再次使用随机森林分类器和独立预测特征（AUC &gt; 0.6，p &lt; 0.05）构建精炼放射组学签名。</li></ul></li><li><strong>统计分析</strong>：<ul><li>使用R软件进行特征选择、分类器建模和统计分析。</li><li>通过ROC曲线分析评估放射组学签名的预测性能，使用AUC量化其性能，并报告敏感性、特异性和准确性。</li><li>使用Mann-Whitney U检验和卡方检验评估连续变量和分类变量之间的差异。</li></ul></li></ol><h1 id="6、题目"><a href="#6、题目" class="headerlink" title="6、题目"></a>6、题目</h1><p><strong>EfficientNet-Based System for Detecting EGFR-Mutant Status and Predicting Prognosis of Tyrosine Kinase Inhibitors in Patients with NSCLC</strong></p><p><strong>基于EfficientNet系统检测NSCLC患者EGFR突变状态并预测酪氨酸激酶抑制剂预后的系统</strong></p><h2 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>研究设计和参与者</strong>：<ul><li>这是一项回顾性、多中心研究，纳入了来自四家医院的485名NSCLC患者。</li><li>将339名患者的数据用于训练数据集，以开发基于EfficientNetV2-L的模型（EME），剩余的患者分配到独立的测试数据集中。</li><li>为了研究EME评分与EGFR相关生物过程之间的生物学关联，纳入了来自癌症基因组图谱（TCGA）肺腺癌数据集的患者。</li></ul></li><li><strong>CT数据和图像分割</strong>：<ul><li>所有患者在治疗前进行CT扫描，并使用ITK-SNAP软件分割肿瘤区域。</li><li>采用有经验的放射科医生和NSCLC专家进行图像质量评估和分割。</li></ul></li><li><strong>模型构建</strong>：<ul><li>EME模型基于EfficientNetV2-L，输入为256x256像素的三通道图像块，包括肿瘤及其周围区域。</li><li>使用LASSO Cox回归构建基本EME预后模型，并采用Akaike信息准则（AIC）构建最终模型。</li><li>采用X-tile软件选择最佳分界值，将患者分为高风险和低风险亚组。</li></ul></li><li><strong>模型性能评估与比较</strong>：<ul><li>提取每位患者的放射组学特征，构建放射组学模型以预测EGFR突变状态和预后。</li><li>构建融合模型，整合EME和放射组学模型，评估其性能改进。</li><li>采用ROC曲线下面积（AUC）、准确性、精确性、召回率和F1分数评估模型性能，并使用Delong检验比较不同模型的AUC。</li></ul></li><li><strong>特征可视化和生物学相关分析</strong>：<ul><li>使用Grad-CAM生成激活图，突出显示EME模型激活的相关区域。</li><li>采用t-SNE进行特征降维和可视化，展示EME特征与EGFR突变状态之间的关系。</li><li>使用热图描述EME预后特征与EGFR突变NSCLC患者预后之间的关系。</li></ul></li><li><strong>统计分析</strong>：<ul><li>采用R软件进行所有统计分析，使用卡方检验和Mann-Whitney U检验比较基线特征。</li><li>采用Bootstrap方法计算95%置信区间（CI），使用多变量逻辑回归分析构建放射组学模型。</li><li>采用Kaplan-Meier分析和log-rank检验可视化生存曲线，并使用Harrell的一致性指数（C-index）评估预后模型性能。</li></ul></li></ol><h1 id="7、题目"><a href="#7、题目" class="headerlink" title="7、题目"></a>7、题目</h1><p><strong>Identification of Stage IIIC&#x2F;IV EGFR-Mutated Non-Small Cell Lung Cancer Populations Sensitive to Targeted Therapy Based on a PET&#x2F;CT Radiomics Risk Model</strong></p><p><strong>基于PET&#x2F;CT放射组学风险模型识别对靶向治疗敏感的IIIC&#x2F;IV期EGFR突变非小细胞肺癌患者</strong></p><h2 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者选择</strong>：<ul><li>研究回顾性纳入了250名IIIC-IV期EGFR突变NSCLC患者，这些患者接受了第一代和第二代EGFR-TKI药物治疗。</li><li>患者来自两个机构，其中训练队列包括140名患者，内部验证队列包括60名患者，外部验证队列包括50名患者。</li></ul></li><li><strong>PET&#x2F;CT数据获取与图像分割</strong>：<ul><li>所有患者在治疗前进行PET&#x2F;CT扫描。</li><li>使用ITK-SNAP软件手动分割肿瘤区域（ROI）。</li></ul></li><li><strong>放射组学特征提取</strong>：<ul><li>从PET和CT图像中提取1037个三维放射组学特征，量化肿瘤区域的表型特征。</li><li>使用PyRadiomics软件包进行特征提取，包括14个体积形状特征、18个一阶统计特征和75个纹理特征。</li></ul></li><li><strong>特征选择与放射组学模型构建</strong>：<ul><li>采用四步特征选择方法，以避免因特征过多而导致的过拟合。</li><li>第一步：计算每个特征的组内相关系数（ICC），保留ICC大于0.8的特征。</li><li>第二步：使用Pearson相关性分析评估特征之间的相关性，对于每对相关性绝对值大于0.8的特征，保留信息冗余较少的特征。</li><li>第三步：在训练队列中进行单变量Cox回归分析，根据Harrell一致性指数（C-index）排序，选择前10个特征。</li><li>第四步：进行多变量Cox回归分析，结合所有可能的特征组合，通过10折交叉验证选择最优组合，最终构建预后模型（Rad-score）。</li></ul></li><li><strong>统计分析与模型验证</strong>：<ul><li>使用Kaplan-Meier生存分析比较不同风险组患者的无进展生存期（PFS）。</li><li>采用时间依赖的受试者工作特征（ROC）曲线分析评估模型在10个月、一年和14个月PFS预测中的表现。</li><li>通过C-index和AUC评估模型在训练队列、内部验证队列和外部验证队列中的预后准确性。</li></ul></li></ol><h1 id="8、题目"><a href="#8、题目" class="headerlink" title="8、题目"></a>8、题目</h1><p><strong>Association between Contrast-Enhanced Computed Tomography Radiomic Features, Genomic Alterations and Prognosis in Advanced Lung Adenocarcinoma Patients</strong></p><p><strong>增强型CT放射组学特征、基因组改变与晚期肺腺癌患者预后之间的关系</strong></p><h2 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者招募</strong>：<ul><li>研究纳入了261名回顾性患者（数据集1）和48名前瞻性患者（数据集2）。</li><li>患者均为确诊的晚期肺腺癌患者，并在研究期间进行了分子检测。</li></ul></li><li><strong>CT数据获取与图像分割</strong>：<ul><li>从增强型CT图像中提取放射组学特征。</li><li>使用三名放射科医生手动分割肺部原发肿瘤的兴趣区域（VOI），并通过共识确定分割标准。</li></ul></li><li><strong>放射组学特征提取</strong>：<ul><li>使用PyRadiomics软件包从每个VOI中提取1413个放射组学特征。</li><li>提取特征包括一阶统计特征、形状特征和纹理特征。</li></ul></li><li><strong>特征选择与模型构建</strong>：<ul><li>为了去除受CT采集和重建参数显著影响的特征，进行方差分析（ANOVA），并去除了155个特征。</li><li>采用LASSO-Logistic回归模型识别与可操作基因状态（EGFR突变、KRAS突变和ALK重排）最相关的放射组学特征。</li><li>使用这些特征构建放射组学评分（RS），并测试其预测基因状态的能力。</li><li>开发临床模型和临床-放射组学模型，通过多变量Logistic回归结合放射组学评分和临床变量。</li></ul></li><li><strong>模型验证与统计分析</strong>：<ul><li>使用数据集2进行模型验证，通过受试者工作特征曲线下面积（AUC）评估模型的准确性。</li><li>进行探索性分析，评估每个放射组学评分与相关临床变量之间的关联。</li><li>针对总生存期（OS）预测，使用数据集1进行内部交叉验证，并计算Harrel一致性指数（C-index）评估模型的准确性。</li><li>采用Kaplan-Meier生存分析比较高风险和低风险患者的OS，并使用log-rank检验评估组间差异。</li></ul></li></ol><h1 id="9、题目"><a href="#9、题目" class="headerlink" title="9、题目"></a>9、题目</h1><p><strong>omputed tomography-based radiomics quantification predicts epidermal growth factor receptor mutation status and efficacy of first-line targeted therapy in lung adenocarcinoma</strong></p><p><strong>基于CT的放射组学量化方法预测肺腺癌中表皮生长因子受体突变状态和一线靶向治疗的疗效</strong></p><h2 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>患者选择</strong>：<ul><li>研究回顾性分析了来自湖南省肿瘤医院的肺腺癌患者的治疗前CT图像和临床信息。</li><li>最终纳入了692名患者用于建立放射组学签名，其中514名用于训练队列，178名用于验证队列。</li></ul></li><li><strong>CT数据获取与图像分割</strong>：<ul><li>使用IBEX软件手动分割肿瘤区域（ROI）。</li><li>图像由经验丰富的放射科医生分割，并通过PyRadiomics工具箱从CT图像中提取2153个放射组学特征。</li></ul></li><li><strong>特征选择与模型构建</strong>：<ul><li>使用Mann-Whitney统计检验剔除冗余特征。</li><li>使用最小冗余最大相关（mRMR）方法确定最显著的放射组学特征。</li><li>将前13个特征输入支持向量机（SVM）分类器，建立放射组学签名预测EGFR突变状态。</li><li>通过10折交叉验证优化分类器参数，并结合四个临床特征（年龄、性别、吸烟史和家族病史）。</li></ul></li><li><strong>模型验证与统计分析</strong>：<ul><li>采用ROC曲线下面积（AUC）、准确性、敏感性、特异性和F1评分评估放射组学签名的预测性能。</li><li>使用训练队列和验证队列评估模型的无进展生存期（PFS）预测能力。</li><li>通过Cox回归分析探索与最佳反应相关的放射组学特征。</li></ul></li></ol><h1 id="10、题目"><a href="#10、题目" class="headerlink" title="10、题目"></a>10、题目</h1><p><strong>Non-invasive decision support for NSCLC treatment using PET&#x2F;CT radiomics</strong></p><p><strong>使用PET&#x2F;CT放射组学进行非小细胞肺癌治疗的非侵入性决策支持</strong></p><h2 id="方法-9"><a href="#方法-9" class="headerlink" title="方法"></a>方法</h2><ol><li><strong>研究设计与患者选择</strong>：<ul><li>研究回顾性纳入了来自不同机构的NSCLC患者，分为训练集、内部验证集和外部测试集。</li><li>用于训练和验证的患者数据来自上海肺科医院和河北医科大学第四医院，而用于外部测试的数据来自哈尔滨医科大学。</li></ul></li><li><strong>PET&#x2F;CT数据获取与图像处理</strong>：<ul><li>所有患者在治疗前接受了18F-FDG PET&#x2F;CT扫描。</li><li>采用放射科医生手动标记的感兴趣区域（ROI），从图像中提取特征。</li></ul></li><li><strong>深度学习模型构建</strong>：<ul><li>开发基于深度学习的模型，利用PET&#x2F;CT图像的深度学习特征（例如，最后的全局平均池化层的输出）。</li><li>使用无监督层次聚类方法对深度学习特征进行聚类分析，生成深度学习评分（EGFR-DLS）。</li><li>模型用于预测EGFR突变状态以及评估EGFR-TKI和ICI治疗的预后。</li></ul></li><li><strong>模型性能评估</strong>：<ul><li>通过受试者工作特征曲线（ROC曲线）和AUC评估模型在训练集、内部验证集和外部测试集中的表现。</li><li>使用多变量Logistic回归分析评估EGFR-DLS与其他临床变量（例如年龄、性别、分期、吸烟状态、SUVmax）的关系。</li><li>通过Kaplan-Meier生存分析评估EGFR-DLS在EGFR-TKI和ICI治疗中的预后价值。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Agile Multi-Source-Free Domain Adaptation</title>
    <link href="/cblog/2024/06/15/Agile-Multi-Source-Free-Domain-Adaptation/"/>
    <url>/cblog/2024/06/15/Agile-Multi-Source-Free-Domain-Adaptation/</url>
    
    <content type="html"><![CDATA[<h1 id="Agile-Multi-Source-Free-Domain-Adaptation"><a href="#Agile-Multi-Source-Free-Domain-Adaptation" class="headerlink" title="Agile Multi-Source-Free Domain Adaptation"></a>Agile Multi-Source-Free Domain Adaptation</h1><p><strong>作者:</strong> Xinyao Li, Jingjing Li, Fengling Li, Lei Zhu, Ke Lu</p><h1 id="所属机构"><a href="#所属机构" class="headerlink" title="所属机构:"></a>所属机构:</h1><ol><li>中国电子科技大学（UESTC）</li><li>深圳研究院，UESTC</li><li>悉尼科技大学</li><li>同济大学电子与信息工程学院</li></ol><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/TL-UESTC/Bi-ATEN">https://github.com/TL-UESTC/Bi-ATEN</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><h2 id="工作重点"><a href="#工作重点" class="headerlink" title="工作重点"></a>工作重点</h2><p>不访问源数据，自适应的利用来自多个源于训练模型的source知识到target</p><p>提出无需对源主干进行调参的网络</p><p><strong>工作贡献：</strong>Bi-level ATtention ENsemble (Bi-ATEN) module；它学习域内权重和域间集成权重，以在实例特异性和域一致性之间实现良好的平衡。</p><p>研究团队通过对预训练模型中的瓶颈层进行小幅度调整，在DomainNet数据集上的表现达到了或超过了目前最先进的方法。这种调整不仅使模型的性能提升，同时<strong>显著减少了所需训练参数的数量（少于3%），并且大幅度提高了模型的处理速度</strong>（吞吐量增加了8倍）。</p><p>此外，通过较小的修改，所提出的模块可以轻松地配备到现有方法中，并获得超过 4% 的性能提升。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>计算量太大，微调大模型参数是把预训练模型转移到下游任务的主要方法</p><p>但是这种方法严重依赖标记的训练数据，并且域不同会严重影响网络性能</p><p>此外，经常拥有不同来源或架构上训练的多个预训练模型</p><p>在现实世界的应用中，最大限度地利用多个预训练模型的知识的需求是很常见的</p><p><strong>无源域适应（Source-Free Domain Adaption, SFDA）指在数据不共享的场合，可以通过源域的预训练模型和目标域的数据进行跨域知识迁移。</strong></p><p>多个无源域自适应（MSFDA）可以通过使多个预训练源模型整体适应未标记的目标域，同时不访问源训练数据来应对这些挑战。</p><p><strong>现有的 MSFDA 方法通常通过两步框架解决该问题：</strong></p><ol><li>针对目标领域彻底调整每个源模型</li><li>了解源重要性权重以组装源模型</li></ol><p>然而，它们在计算效率和可扩展性方面的巨大限制阻碍了它们在大规模问题上的应用。</p><p><strong>第一步：</strong></p><p>要调整的模型数量随着源域的数量线性增加，这对于具有丰富源域的大规模问题来说可能变得不可接受。 调整每个模型的所有参数的必要性也使得将这些方法扩展到更大的模型是不可行的。</p><p>在表 5 中，我们比较了 CAiDA 的性能和可训练参数</p><p>作为典型的 MSFDA 框架，CAiDA 由于 ResNet-50 主干的性能有限而表现不佳。</p><p>通过配备更强大的主干 SwinTransformer，可实现 +12.3% 的潜在性能提升，但需要调整四倍的参数。</p><p>另一方面，我们的目标是通过配备 SwinTransformer 来实现卓越的性能，同时要求显着降低训练成本，为 MSFDA 在大型模型上提供更可行、更敏捷的解决方案。</p><p><strong>第二步：</strong></p><p>对于步骤 (2)，当前的 MSFDA 方法学习域级集成权重，在所有目标实例上应用相同的集成策略。 尽管学习到的权重可以在域可转移性方面直观地解释，但它们不可避免地会在实例级别引入错位和偏差。 这一争议本质上引入了实例特异性和集合权重的域一致性之间的权衡，而现有方法尚未充分利用这一点。</p><ol><li><strong>域级别的集成权重</strong>：当前的方法在所有目标实例上使用相同的集成权重，这意味着它们不会根据每个实例的具体情况调整权重。</li><li><strong>可转移性解释</strong>：这些权重在域之间的转移能力上是有意义的，可以直观地解释为某个域的重要性。</li><li><strong>错位和偏差</strong>：然而，在实例级别，这种统一的策略可能会导致错位（即，某些实例得到不合适的权重分配）和偏差（即，某些实例的特性没有被充分考虑）。</li><li><strong>实例特异性 vs 域一致性</strong>：这种方法没有平衡好实例的特异性（每个实例的独特需求）和域的一致性（在所有实例上应用相同策略）的关系。</li></ol><p>最近模型集成方法的成功表明，通过设计自适应集成权重来传递知识是有效的。虽然最优策略很难学习，但我们求助于对几个特定于领域的瓶颈层进行轻微调整，其成本不到整个模型调整的0.1%。</p><p>如上所述，设计有效权重的关键是利用域级别的可转移性和实例级别的个体特征，如图8所示。</p><p>现有的多源无数据域适应（MSFDA）方法仅仅从特征表示中学习权重，而忽略了特征和输出之间的潜在可转移性不匹配问题。这意味着即使目标域的特征在源域和目标域之间是可转移的，它们也不一定能产生准确的预测。</p><p>解释：</p><ol><li><strong>特征和输出之间的可转移性不匹配</strong>：<ul><li><strong>特征可转移性</strong>：特征在源域和目标域之间的可转移性是指这些特征在两个域之间的相似性或兼容性。高可转移性特征意味着这些特征在源域和目标域都表现良好。</li><li><strong>输出准确性</strong>：尽管特征在两个域之间可以转移，但它们并不总是能保证在目标域中的输出是准确的。这是因为特征和最终预测之间可能存在不匹配。</li></ul></li><li><strong>示例：</strong>假设我们有一个在猫和狗的图像分类任务上训练的模型。该模型学习了很多关于猫和狗的特征。如果我们将这个模型应用于一个新任务，比如区分狮子和老虎的图像，模型可能会成功地转移一些基本的动物特征（如毛发、四肢的形状等），但这些特征未必足以准确地区分狮子和老虎。因此，尽管特征在源任务和目标任务之间是可转移的，但由于这些特征在新任务中的适用性不足，预测结果可能并不准确。</li></ol><p><strong>对于特征表示，首先学习域内权重，找到产生无偏输出的最兼容的分类器来减少可转移性失配。</strong></p><p><strong>利用所选源分类器的无偏输出，我们进一步学习将源输出组合到最终结果中的域间集成权重。我们提出了一种新的双层注意集成(BiAten)，通过注意机制来有效地学习这两个权重。</strong></p><p>BiAten能够根据每个实例的特殊性定制其整体决策，同时保持跨域一致的更广泛的可转移性趋势。这种平衡对于准确的领域适应是至关重要的，在这种情况下，模型需要利用特定于领域的知识，而不会丢失驱动适应的总体模式。</p><p>该方法可以简化为域间注意集成(ATEN)，并通过替换它们的权重学习模块嵌入到现有的MSFDA方法中。</p><p>策略：</p><ol><li><strong>实例特异性</strong>：确保模型能够根据每个具体实例的特性进行调整，以提供最合适的处理结果。</li><li><strong>域一致性</strong>：在不同域之间保持处理策略的一致性，确保结果的可靠性。</li><li><strong>轻微调整瓶颈层</strong>：通过对模型的瓶颈层进行小幅度调整，提高模型的适应性和性能。</li></ol><h2 id="贡献总结"><a href="#贡献总结" class="headerlink" title="贡献总结"></a>贡献总结</h2><ol><li><p>We propose a novel framework to agilely handle<br>MSFDA by learning fine-grained domain adaptive ensemble<br>strategies.</p><p>我们提出了一种新的框架，通过学习细粒度域自适应集成策略来灵活地处理MSFDA。</p></li><li><p>We design an effective module Bi-ATEN that<br>learns both intra-domain weights and inter-domain ensem-<br>ble weights. Its light version ATEN can be equipped to exist-<br>ing MSFDA methods to boost performance.</p><p>我们设计了一个同时学习域内权值和域间集成权值的有效模块BiAten。它的轻型版本ATEN可以配备到现有的MSFDA方法，以提高性能。</p></li><li><p>Our method<br>significantly reduces computational costs while achieving<br>state-of-the-art performance, making it feasible for real-life<br>transfer applications with large source-trained models.</p><p>我们的方法显著降低了计算成本，同时获得了最先进的性能，使其适用于具有大型源训练模型的真实传输应用程序。</p></li><li><p>Extensive experiments on three challenging benchmarks and<br>detailed analysis demonstrates the success of our design.</p><p>在三个具有挑战性的基准上进行的大量实验和详细的分析证明了我们的设计是成功的。</p></li></ol><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>**Source-free domain adaptation (SFDA)**：不可访问源数据，只能访问源预训练模型</p><p>**Multi-source domain adaptation (MSDA)**：MSDA的目标是利用多个源域的数据来训练模型，使其能够更好地适应和预测目标域的数据。这种方法假设多个源域提供了更丰富的特征和信息，有助于模型更准确地理解和适应目标域的分布。</p><p><strong>Multi-source-free domain adaptation (MSFDA)：</strong>MSFDA的目标是使用多个预训练的源模型，而不是源数据，来帮助模型适应目标域。这需要设计新的算法和方法来有效地利用源模型的知识。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="问题定义（gpt）"><a href="#问题定义（gpt）" class="headerlink" title="问题定义（gpt）"></a>问题定义（gpt）</h2><p>目标是优化所有 𝑛个源模型以在目标域上达到满意的性能。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616110139495.png" alt="image-20240616110139495"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616110207993.png" alt="image-20240616110207993"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们不是通过特定的源分类器直接生成输出，而是通过将当前特征通过所有源分类器转发来计算所有可能的跨域输出。在特征表示和所有输出向量之间计算域内权重{αi}n i&#x3D;1，以获得无偏输出。</p><p>随后，学习域间权重β以将无偏的域输出组装成最终的分类结果。请注意，源主干和源分类器在整个训练过程中都保持冻结。</p><p>该框架的核心是BiAten模块，如图9右侧所示。它同时从特征输出相似性中学习{αi}n i&#x3D;1，从特征-特征相似性中学习β。接下来，我们详细阐述了各个模块的详细设计。</p><h2 id="两级注意力集成"><a href="#两级注意力集成" class="headerlink" title="两级注意力集成"></a>两级注意力集成</h2><p><strong>Intra-domain weights.<strong>：目前所有的MSFDA方法都采用端到端的训练范式，将每个源模型作为一个整体来对待，然而，目标和源数据之间的分布变化可能会导致源模型组件内部的不匹配，如瓶颈和分类器。受深度模型重组方法的启发，我们提出</strong>通过执行部分模型重组来改进现有的MSFDA范例</strong>。我们探索适合目标数据特征的兼容瓶颈-分类器对，并通过对瓶颈-分类器对的跨域加权输出求和得到重组结果。我们首先通过以下方式获得其跨域输出：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616110419859.png" alt="image-20240616110419859"></p><h2 id="域内权重"><a href="#域内权重" class="headerlink" title="域内权重"></a>域内权重</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616112600736.png" alt="image-20240616112600736"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616112615506.png" alt="image-20240616112615506"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616112624959.png" alt="image-20240616112624959"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616125740033.png" alt="image-20240616125740033"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616125841028.png" alt="image-20240616125841028"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616125853555.png" alt="image-20240616125853555"></p><h2 id="域间权重"><a href="#域间权重" class="headerlink" title="域间权重"></a>域间权重</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616141726994.png" alt="image-20240616141726994"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616141742757.png" alt="image-20240616141742757"></p><h2 id="动态聚类保证结果正确"><a href="#动态聚类保证结果正确" class="headerlink" title="动态聚类保证结果正确"></a>动态聚类保证结果正确</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616215129288.png" alt="image-20240616215129288"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616215228532.png" alt="image-20240616215228532"></p><h2 id="Attention-Ensemble-作为可插入模块"><a href="#Attention-Ensemble-作为可插入模块" class="headerlink" title="Attention Ensemble 作为可插入模块"></a>Attention Ensemble 作为可插入模块</h2><p>当域内权重（αi）仅在第 𝑖 个位置为1，其余位置为0时，Bi-ATEN将简化为仅使用域间权重（<em>β</em>）的注意力集成模块（ATEN）。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/image-20240616221948708.png" alt="image-20240616221948708"></p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/cblog/2024/05/19/hello-world/"/>
    <url>/cblog/2024/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SDC-UDA</title>
    <link href="/cblog/2024/05/11/SDC-UDA/"/>
    <url>/cblog/2024/05/11/SDC-UDA/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>SDC-UDA: Volumetric Unsupervised Domain Adaptation Framework for Slice-Direction Continuous Cross-Modality Medical Image Segmentation</p><p>SDC-UDA：用于切片方向连续跨模态医学图像分割的体积无监督域自适应框架</p><p> 会议：2023 IEEE&#x2F;CVF 计算机视觉与模式识别会议 （CVPR）</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>医学影像领域，获取像素级专家注释是极其昂贵和费力的。</li><li>与以往的医学图像分割方法不同，它可以在切片方向上获得连续分割，从而保证了临床实践中更高的准确性和潜力</li><li>当深度学习模型面对来自看不见的领域的数据时，性能会下降。无监督域适应 （UDA） 旨在通过将源域数据训练的模型调整到目标域来缓解此问题，而无需在目标域中进行监督。</li><li>以往在跨模态医学图像分割领域对UDA的研究通常是通过同时学习二维图像平移和靶域分割来进行的，在每个目标数据切片上推断训练好的模型，然后在切片方向上堆叠预测。可能导致切片方向上的预测不一致或波动，而这些预测在定量指标中未显示，并可能中断对靶标结构的准确分析，使其难以在现实世界的临床实践中使用。</li></ol><h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><ol><li>我们提出了<strong>SDC-UDA</strong>，一个<strong>用于跨模态医学图像分割的统一体积UDA框架</strong>。</li><li>用于高效医学图像翻译的切片内和切片间自注意力：提出的 2.5D 平移框架与切片内和切片间自注意力模块可提高合成体积中的<strong>解剖结构保留和</strong>切片<strong>方向平滑度</strong>，从而使合成体积能够在以下自训练步骤中有效使用。</li><li>具有不确定性约束的伪标签细化的体积自训练：我们提出了一种新型的不确定性约束伪标签细化模块，<strong>该模块可以自适应地提高伪标签的准确性（即灵敏度或特异性），</strong>从而最大限度地提高医学图像分割的自训练性能。</li><li>SDC-UDA<strong>在多个具有不同数据特征的公共数据集上进行了验证</strong>，用于跨模态医学图像分割。它不仅超越了以往方法的性能，而且表现出<strong>优异的切片方向分割连续性</strong>，可在临床实践中提供精确的分析。</li></ol><h1 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h1><h2 id="用于医学图像分割的UDA"><a href="#用于医学图像分割的UDA" class="headerlink" title="用于医学图像分割的UDA"></a>用于医学图像分割的UDA</h2><p>以前的工作大多是用目标域分割来训练二维级图像翻译，并将每个目标切片的分割堆叠在切片方向上。由于分割网络不考虑切片方向的解剖结构，这可能导致分割结果的高度可变性，即使在相邻的切片中也是如此。</p><h2 id="医学图像分割的-UDA-自训"><a href="#医学图像分割的-UDA-自训" class="headerlink" title="医学图像分割的 UDA 自训"></a>医学图像分割的 UDA 自训</h2><p>在自我训练中，首先仅使用标记的数据训练教师模型。接下来，通过在训练模型上传递未标记的数据来推断具有高置信度的伪标签。使用标记数据和伪标记数据，可以使用更大的数据集来训练学生模型，该模型的性能优于仅在标记数据上训练的教师模型。</p><p>所提出的伪标签细化策略在两个方面是有效的：1）灵敏度和特异性增强细化可以根据目标数据的特征自适应使用，2）它是一种更安全的不确定性处理方法，因为即使是正确分割的区域也可能具有很高的不确定性，因此在以下训练中使用不确定性图对损失函数进行加权可能会将模型引导到错误的方向。</p><h1 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h1><h2 id="3-1-使用切片内和切片间自注意力模块的不配对图像翻译"><a href="#3-1-使用切片内和切片间自注意力模块的不配对图像翻译" class="headerlink" title="3.1. 使用切片内和切片间自注意力模块的不配对图像翻译"></a>3.1. 使用切片内和切片间自注意力模块的不配对图像翻译</h2><p>以前的 2D UDA 方法将 3D 体积拆分为 2D 切片，然后将它们的平移重新堆叠为 3D 体积。由于切片是单独处理的，因此重新构建翻译体积通常需要额外的后处理，例如切片方向插值，这仍然不能完美地解决切片方向不连续等问题。</p><p>3D-CycleGAN：优化复杂性，计算负担或翻译质量下降等典型缺点，它们很少使用</p><p><strong>方法是将一堆源域图像转换为目标域，同时使用切片内和切片间自注意力模块。</strong>利用了切片方向上相邻切片的信息。</p><h2 id="3-2-基于不确定性约束的伪标签细化的体积自训练"><a href="#3-2-基于不确定性约束的伪标签细化的体积自训练" class="headerlink" title="3.2. 基于不确定性约束的伪标签细化的体积自训练"></a>3.2. 基于不确定性约束的伪标签细化的体积自训练</h2><p>即使源到目标转换的图像生成良好，与真实目标域数据仍可能存在一定的分布差距，难以完全替代。通过自训练，可以获取未标记目标域数据的伪标签，并用于对目标域数据进行监督，从而从模型的角度缩小域差距。我们建议利用体积自训练来缩小领域差距，采用简单新颖的伪标签细化策略，以最大限度地发挥自我训练的效果。</p><h3 id="3-2-1使用标记合成扫描进行训练分割"><a href="#3-2-1使用标记合成扫描进行训练分割" class="headerlink" title="3.2.1使用标记合成扫描进行训练分割"></a>3.2.1使用标记合成扫描进行训练分割</h3><p>利用从源域转换的合成数据Xxt和源扫描上的注释ys（即，标记的合成数据集），我们首先训练一个教师分割网络fteacher，使分割损失最小化：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122138093.png" alt="image-20240512213836909"></p><h3 id="3-2-2在未标记的目标域数据上推断伪标记"><a href="#3-2-2在未标记的目标域数据上推断伪标记" class="headerlink" title="3.2.2在未标记的目标域数据上推断伪标记"></a>3.2.2在未标记的目标域数据上推断伪标记</h3><p>一旦训练了教师模型，就可以通过将真实的目标扫描传递给训练的分割模型fteacher来获得未注释的真实的数据xt的伪标记fteacher。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122141222.png" alt="image-20240512214146196"></p><h3 id="3-2-3用于灵敏度-特异性增强的不确定性约束伪标记细化"><a href="#3-2-3用于灵敏度-特异性增强的不确定性约束伪标记细化" class="headerlink" title="3.2.3用于灵敏度&#x2F;特异性增强的不确定性约束伪标记细化"></a>3.2.3用于灵敏度&#x2F;特异性增强的不确定性约束伪标记细化</h3><p><strong>灵敏度增强伪标签细化。</strong>利用伪标签的推断，不确定性（即，根据以下等式计算对应于每个类别的（熵）图：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122142106.png" alt="image-20240512214247073"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122143361.png" alt="image-20240512214350323"></p><p><strong>特异性增强伪标签细化。</strong>为了增强伪标记的特异性，检测伪标记范围内的高度不确定区域。然后，如果该区域中的像素强度在包括在当前伪标签中的图像强度的特定范围之外，则将其从当前伪标签中排除。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122144793.png" alt="image-20240512214417747"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122145278.png" alt="image-20240512214516196"></p><h3 id="3-2-4-使用组合数据重新训练分割"><a href="#3-2-4-使用组合数据重新训练分割" class="headerlink" title="3.2.4.使用组合数据重新训练分割"></a>3.2.4.使用组合数据重新训练分割</h3><p>合成目标扫描与真实的目标扫描具有分布间隙，但它们与完美的注释配对。另一方面，真实的靶扫描与伪标记配对，伪标记还不完整。我们将这两个对自我训练，以最大限度地提高泛化能力，并尽量减少由于分布的差异造成的性能下降。利用标记的合成目标扫描（xt，ys）和伪标记的真实的目标扫描（xt，yt r）的组合数据，我们训练学生分割fstudent以最小化</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122147415.png" alt="image-20240512214733378"></p><p>尽管不是地面真值标签，但在先前的文献中已经报道了自训练方案和伪标签通过利用未标记的数据进行训练来提高模型在未知数据上的性能和泛化能力</p><h1 id="四、实验"><a href="#四、实验" class="headerlink" title="四、实验"></a>四、实验</h1><h2 id="4-1-数据集"><a href="#4-1-数据集" class="headerlink" title="4.1.数据集"></a>4.1.数据集</h2><h3 id="CrossMoDA-dataset"><a href="#CrossMoDA-dataset" class="headerlink" title="CrossMoDA dataset."></a>CrossMoDA dataset.</h3><p>前庭神经鞘瘤和耳蜗分割的CrossMoDA数据集[7]由105个标记的对比增强T1（ceT1）MRI扫描和105个未标记的高分辨率T2（hrT2）MRI扫描组成。域适应的方向是从ceT1到hrT2，因为hrT2扫描的注释不公开。</p><h3 id="Cardiac-structure-segmentation-dataset"><a href="#Cardiac-structure-segmentation-dataset" class="headerlink" title="Cardiac structure segmentation dataset."></a>Cardiac structure segmentation dataset.</h3><p>心脏结构分割数据集。</p><p>由20个MRI和20个CT体积组成，用于心脏分割。从MRI到CT进行域适应，每种模态的80%用于训练，20%用于评价的随机选择的CT扫描。用于分割的目标心脏结构是升主动脉（AA）、左心房血腔（LAC）、左心室血腔（LVC）和左心室心肌（MYO）。在256×256的固定冠状面分辨率下，手动裁剪MRI和CT体积以覆盖4个心脏子结构。</p><h2 id="4-2-实验细节"><a href="#4-2-实验细节" class="headerlink" title="4.2.实验细节"></a>4.2.实验细节</h2><p>带层内和层间自关注模块的不成对图像平移。切片内和切片间的专注翻译基于2D框架，其中图像切片作为大小为（B×3，1，H，W）的堆叠批次馈送到2D CNN E，其中H和W各自表示高度和宽度。在GE之后，编码的特征图被重新整形为（B，3，H，W）并被馈送到注意模块以考虑切片方向注意。贴片大小p设定为2。转置卷积用于将嵌入的补丁转换回2D特征图。对于在G处生成的一堆小体积，我们实现了2D WMD来进行域转换的对抗训练。对于D的真实的输入，从目标体积随机提取3个连续切片。</p><p>不确定性约束的伪标签精化。对于每个类别，进行网格搜索，以确定如何设置用于掩蔽高不确定性区域的阈值，以及是否使用灵敏度和特异性增强细化中的一种或两种。对于CrossMoDA数据集，在两个类中组合灵敏度和特异性增强细化（即，VS和CODEa），不确定性阈值为0.3，结果最好。对于心脏数据集，使用相同的阈值，并且对于除一个类别之外的所有类别仅使用特异性增强细化（即，AA）导致了最好的结果。这是由于心脏CT中相邻子结构之间的对比度差异非常弱，这导致使用灵敏度增强模块时伪标记噪声更大。消融结果请参见补充材料中的表格。α和β分别设定为0.6和1.4。</p><p>体积的自我训练。对于体积分割自训练，使用从nnU-Net [14]构建的基于3D U-Net的架构。使用Dice和交叉熵损失与随机梯度下降优化器的组合对分割进行了100个时期的训练。初始学习率和批量大小分别为1 e-2和2。</p><h2 id="4-3结果"><a href="#4-3结果" class="headerlink" title="4.3结果"></a>4.3结果</h2><h3 id="片内和片间自注意力模块在图像翻译中的作用"><a href="#片内和片间自注意力模块在图像翻译中的作用" class="headerlink" title="片内和片间自注意力模块在图像翻译中的作用"></a>片内和片间自注意力模块在图像翻译中的作用</h3><p>由于使用2D网络（蓝色箭头）逐切片预测产生的变化，在翻译图像中观察到像素强度的切片方向不一致。即使使用将两个相邻切片放在网络中的2.5D网络，这也没有完全克服。此外，在2D和2.5D网络中，发现源图像的解剖结构在转换图像中失真（红色和绿色箭头）。另一方面，观察到当利用有效地考虑相邻解剖结构的切片内和切片间自注意模块时，上述问题得到缓解。表1示出了通过在图像平移网络中结合切片内和切片间自注意力，与利用纯未配对图像平移随后是3D分割网络的基线相比，最终分割性能的提高。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122210189.png" alt="image-20240512221012057"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122210864.png" alt="image-20240512221024819"></p><h3 id="不确定性约束伪标签细化和体积自训练的影响"><a href="#不确定性约束伪标签细化和体积自训练的影响" class="headerlink" title="不确定性约束伪标签细化和体积自训练的影响"></a>不确定性约束伪标签细化和体积自训练的影响</h3><p>不确定性约束的伪标签细化和体积自训练的效果。由于CrossMoDA数据集无法获得目标域的真实数据，因此通过比较伪标签细化前后的自训练性能来验证伪标签细化的有效性。对于可获得基础事实的心脏数据集，通过比较伪标签细化前后的骰子系数与标签进行验证（请参阅补充材料）。表1显示了通过在CrossMoDA数据集上应用所提出的不确定性约束伪标签细化来提高目标域分割性能。可以看出，体积自训练与所提出的不确定性约束伪标签细化相结合，大幅提高了VS和C中的定量指标，而纯自训练仅提高了VS中的性能。</p><h3 id="比较研究"><a href="#比较研究" class="headerlink" title="比较研究"></a>比较研究</h3><p>比较研究。该方法与六种流行的UDA方法进行了比较，它们是CycleGAN [38]，CyCADA [12]，ADVENT [34]，FDA [36]，SIFA [4]和PSIGAN [15]。前四种方法是从自然图像领域，而最后两个是UDA的医学图像分割方法。完全监督和无适应的结果分别提供上限和下限。请注意，CrossMoDA数据集的全监督结果（其真实分割掩码不可用）来自数据集所有者的论文[7]。表2和图6显示了所提出的方法与先前方法之间的比较研究的定量和定性结果。SDC-UDA在非医学领域的语义分割研究中远远超过了UDA的结果，并且与最近在医学领域的研究相比，在多个任务中显示出更好的结果。特别是，与心脏数据集相比，在CrossMoDA数据集中提出的方法和比较方法之间存在显著的性能差距。这可能是由于以前的医学UDA研究致力于数据集，其中数据被裁剪在目标器官周围，前景对象占据了大部分数据。相比之下，SDC-UDA显示CrossMoDA数据集中的两个目标结构都以高精度分割。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122214165.png" alt="image-20240512221401093"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122216576.png" alt="image-20240512221656454"></p><h3 id="与先前研究相比，分割的切片方向连续性"><a href="#与先前研究相比，分割的切片方向连续性" class="headerlink" title="与先前研究相比，分割的切片方向连续性"></a>与先前研究相比，分割的切片方向连续性</h3><p>与以前的研究相比，分割的切片方向连续性。图7显示了与MMWHS心脏数据集上的先前研究相比，所提出的方法的分割的出色切片方向连续性。图7-（a）、（B）、（c）和（d）分别绘制了AA、LAC、LVC和MYO代表性病例的切片Dice值。我们的SDC-UDA在切片方向上表现出渐进和一致的分割性能，而最近提出的医学UDA方法SIFA和PSIGAN在切片方向上表现出非常不一致的分割性能，有时会突然波动。这表明所提出的方法在临床实践中是有用的，其中需要精确的体积分割来分析患者的状态具有高置信度的潜力。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202405122225444.png" alt="image-20240512222529361"></p><h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>在这项研究中，我们提出了SDC-UDA，一种新的体积UDA框架切片方向连续跨模态医学图像分割，并验证了它在多个公共数据集。SDC-UDA通过切片内和切片间的自我关注有效地转换医学体积，并通过简单而有效的伪标签细化策略（利用不确定性图）增强的体积自训练更好地适应目标域。消融研究证明了每个组件的有效性和比较研究表明所提出的方法的上级性能。</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>广义无源域适应</title>
    <link href="/cblog/2024/04/11/%E5%B9%BF%E4%B9%89%E6%97%A0%E6%BA%90%E5%9F%9F%E9%80%82%E5%BA%94/"/>
    <url>/cblog/2024/04/11/%E5%B9%BF%E4%B9%89%E6%97%A0%E6%BA%90%E5%9F%9F%E9%80%82%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p>源码：<a href="https://github.com/Albert0147/G-SFDA">https://github.com/Albert0147/G-SFDA</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>广义无源域适应</p><p>Generalized Source-free Domain Adaptation</p><p>作者：<a href="https://ieeexplore.ieee.org/author/37088864071">杨世奇</a>;<a href="https://ieeexplore.ieee.org/author/37089065723">王亚兴</a>;<a href="https://ieeexplore.ieee.org/author/37295645400">约斯特·范·德·韦杰尔</a>；<a href="https://ieeexplore.ieee.org/author/37540708000">路易斯·赫兰兹</a>；</p><p>期刊：2021 IEEE&#x2F;CVF 国际会议</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>域适应（DA）旨在将从源域学到的知识转移到未标记的目标域。</p><p><strong>无源域自适应</strong></p><ol><li>“无源”表示没有标记的数据，即在目标域中没有标签或标签非常有限。</li><li>无源域自适应的目标是利用源域中的有标签数据，以及目标域中的无标签数据，来训练一个能够在目标域上表现良好的模型，而无需目标域的标签数据。</li><li>该技术的主要挑战是如何在源域和目标域之间找到有效的特征表示，使得模型在目标域上能够泛化到新的数据，而不会受到源域和目标域之间的分布差异的影响。常见的无源域自适应方法包括深度特征对齐、领域间对抗训练等。</li></ol><p>这些方法没有考虑保持源性能，</p><p>提出<strong>广义无源域适应（G-SFDA）</strong>。其中学习的模型需要在目标域和源域上都表现良好，并且在适应过程中只能访问当前未标记的目标数据。</p><p><strong>局部聚类（LSC）</strong>：旨在将目标特征与其语义相似的邻居进行聚类，从而在缺乏源数据的情况下成功地将模型适应目标域。</p><p><strong>稀疏域注意力（SDA）</strong>：它产生一个二元域特定注意力来激活不同域的不同特征通道，同时域注意力将用于在适应过程中正则梯度以保留源信息。</p><p>在适应后适用于所有领域单个或多个目标域。</p><h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><p><em>域适应</em>（DA）方法旨在通过减少标记源域和未标记目标域之间的域转移，将从标签丰富的数据集（源域）学到的知识转移到其他未标记数据集（目标域）。</p><p>大多数DA方法的一个关键要求是它们需要在适应过程中访问源数据，这在许多实际应用中通常是不可能的，例如在计算能力有限的移动设备上部署域适应算法，或者在数据隐私规则限制对源域的访问。</p><p><em>源域适应</em>(SFDA) 设置（仅提供源预训练模型而不是源数据）</p><p>SHOT [20]和 3C-GAN [18]与本文最相关，它们适用于源域和目标域具有相同类别的近集 DA。 </p><p>3C-GAN [18]基于条件 GAN 的目标式图像生成，SHOT [20]提出将源假设（即固定源分类器）转移到目标数据，同时最大化互信息。</p><p>即使源数据随时可用，某些 DA 方法的源性能在适应后也会下降。目前的 SFDA 方法通过微调源模型来关注目标领域，导致忘记旧领域。</p><p>解决此设置的一个简单方法是仅存储源模型和目标模型</p><p><strong>我们提出了一种新的 DA 范式，其中模型预计在无源域适应后在所有域上表现良好。我们将此设置称为<em>通用无源域适应</em>(G-SFDA)。</strong>为简单起见，在本文中，我们将首先关注单个目标域，然后描述如何扩展到持续无源域适应。</p><ol><li>为了在没有源数据的情况下执行对目标域的适应，我们首先提出局部结构聚类（LSC），它将每个目标特征与其最近的邻居聚类在一起。</li><li>为了保持源性能，我们建议使用稀疏域注意力（SDA），应用于特征提取器的输出，根据特定域激活不同的特征通道。源域注意力将用于在目标适应期间正则化梯度，以防止忘记源信息。</li></ol><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ol><li>一种新的域适应范式，称为广义无源域适应（G-SFDA），其中源预训练模型在没有源数据的情况下适应目标域，同时保持源域的性能。</li><li>局部结构聚类（LSC）来实现无源域自适应，它利用特征空间中的局部邻居信息。</li><li>稀疏域注意力（SDA），它为不同的域激活不同的特征通道，并在目标适应期间正则化反向传播的梯度以保留源域的信息。</li><li>当现有方法遭受遗忘并在源域上获得较差性能时，我们的方法能够保持源域性能。此外，当专注于目标领域时，我们的方法与现有方法相当或更好，特别是我们在 VisDA 上实现了最先进的目标性能。</li></ol><h3 id="VisDA"><a href="#VisDA" class="headerlink" title="VisDA"></a>VisDA</h3><p>VisDA是Visual Domain Adaptation的缩写，指的是视觉领域适应（Visual Domain Adaptation）。VisDA挑战赛是一个由CVPR（Computer Vision and Pattern Recognition，计算机视觉与模式识别）社区组织的竞赛，旨在推动视觉领域适应技术的发展。</p><p>在VisDA挑战赛中，参与者需要开发算法来解决跨领域的视觉识别问题。具体来说，他们需要训练一个模型，在一个视觉领域（通常是源域）中学习，然后将该模型应用于另一个不同的视觉领域（通常是目标域）中进行测试。这个过程旨在测试模型在不同领域之间的泛化能力和适应性。</p><p>VisDA挑战赛通常包含多个任务和数据集，涉及不同类型的图像数据，如物体识别、场景分类等。</p><h1 id="第二节-相关作品"><a href="#第二节-相关作品" class="headerlink" title="第二节 相关作品"></a>第二节 相关作品</h1><h2 id="领域适应"><a href="#领域适应" class="headerlink" title="领域适应"></a>领域适应</h2><h2 id="无源域适应"><a href="#无源域适应" class="headerlink" title="无源域适应"></a>无源域适应</h2><p>正常的域适应方法需要在适应期间访问源数据。</p><p>与我们的工作相关的是 SHOT [20]和 3C-GAN [18]，两者都用于 close-set DA。 SHOT提出固定源分类器，并通过最大化互信息和伪标签将目标特征与固定分类器匹配。 3C-GAN 基于条件 GAN 合成标记目标式训练图像。</p><p><strong>尽管实现了良好的目标性能，但这些方法在适应后无法保持源性能。除了这些方法之外，我们的目标是在适应后保持源域性能。</strong></p><h2 id="持续领域适应"><a href="#持续领域适应" class="headerlink" title="持续领域适应"></a>持续领域适应</h2><p><strong>持续学习</strong>（CL）特别关注在学习新任务时避免灾难性遗忘，但它不是为 DA 量身定制的，因为 CL 中的新任务通常具有标记数据。</p><h1 id="第三节-方法"><a href="#第三节-方法" class="headerlink" title="第三节 方法"></a>第三节 方法</h1><p>无源无监督域适应的方法。然后我们介绍我们的方法来防止忘记源模型的知识。接下来，我们详细阐述如何统一这两个模块来解决广义无源域适应（G-SFDA）问题，并训练域分类器以进行与域无关的评估。最后，我们将我们的方法扩展到连续的无源域。</p><h2 id="3-1-问题设置"><a href="#3-1-问题设置" class="headerlink" title="3.1 问题设置"></a>3.1 问题设置</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121445091.png" alt="image-20240414121445091">表示标记的源域数据，<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121257661.png" alt="image-20240414121257661">，<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121327303.png" alt="image-20240414121327303">是对应<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121428804.png" alt="image-20240414121428804">的标签，并且将具有<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121704124.png" alt="image-20240414121704124">个样本的未标记的目标域数据表示<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121730648.png" alt="image-20240414121730648">，类的数量是C。在无源设置中，我们在这里考虑Ds仅在模型预训练期间可用。我们的方法基于神经网络，我们将其分为两部分：特征提取器f和仅包含一个全连接层的分类器g，网络的输出表示为<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414121834346.png" alt="image-20240414121834346"></p><h2 id="3-2-局部结构聚类"><a href="#3-2-局部结构聚类" class="headerlink" title="3.2 局部结构聚类"></a>3.2 局部结构聚类</h2><p>大多数领域适应方法旨在对齐源域和目标域的特征分布。在无源无监督域适应（SFDA）中，这一点并不明显，因为算法在适应过程中不再访问源域数据。</p><p>源模型提供的关于目标数据的两个主要信息源：类预测<strong><em>p</em> ( x )</strong> 和特征空间**f( <em>x</em> )**中的位置。</p><p><strong>主要思想：</strong>期望目标域的特征相对于源域发生移动，但是，我们期望类仍然在特征空间中形成簇，因此，我们的目标是将数据点的聚类移动到它们最可能的类预测。</p><p>算法：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang1-p10-yang-small.gif" alt="图 1：- 局部结构聚类 (LSC)。由于域转移，源模型中的一些目标特征将偏离密集的源特征区域。 LSC 旨在通过语义上邻近的目标特征（由黑线连接）对目标特征进行聚类。 "></p><p>局部结构聚类（LSC）。由于域转移，源模型中的一些目标特征将偏离密集的源特征区域。 LSC 旨在通过语义上邻近的目标特征（由黑线连接）对目标特征进行聚类。</p><p>为了找到语义上接近的邻居，我们建立了一个存储目标特征的特征库。<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414130109750.png" alt="image-20240414130109750"></p><p>与之不同的是，我们只使用特征库中的少量邻域对目标特征进行一致性正则化聚类。</p><p>接下来，我们构建存储对应的软最大化预测分数的分数库<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414130226646.png" alt="image-20240414130226646"></p><p>局部结构聚类是通过应用以下损失来鼓励k最近特征之间的一致预测来实现的：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414130318106.png" alt="image-20240414130318106"></p><p>我们首先基于余弦相似度在特征库中为每个当前目标特征找到k-最近邻N。最小化当前目标样本的预测分数Xi与N的存储的预测分数s（Nk）之间的点积的负对数值，旨在鼓励特征和它的几个邻居之间的一致预测。</p><p>第二项通过鼓励预测平衡来避免退化解决方案。</p><p>这里<em>p c</em>是经验标签分布；它表示<em>c</em>类的预测概率，<em>q</em>是均匀分布。</p><p>在实验中，我们将通过验证最近邻居是否共享正确的预测标签来证明所提出的 LSC 的有效性。</p><h2 id="3-3-稀疏域注意力"><a href="#3-3-稀疏域注意力" class="headerlink" title="3.3 稀疏域注意力"></a>3.3 稀疏域注意力</h2><p>在G-SFDA设置下，我们不仅希望具有高目标性能，而且希望在不访问源数据的情况下保持源性能。</p><p>我们建议通过稀疏域注意力（SDA）向量<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414135343951.png" alt="image-20240414135343951">仅激活不同域的<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414135411297.png" alt="image-20240414135411297">其包含接近于二进制的值，这将屏蔽特征提取器的输出。我们采用嵌入层来自动产生域自适应。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414135508971.png" alt="image-20240414135508971"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414143825916.png" alt="image-20240414143825916">是嵌入层的输出，<em>σ</em>是<em>sigmoid</em>函数，常数 100 是为了确保接近二进制的输出，但仍然可微。As和At两者都在源域上进行训练，并在适应目标域期间固定。此外，在源训练时，我们对嵌入层使用<strong>稀疏正则化</strong>和<strong>梯度补偿</strong>，我们使用 SDA 来构建特定于域的信息流，其中某些通道特定于每个域。我们可以通过规范流入源掩模中激活的通道的梯度来维护源信息。</p><p>为了训练源域，我们应用源注意力As，在适应目标域时，我们使用稀疏目标注意力At用于向前传递。为了防止遗忘，不应该对存在于As中的特征通道进行更新。</p><p>原因有二：首先，这些通道的信息是在无源自适应到目标域期间提供的唯一源信息;保留这些信息可以促进目标自适应，其次更重要的是，在G-SFDA设置下，我们希望在自适应之后保持源性能，因此目标自适应不应该干扰与源域相关联的特征流向这些通道的信息。</p><p>如图2（c）所示，在目标自适应期间，我们建议使用源注意力As来正则化在反向传播期间流向分类器和特征提取器的梯度：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414145348632.png" alt="image-20240414145348632"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414161922206.png" alt="image-20240414161922206">表示逐元素乘法，<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414162038569.png" alt="image-20240414162038569">是k维全1向量（<strong>全一向量</strong>：所有元素都为1的向量。)，<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414162958502.png" alt="image-20240414162958502">，<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414163030552.png" alt="image-20240414163030552">是特征提取器中最后一层的权重，<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414163108342.png" alt="image-20240414163108342">是分类器的权重，这里，源注意力As用于正则化流入源激活通道（用于特征提取器)以及分类器中的对应神经元的梯度。通过等式3和等式4、源信息有望得到保存。</p><p>我们的掩蔽只能防止最后两层<em>W fl</em>和<em>W g中的遗忘。</em>我们确保对源域性能至关重要的功能仅进行最小程度的更改，并且目标域特定功能用于解决域转移。我们的方法并不能防止源域的所有遗忘，因为我们没有规范特征提取器中内层的梯度。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414163645364.png" alt="image-20240414163645364"></p><p><strong>权重掩盖</strong>（也称为<strong>权重掩码</strong>）是一种在机器学习中常见的正则化技术，其目的是通过限制神经网络中权重的取值范围来防止过拟合 让我详细解释一下：</p><ul><li><strong>权重掩盖</strong>本质上是一个与权重参数形状相同的二进制张量。<strong>其中，0表示对应的权重参数被掩盖（不参与训练），1表示对应的权重参数保持不变。</strong></li><li><strong>通过将掩码与权重参数相乘，可以实现对权重参数的掩盖。这意味着在训练过程中，某些权重的更新会被抑制，从而限制了模型的复杂性，减少了过拟合的风险。</strong></li></ul><p>权重掩盖在训练期间对权重进行动态调整，以平衡模型的性能和泛化能力。它是一种有效的正则化方法，有助于提高模型的鲁棒性和泛化能力。</p><h2 id="3-4-统一培训"><a href="#3-4-统一培训" class="headerlink" title="3.4 统一培训"></a>3.4 统一培训</h2><p>在本节中，我们首先说明如何将培训与SDA和LSC相结合。</p><ul><li><p>首先我们使用交叉熵损失在<strong>数据集 Ds</strong> 上训练模型，同时使用源域和目标域的注意力 <strong>As</strong> 和 <strong>At</strong>。这是为了为目标适应提供良好的初始化，而在目标适应中仅使用 <strong>At</strong>。</p></li><li><p>我们将源模型适应到目标域，使用目标注意力 <strong>At</strong> 并仅访问目标域数据 <strong>Dt</strong>。在反向传播过程中，我们根据<strong>公式3</strong>和<strong>公式4</strong>对梯度进行正则化。与仅在第3.2节中使用LSC进行训练不同，这里我们构建了特征库 <strong>F &#x3D; {(f(xi)At)}xi∈Dt</strong>，其中我们放弃了不相关的通道，因为这些通道不会对当前预测产生贡献，可能包含噪声。出于同样的原因，在使用k最近邻算法时，我们还将目标注意力应用于特征，因此<strong>公式1</strong>中的 <strong>N{1,…,K}</strong> 变成了：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414164152769.png" alt="image-20240414164152769"></p></li></ul><p>在实验部分，我们将考虑使用<strong>G-SFDA</strong>（具有<strong>域感知</strong>）以及不使用（<strong>域无关</strong>）推理时的<strong>域ID</strong>。在更具挑战性的设置中，<strong>域ID</strong>是不可用的，需要进行估计。因此，我们提出训练一个<strong>域分类器</strong>，该分类器接收特征 <strong>f(x)</strong> 来估计测试样本的<strong>域ID</strong>，仅存储源域中一小组图像。我们将在实验中展示，在具有挑战性的<strong>域无关</strong>设置中，我们获得了与较简单的<strong>域感知</strong>设置类似的结果。</p><ul><li><strong>域ID</strong>（或<strong>域标识</strong>）是指不同数据集或环境之间的区分标志。在领域自适应任务中，我们通常有一个源域（例如，一个数据集）和一个目标域（另一个数据集）。目标域可能与源域在分布、特性或环境上存在差异。</li><li><strong>域ID估计</strong>的目标是在目标域中估计或推断出样本所属的域。这对于在目标域中进行模型适应和泛化至关重要。如果我们知道样本属于哪个域，我们可以根据该域的特点来调整模型，以更好地适应目标域。</li></ul><h2 id="3-5-持续的无源域适应"><a href="#3-5-持续的无源域适应" class="headerlink" title="3.5 持续的无源域适应"></a>3.5 持续的无源域适应</h2><p>在这里，我们将说明如何将我们的方法扩展到<strong>连续无源域自适应</strong>，其中模型仅根据当前目标域数据进行适应，而不考虑源域。假设有 <strong>Nt</strong> 个目标域。</p><p>首先，在源预训练阶段，我们使用来自SDA的所有域注意力 <strong>As</strong> 和 <strong>{Ati}i&#x3D;1,Nt</strong> 进行训练，以获得良好的初始化。</p><p>然后，在适应到第 <strong>j</strong> 个目标域时，我们计算 <strong>A′</strong>，该向量考虑了除当前目标域之外的所有域注意力。我们将 <strong>Eq. 3</strong> 和 <strong>Eq. 4</strong> 中的 <strong>As</strong> 替换为 <strong>A′</strong>，用于当前梯度的正则化。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414164832016.png" alt="image-20240414164832016"></p><p>在这里，<strong>max</strong> 是逐元素操作，**A’**是从 <strong>As</strong> 初始化得到的。使用 <strong>A’</strong> 进行梯度正则化意味着在一个目标域上的训练不应影响其他目标域。</p><h1 id="第四节-实验"><a href="#第四节-实验" class="headerlink" title="第四节 实验"></a>第四节 实验</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ol><li><em>Office-Home</em>包含 4 个域（真实、剪贴画、艺术、产品），65 个类，总共 15,500 张图像。</li><li><em>VisDA</em> 是一个更具挑战性的数据集，有 12 个类别。其源域包含 152k 合成图像，而目标域包含 55k 真实物体图像。</li></ol><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>我们主要在两种不同的环境下与现有的方法进行比较，一种是正常的DA和SFDA设置，目标性能是唯一的焦点。另一个是我们提出的G-SFDA设置，在无源域适配后，适配模型预计在源域和目标域上都具有良好的性能。在此设置中，我们计算源和目标精度之间的调和平均值：<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240414170727071.png" alt="image-20240414170727071">AccS和AccT分别是源测试数据和目标测试数据的准确度。对于SFDA，我们使用所有源数据进行模型预训练。</p><p>对于G-SFDA，我们仅使用部分数据（Office-Home 为 80%，VisDA 为 90%），其余的源数据用于评估源性能。</p><p>我们在域感知和域不可知设置下提供结果（我们使用域分类器估计域 ID）。最后，我们报告了持续无源域适应的结果。</p><p><strong>表 1：</strong> 基于 ResNet101 的无监督域自适应方法在 VisDA-C 上的准确度 (%)。无源意味着在适配过程中无需访问源数据即可进行设置。下划线的结果是第二高的结果。我们的结果是使用目标注意力At。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang.t1-p10-yang-large.gif" alt="img"></p><p><strong>VisDA</strong> 是一个更广泛的数据集，而 <strong>VisDA-C</strong> 则是专注于视觉领域的子集。</p><p><strong>表 2：</strong> 基于 ResNet50 的无监督域适应方法的 Office-Home 的准确度 (%)。无源是指无源设置，在适配过程中无需访问源数据。下划线表示第二高的结果。我们的结果是使用目标注意力At。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang.t2-p10-yang-large.gif" alt="img"></p><ol><li><strong>Art</strong>（艺术）：包括素描、绘画、装饰等艺术形式的图像。</li><li><strong>Clipart</strong>（剪贴画）：收集的剪贴画图像。</li><li><strong>Product</strong>（产品）：没有背景的物体图像。</li><li><strong>Real-World</strong>（真实世界）：使用普通相机拍摄的物体图像</li></ol><p><strong>表 3：</strong> 在 G-SFDA 设置下使用 ResNet-101 作为主干的 VisDA 数据集上每种方法的准确度 (%)。为源数据集随机指定 0.9&#x2F;0.1 训练&#x2F;测试分割。 T 和 S 表示目标域和源域的准确性。域 ID 意味着在评估期间可以访问域 ID，我们在域感知和不可知设置下提供结果。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang.t3-p10-yang-large.gif" alt="img"></p><p><strong>表 4：</strong> 在 G-SFDA 设置下使用 ResNet-50 作为骨干的 Office-Home 数据集上每种方法的准确度 (%)。为源数据集随机指定 0.8&#x2F;0.2 训练&#x2F;测试分割。 T 和 S 表示目标域和源域的准确性。域 ID 意味着在评估期间可以访问域 ID，无域 ID 意味着使用域分类器估计的域 ID。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang.t4-p10-yang-large.gif" alt="img"></p><p><strong>表 5：（</strong> 左二）Office-Home 和 VisDA 的消融研究。 S 和 T 表示源精度和目标精度。 （右二）消除每个域存储的图像数量以训练域分类器。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang.t5-p10-yang-large.gif" alt="img"></p><p><strong>表6：</strong> 连续无源域适应，模型从源域（第一个域）顺序适应所有目标域。源域的结果在测试集上报告。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang.t6-p10-yang-large.gif" alt="img"></p><h2 id="4-1-与最先进的技术相比"><a href="#4-1-与最先进的技术相比" class="headerlink" title="4.1.与最先进的技术相比"></a>4.1.与最先进的技术相比</h2><p>VisDA 和 Office-Home 数据集的结果如表 1 所示。</p><p>首先我们的方法（带域 ID）获得了显着更高的<em>H</em>值，在 Office-Home 上将 SHOT 提高了 8.8%，在 VisDA 上提高了 4.6%。增益主要归功于源数据集上的优异结果，因为 SHOT 会出现遗忘问题。</p><h2 id="4-2-分析和进一步的实验"><a href="#4-2-分析和进一步的实验" class="headerlink" title="4.2.分析和进一步的实验"></a>4.2.分析和进一步的实验</h2><h3 id="训练曲线"><a href="#训练曲线" class="headerlink" title="训练曲线"></a><strong>训练曲线</strong></h3><p>如图3（a）所示，SDA在整个自适应阶段期间的源性能是相当平滑的，这证明了SDA的效率。</p><h3 id="最近邻数K"><a href="#最近邻数K" class="headerlink" title="最近邻数K"></a>最近邻数K</h3><p>在图3（B）中，我们显示了等式中不同K ∈ {1，5，10，15，20，30}的结果。1、VisDA。我们的方法对K的选择是相当鲁棒的，只有K是1才会导致较低的结果。我们推测，如果特征位于密集区域，则在等式1中仅使用单个最近邻可能会有噪声。</p><h3 id="SDA消融研究"><a href="#SDA消融研究" class="headerlink" title="SDA消融研究"></a>SDA消融研究</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang4-p10-yang-large.gif" alt="img"></p><p>如图 4 所示。这里的 <strong>Accn</strong> 表示目标特征与其 3 个最近邻的预测标签相同的百分比，而在这些特征中，<strong>Accnp</strong> 表示具有正确共享预测标签的百分比。</p><h3 id="领域分类器"><a href="#领域分类器" class="headerlink" title="领域分类器"></a>领域分类器</h3><p>我们将结果报告为用于训练域分类器的存储图像数量的函数（表 5右侧）。对于 Office-Home，我们确保每个班级至少有一张图像。结果表明，在存储少量图像的情况下，学习到的域 ID 分类器效果良好。</p><h3 id="t-SNE-可视化"><a href="#t-SNE-可视化" class="headerlink" title="t-SNE 可视化"></a>t-SNE 可视化</h3><p>我们可视化适应前后的特征，这些特征已经被不同的领域注意力所掩盖，源特征和目标特征预计独立聚类，如<strong>图5</strong>所示。源簇在适应后保持良好，无序的目标特征在适应后变得更加结构化。我们还可视化共享和特定域通道中的功能。如<strong>图6</strong>所示，共享域通道中的特征聚集在一起，但特定域通道中的特征跨域完全分离。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang5-p10-yang-large.gif" alt="img"></p><p>图5、Office-Home 的任务 Ar <em>→</em> Pr适应前后的 t-SNE 特征可视化。蓝色是源特征，红色是目标特征。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/yang6-p10-yang-large.gif" alt="img"></p><p>图6、适应后来自域共享和域特定通道的特征的 t-SNE（Office-Home 上的任务 Ar <em>→</em> Pr）。蓝色是源特征，红色是目标特征。</p><h3 id="持续的无源域适应"><a href="#持续的无源域适应" class="headerlink" title="持续的无源域适应"></a>持续的无源域适应</h3><p>我们还在表中提供了持续无源域适应的结果（域感知）。</p><p>表6结果表明它可以很好地适用于所有领域。</p><p>有趣的是，适应一个目标域会提高未见过的目标域的性能，例如，当将模型从源域<em>Cl</em>适应第一个目标域<em>Ar</em>时，未见的目标域<em>Rw</em>也会获得增益。原因是当前学到的信息对未来的目标领域也有帮助。请注意，对于某些目标域，与直接从源到域进行适应相比，结果较低，原因是我们通过使用更多的梯度正则化来减少学习通道，如<a href="https://ieeexplore.ieee.org/document/#deqn6">等式1所示。 6</a>，意味着需要更多的容量来适应更多的领域。</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聚类引导的半监督域自适应医学图像分类</title>
    <link href="/cblog/2024/04/10/%E8%81%9A%E7%B1%BB%E5%BC%95%E5%AF%BC%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <url>/cblog/2024/04/10/%E8%81%9A%E7%B1%BB%E5%BC%95%E5%AF%BC%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>聚类引导的半监督域自适应医学图像分类</p><p>Cluster-Guided Semi-Supervised Domain Adaptation for Imbalanced Medical Image Classification</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>半监督DA：使用目标域的很多未标记的样本和少量标记样本修改源域分类器来构建目标域分类器的技术。</p><p>内容：弱监督的聚类管道来获得高纯度的聚类，并在表示学习中利用这些聚类来进行领域适应。</p><h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><p><strong>无监督</strong>域适应场景中，目标域中的所有样本都是未标记的。通过使用未标记的样本修改分类器，分类器开始适用于目标域样本。</p><p><strong>半监督域适应</strong>：即使在目标域中，我们也有少量标记样本。使用它们作为两个域之间的桥梁将对域适应产生比无监督场景更可靠的影响。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ol><li><p><strong>假设来自目标域的未标记样本分布在同一类标记目标样本周围</strong></p></li><li><p><strong>为所有标记和未标记的目标样本引入聚类，得到高纯度的簇，执行簇族域适应</strong></p><p><font color='red'>高纯度的簇通常意味着聚类算法能够有效地将数据点归类到它们真实的类别中，从而提供了有用的聚类结果。</font></p></li><li><p><strong>难点：</strong>医学图像，简单的聚类技术并不合适。这是因为医学图像通常严重类别不平衡，并且朴素的聚类技术会导致低纯度的聚类。</p></li><li><p><strong>方法</strong>：<strong>弱监督聚类</strong></p></li></ol><h3 id="方法细化"><a href="#方法细化" class="headerlink" title="方法细化"></a>方法细化</h3><p>通过<em>k</em>均值引入了两个针对初始聚类结果的细化步骤</p><ol><li>第一个细化步骤是通过软约束聚类进行聚类细化</li><li>第二个是通过基于比例的分裂来细化集群。</li><li>还提出了一个目标函数，用于通过标记的目标样本引导属于同一簇的未标记的目标样本。</li></ol><h1 id="第二节-聚类引导的半监督域适应"><a href="#第二节-聚类引导的半监督域适应" class="headerlink" title="第二节 聚类引导的半监督域适应"></a>第二节 聚类引导的半监督域适应</h1><h3 id="A-问题设置"><a href="#A-问题设置" class="headerlink" title="A.问题设置"></a>A.问题设置</h3><p>不仅使用Ds而且使用{Dt，Du}来提高分类性能的问题。由于我们在目标域中具有标记样本Dt，因此该问题被称为半监督域自适应。</p><h3 id="B-弱监督聚类（三步）"><a href="#B-弱监督聚类（三步）" class="headerlink" title="B.弱监督聚类（三步）"></a>B.弱监督聚类（三步）</h3><h4 id="1-k均值聚类"><a href="#1-k均值聚类" class="headerlink" title="1.k均值聚类"></a>1.k均值聚类</h4><p>图1b中，对目标样本进行k均值聚类，聚类的数量K被设置为大于数据集中的类的实际数量。</p><h4 id="2-软约束聚类进行聚类细化"><a href="#2-软约束聚类进行聚类细化" class="headerlink" title="2.软约束聚类进行聚类细化"></a>2.软约束聚类进行聚类细化</h4><p>如图1（b）中的绿色聚类所示</p><p>通过软约束聚类的聚类细化：第一聚类细化步骤旨在划分每个冲突聚类，（具有来自不同类别标签的样本的聚类）分成几个不冲突的聚类。</p><p><strong>软约束聚类：</strong></p><p>约束聚类引入了两种类型的约束，称为<strong>必须链接</strong>和<strong>不能链接</strong>。</p><p><strong>must-link：</strong>是指应该被分组到同一个聚类中的一对样本。</p><p><strong>cannotlink</strong>是指不应该被分到同一个簇的样本。</p><p>任务中：如果我们在同一初始簇中找到具有不同标签的样本（通过<em>k</em>均值），则加上<strong>cannot-link</strong>，类似地，如果我们在初始簇中找到具有相同标签的样本，则加上<strong>must-link</strong>。附加链接后，我们在满足链接约束的情况下再次执行聚类。</p><h4 id="3-基于比例的拆分进行聚类细化"><a href="#3-基于比例的拆分进行聚类细化" class="headerlink" title="3.基于比例的拆分进行聚类细化"></a>3.基于比例的拆分进行聚类细化</h4><p>第二个聚类细化步骤的目的是根据类别比例 ( <em>p</em> 1 ,…, <em>p C</em> )（<strong>即先验类别概率</strong>）将聚类分割成更小的聚类</p><p>类别比例是通过标记目标样本之间的类别比例推断出来的。</p><p>此目标与之前的细化步骤类似，但使用不同的标准。粗略地说，在第一次细化之后，如果我们发现一个包含一个或多个标记样本的大簇，那么该簇将是一个非纯簇，应该被分成更小的簇。</p><p>我们通过使用类比例将较大的簇分成较小的簇。（k均值）</p><h3 id="C-聚类引导的域适应"><a href="#C-聚类引导的域适应" class="headerlink" title="C.聚类引导的域适应"></a>C.聚类引导的域适应</h3><p><strong>聚类引导的域适应</strong></p><p>图1(c)和(d) </p><ol><li>CNN 模型针对两个目标进行训练。<strong>一是对所有标记样本进行分类</strong>，通过交叉熵损失使源样本和标记的目标样本更加接近。</li><li>另一种是引导未标记样本更接近标记样本重新训练后属于同一簇</li></ol><p><strong>目标函数</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202404102254916.png" alt="image-20240410225441509"></p><p>f（x）表示样本x的特征向量，通过使用该损失训练<em><strong>f</strong></em>，以及标记样本的引导，将未标记样本逐渐映射到源域的相应类xju。</p><h1 id="第三节-实验"><a href="#第三节-实验" class="headerlink" title="第三节 实验"></a>第三节 实验</h1><h2 id="数字数据集"><a href="#数字数据集" class="headerlink" title="数字数据集"></a>数字数据集</h2><ol><li>MNIST</li><li>USPS</li><li>SVHN</li></ol><p>根据帕累托分布，对原始数据进行欠采样。所有图像在源域中进行标记，并随机采样 2% 图像作为目标域中的标记数据。</p><h2 id="宫颈癌数据集"><a href="#宫颈癌数据集" class="headerlink" title="宫颈癌数据集"></a>宫颈癌数据集</h2><p>从两家医院收集了 WSI 图像，并将它们用作源域和目标域。源域数据集包含 158 个 WSI。目标域数据集包含 106 个 WSI，每个WSI被切割成256×256像素的块。</p><p>从源域收集了 163,877 个补丁图像，从目标域收集了 71,598 个补丁图像。在实验中，通过患者不相交的随机样本分割进行 5 倍交叉验证，<strong>其中训练和测试集中不存在同一患者</strong>。</p><p>每个样本都被标记为三个宫颈癌阶段之一：非肿瘤（Non-Neop.）、低度鳞状上皮内病变（LSIL）和高度鳞状上皮内病变（HSIL）。该数据集显示三个类别之间存在严重的类别不平衡。例如，源域的样本为 146,524 Non-Neop.、5,646 LSIL 和 11,707 HSIL。</p><h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><p>两种方法是简单的监督学习方法：一种是用标记的源样本（<strong>S</strong>）训练的模型，另一种是用标记的源样本和标记的目标样本（<strong>S+T</strong>）训练的模型。</p><p><strong>DANN</strong> [2]和<strong>COAL</strong> [5]是无监督域适应方法，<strong>ENT</strong> [15]、<strong>MME</strong> [6]和<strong>CDAC</strong> [9]是半监督域适应方法。为了公平比较，我们修改了这些无监督域适应方法以适应半监督域适应。</p><p>使用每类 Dicecoefficient (mDice) 的平均值，它已广泛用于分割性能。为了证明我们的方法对不平衡数据的有效性，我们还在使用宫颈癌数据集的实验中显示了次要类别 LSIL 类别 (MiDice) 的 Dice 系数。</p><p>使用ImageNet进行预训练的ResNet-50初始化为模型<em><strong>f</strong></em> ，通过使用标记的源域数据对其进行训练Ds。然后，我们通过重复图 1(b)-(d)的步骤来重新训练模型。我们通过提前停止参考验证集的 mDice 来终止模型的训练。初始聚类的簇数<em>K (</em> <em>k</em> -means) 设置为 30，这大于两个数据集中的类数。此外，软约束聚类的簇数设置为<em>K</em>乘以属于该冲突簇的目标样本与所有目标样本的比率。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202404102306892.png" alt="image-20240410230602817"></p><p>目标域的分割结果示例。右起各列显示了 MME 的分割结果（表 2中第二好）和所提出的方法。灰色、蓝色、红色和黑色分别表示非Neop.、LSIL、HSIL和Nolabel区域。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202404102307924.png" alt="image-20240410230736828"></p><p>数字数据集上每类 Dice 系数 (mDice) 的平均值。</p><p>该结果表明，当将 USPS 设置为目标域时，所提出的方法并不有效。由于该方法使用标记目标样本作为anchor，当样本数量极少且标记目标样本数量有限时，预计不会产生显着效果；MNIST、USPS 和 SVHN 中的样本数量分别为 8,396、836 和 7,216。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202404102308538.png" alt="image-20240410230833480"></p><p>宫颈癌分期分类结果。</p><p>与作为基线的 S+T 相比，所有比较方法的性能均有所下降。相比之下，所提出的方法实现了性能的提高，并且优于 MiDice 中的比较方法。这些结果证实了所提出的方法对于类不平衡场景（医学图像分类的典型情况）具有鲁棒性。</p><p>图2显示了从MME（表2中第二好的）和所提出的方法获得的目标域WSI的分割结果的示例。图 2证实了 MME 错误地预测了 Non-Neop。到小班。相比之下，所提出方法的预测大致正确。这些结果表明，现有方法倾向于将主要类别的预测偏向次要类别，而所提出的方法没有这种倾向，因为它解决了类别不平衡问题。</p><h1 id="第四节-局限性"><a href="#第四节-局限性" class="headerlink" title="第四节 局限性"></a>第四节 局限性</h1><p>当前试验的局限性假设未标记目标样本的类比例 ( <em>p</em> 1 ,…, <em>p C</em> ) 大致接近标记目标样本的类比例。假设所选样本存在意外偏差。在这种情况下，它不仅会扰乱类比例（<em>p</em> 1 ,…, <em>p C</em>）的推断，而且还会使每个簇中标记样本的数量产生很大差异。</p><p>可以引入策略来自动选择覆盖目标域样本变化的样本。</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域适应：挑战、方法、数据集和应用</title>
    <link href="/cblog/2024/04/07/%E9%A2%86%E5%9F%9F%E9%80%82%E5%BA%94%EF%BC%9A%E6%8C%91%E6%88%98%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <url>/cblog/2024/04/07/%E9%A2%86%E5%9F%9F%E9%80%82%E5%BA%94%EF%BC%9A%E6%8C%91%E6%88%98%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8C%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>领域适应：挑战、方法、数据集和应用</p><p>Domain Adaptation: Challenges, Methods, Datasets, and Applications</p><h1 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h1><p>IEEE ACCESS    2023 年 1 月 16 日</p><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>本调查报告讨论了 DA 如何通过审查 DA 方法和技术来帮助 DNN 在这些环境中高效工作。我们考虑了五个数据领域：计算机视觉、自然语言处理、语音、时间序列和多模态数据。我们提出了一个全面的分类法，包括每个领域对应的方法、数据集、挑战和应用。</p><ol><li>编制五个数据域中现有和新兴的发展议程数据集和任务的清单。</li><li>回顾最近的发展议程方法和技术，以实现更实用的发展议程设置，例如使用更少的数据进行学习、在旅途中学习、持续适应、跨数据域是否存在领域或类别差距等。</li></ol><h1 id="论文组织"><a href="#论文组织" class="headerlink" title="论文组织"></a>论文组织</h1><ol><li>第二节中简要讨论了 DA 的背景、定义和理论</li><li>第三节中讨论了浅层或经典学习中的 DA</li><li>DL中的发展议程在第四节中讨论</li><li>第五节提到了五个数据域中使用的数据集和观测结果。</li><li>第六节提到了这一领域正在处理的挑战和问题。</li><li>第七节着眼于各行各业常见和具体的发展议程用例，并就发展议程如何提供帮助提供了视角。</li></ol><h1 id="第三节-浅层DA"><a href="#第三节-浅层DA" class="headerlink" title="第三节 浅层DA"></a>第三节 浅层DA</h1><p>要掌握 DL 中的 DA，重要的是在浅层学习（或经典学习）中学习 DA 以提供年表。任何与 DA 相关的不包括 DL 的工作都被视为浅层学习，并迎合了在 DNN 的使用变得更加普遍之前发生的 DA 工作。</p><p>浅层学习和深度学习中的 DA 方法旨在通过使用域不变的特征（也称为域不变）或将目标数据转换为训练模型以减少任务错误的形式&#x2F;空间，以某种方式加强模型。</p><p>浅层学习中的 DA 主要基于特征（匹配或对齐或转换或增强），而不是基于数据实例。</p><p>本节包括NLP、时间序列和其他数据域中常用的浅层DA策略以及CV域DA方法。</p><h2 id="A-基于特征的方法"><a href="#A-基于特征的方法" class="headerlink" title="A.基于特征的方法"></a>A.基于特征的方法</h2><p><strong>主要思想：</strong>通过减少数据分布差异来找到共享的特征嵌入&#x2F;表示。</p><table><thead><tr><th align="left">方法</th><th>数据域</th><th>文献</th><th>关键思想</th><th>分布差异判别方法的准则</th></tr></thead><tbody><tr><td align="left">1、特征匹配</td><td>CV</td><td>[13]</td><td>保留共同的潜在表示和输入数据的属性。使用距离度量是常见的。</td><td>MMD</td></tr><tr><td align="left"></td><td>CV</td><td>[15]</td><td>学习在两个领域中共同的转移组件。重点是发现那些不会导致跨领域分布变化的组件。数据的结构被保留。</td><td>MMD</td></tr><tr><td align="left"></td><td>NLP</td><td>[16]</td><td>预测“枢轴特征”，即两个领域共有的特征（使用未标记数据）。它使用辅助函数来构建共享空间，并在不同特征之间引导对应关系。</td><td>Huber loss</td></tr><tr><td align="left">2、特征增强</td><td>NLP</td><td>[18]</td><td>对源数据和目标数据的特征空间进行增强，将增强后的特征作为任何机器学习算法的输入。</td><td>SVD</td></tr><tr><td align="left"></td><td>CV</td><td>[19]</td><td>逐渐从源领域和目标领域之间的测地线路径上提取样本，并在主成分分析（PCA）之后将它们串联起来。</td><td>LDA，PLS</td></tr><tr><td align="left"></td><td>CV</td><td>[20]</td><td>核方法。源数据集和目标数据集被嵌入到 Grassmann 流形中。作者进一步提出了一种测地线流核，等于对所有测地线流子空间进行积分。</td><td>ROD</td></tr><tr><td align="left">3、特征空间对齐</td><td>CV</td><td>[21]</td><td>使用映射函数（源和目标特征向量之间的协方差矩阵）来对齐源和目标子空间，然后计算相似性函数以比较数据。</td><td>Bregman matrix divergence</td></tr><tr><td align="left">4、特征变换</td><td>CV</td><td>[22]</td><td>学习稀疏表示（非线性转换），然后通过使用最大均值差异（MMD）将转换接近。</td><td>MMD</td></tr></tbody></table><p><strong>最大均值差异 （MMD）被多种方法使用</strong></p><ol><li>MMD 是非参数的，这导致了闭合形式的解决方案 - 一个微不足道的解决方案。</li><li>MMD 仅依赖于特征，并且独立于类和类标签，因此支持无监督 DA。在半监督或监督或伪半监督的情况下，可以使用类条件 MMD 来进一步改善 DA。</li></ol><p><strong>使用再现内核希尔伯特空间 （RKHS）：</strong></p><ol><li>当数据转换为稀疏空间（如 RKHS）时，线性可分离的可能性很高。</li><li>应用于内积的表示定理意味着 RKHS 中样本的内积和样本的内积是相同的。</li></ol><p>因此，将样本转换为 RKHS 不仅会在 RKHS 中产生分布差异，还会在特征空间维度上产生分布差异。</p><h2 id="B-实例重新加权和选择方法"><a href="#B-实例重新加权和选择方法" class="headerlink" title="B.实例重新加权和选择方法"></a>B.实例重新加权和选择方法</h2><p>**实例重新权衡:**重点是完全输入数据，而不是特征。通过重新加权任务的源数据，可以最大限度地减少分布差异。实例重新加权方法也称为实例选择，因为它会导致数据的软&#x2F;硬选择。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240407143808362.png" alt="image-20240407143808362"></p><h2 id="C-混合办法"><a href="#C-混合办法" class="headerlink" title="C. 混合办法"></a>C. 混合办法</h2><p>混合方法通常同时使用基于特征的方法和实例重新加权的方法。</p><h2 id="D-异构数据的领域适应"><a href="#D-异构数据的领域适应" class="headerlink" title="D. 异构数据的领域适应"></a>D. 异构数据的领域适应</h2><p>异构数据：多模态数据</p><p>当尝试将源域和目标域特征投影到公共子空间（域不变公共潜在子空间）时，学习特征转换的尝试称为对称转换。在非对称变换中，源要素或目标要素将分别变换并对齐到目标要素或源要素。</p><h1 id="第四节-深度学习中的DA"><a href="#第四节-深度学习中的DA" class="headerlink" title="第四节 深度学习中的DA"></a>第四节 深度学习中的DA</h1><p>深度学习中 DA 的重点是将 DA 包含在深度学习过程和管道中，以便学习可转移的表示。</p><h1 id="第五节-DA中的数据集"><a href="#第五节-DA中的数据集" class="headerlink" title="第五节 DA中的数据集"></a>第五节 DA中的数据集</h1><h1 id="第七节-DA应用"><a href="#第七节-DA应用" class="headerlink" title="第七节 DA应用"></a>第七节 DA应用</h1>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>领域自适应综述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于对比半监督学习的相似解剖结构域自适应分割</title>
    <link href="/cblog/2024/04/06/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%AF%94%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%9B%B8%E4%BC%BC%E8%A7%A3%E5%89%96%E7%BB%93%E6%9E%84%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94%E5%88%86%E5%89%B2/"/>
    <url>/cblog/2024/04/06/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%AF%94%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%9B%B8%E4%BC%BC%E8%A7%A3%E5%89%96%E7%BB%93%E6%9E%84%E5%9F%9F%E8%87%AA%E9%80%82%E5%BA%94%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>基于对比半监督学习的相似解剖结构域自适应分割</p><p>Contrastive Semi-Supervised Learning for Domain Adaptive Segmentation Across Similar Anatomical Structures</p><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>顾冉、张景阳、王国泰、雷文慧、宋涛、张晓凡、李康、张韶婷</p><h1 id="期刊"><a href="#期刊" class="headerlink" title="期刊"></a>期刊</h1><p>IEEE TRANSACTIONS ON MEDICAL IMAGING, VOL. 42, NO. 1, JANUARY 2023</p><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p>半监督学习，跨解剖域适应，对比学习。</p><h1 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h1><p><a href="https://github.com/HiLab-git/DAG4MIA">https://github.com/HiLab-git/DAG4MIA</a></p><h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><ol><li><p>利用来自不同域的具有相似解剖结构的现有标注数据集进行训练。介绍了一种新的框架，称为CS-CADA，它是现有的半监督和领域自适应方法的推广。</p></li><li><p>使用了两个域共享卷积核的domain -specific Batch Normalization (DSBN) [12];并将其集成到基于Mean Teacher (MT)的一致性正则化框架中，以利用目标域中未注释的图像。</p><p>Mean Teacher 是一种半监督学习方法。</p></li><li><p>跨域对比学习策略，其中基于各自DSBN的两个域的一对特征被视为正对，否则被视为负对。</p></li><li><p>在两种不同场景(借助视网膜血管图像和眼底图像进行冠状动脉和心脏MRI分割)上进行了广泛的实验;结果表明，在目标域标注有限的情况下，我们提出的CS-CADA分割方法比现有的半监督和领域自适应方法获得了更准确的分割结果。</p></li></ol><h1 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h1><h1 id="迁移学习和领域自适应"><a href="#迁移学习和领域自适应" class="headerlink" title="迁移学习和领域自适应"></a>迁移学习和领域自适应</h1><h1 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h1><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="A-联合学习与特定领域批量归一化（DSBN）"><a href="#A-联合学习与特定领域批量归一化（DSBN）" class="headerlink" title="A.联合学习与特定领域批量归一化（DSBN）"></a>A.联合学习与特定领域批量归一化（DSBN）</h2><p>两种类型的批量归一化组成，DSBN采用各自的BN参数域S和T由于跨解剖结构的差异。同时，卷积核在域S和T之间共享，以学习类似解剖结构的一般表示。</p><h2 id="B-具有DSBN的自组装均值教师（SE-MT）"><a href="#B-具有DSBN的自组装均值教师（SE-MT）" class="headerlink" title="B.具有DSBN的自组装均值教师（SE-MT）"></a>B.具有DSBN的自组装均值教师（SE-MT）</h2><p>虽然引入的DSBN使模型能够从带注释的SL和TL中学习，但小规模TL仍然限制了模型的性能。为了解决这个问题，我们采用了自集成平均教师（SE-MT）架构，利用未注释的图像TU在目标域。具体地，教师模型T被定义为学生模型在目标域中的指数移动平均（EMA）</p><p>EMA：在深度学习中，EMA通常用于平滑模型的参数更新。在训练神经网络时，模型的参数会不断地根据梯度进行更新。然而，直接使用梯度更新可能会导致参数在训练过程中波动较大，影响模型的稳定性。为了缓解这个问题，可以使用指数移动平均对参数进行平滑处理。</p><h2 id="C-跨域对比学习"><a href="#C-跨域对比学习" class="headerlink" title="C. 跨域对比学习"></a>C. 跨域对比学习</h2><p>为了更好地处理源域和目标域之间的外观和上下文转移，我们提出了一种跨域对比学习策略，以鼓励模型捕捉相似解剖结构的域不变特征，同时对不同的图像风格保持鲁棒性。</p><p>给定来自源域和目标域xs i和xt j的一对图像，gS i和gT j都是基于其特定BN的公共分布空间中的归一化特征。它们应该彼此相似，因此被设置为正对。对于（gS i，gT i）对，它们是由通过两个不同BN归一化的源域图像xs i的相同特征产生的，由于与两个BN相关联的不同风格，它们应该彼此不同。因此，它们被设置为负对。</p><h2 id="D-整体训练损失"><a href="#D-整体训练损失" class="headerlink" title="D.整体训练损失"></a>D.整体训练损失</h2><p>总的训练损失是Eq. 2中的监督损失Lsup、Eq. 4中的无监督一致性损失Lunsup和Eq. 7中的对比学习损失Lct的组合。其公式为:</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240406163619046.png" alt="image-20240406163619046"></p><p>其中λ1，λ2作为权衡参数。一旦训练过程完成，通过参数集T的学生模型上的前向传播获得目标域图像的分割结果。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240407133308143.png" alt="image-20240407133308143"></p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第十四章 专业英语词汇知识</title>
    <link href="/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%E7%9F%A5%E8%AF%86/"/>
    <url>/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、试题分析"><a href="#一、试题分析" class="headerlink" title="一、试题分析"></a>一、试题分析</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214646956.png" alt="image-20240403214646956"></p><h2 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214728494.png" alt="image-20240403214728494"></p><h1 id="二、答题要领"><a href="#二、答题要领" class="headerlink" title="二、答题要领"></a>二、答题要领</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214748161.png" alt="image-20240403214748161"></p><h1 id="三、答题步骤"><a href="#三、答题步骤" class="headerlink" title="三、答题步骤"></a>三、答题步骤</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214809360.png" alt="image-20240403214809360"></p><h1 id="四、专业词汇"><a href="#四、专业词汇" class="headerlink" title="四、专业词汇"></a>四、专业词汇</h1><table><thead><tr><th>英文单词</th><th>中文含义</th><th>英文单词</th><th>中文含义</th></tr></thead><tbody><tr><td>abstract class</td><td>抽象类</td><td>abstraction</td><td>抽象</td></tr><tr><td>access modifier</td><td>存取权限</td><td>accessor methods</td><td>存取器方法</td></tr><tr><td>acceptance</td><td>验收</td><td>action</td><td>动作</td></tr><tr><td>action sequence</td><td>动作序列</td><td>action state</td><td>动作状态</td></tr><tr><td>activation</td><td>激活</td><td>active class</td><td>主动类</td></tr><tr><td>activity</td><td>活动</td><td>active object</td><td>主动对象</td></tr><tr><td>activity graph</td><td>活动图</td><td>actor</td><td>主角</td></tr><tr><td>actor class</td><td>主角类</td><td>actor-generalization</td><td>主角泛华关系</td></tr><tr><td>actual parameter</td><td>实参</td><td>aggregate class</td><td>聚合类</td></tr><tr><td>aggregation</td><td>聚合关系</td><td>analysis</td><td>分析</td></tr><tr><td>analysis class</td><td>分析类</td><td>analysis &amp; design</td><td>分析设计</td></tr><tr><td>analysis mechanism</td><td>分析机制</td><td>analysis pattern</td><td>分析模式</td></tr><tr><td>analyst</td><td>分析员</td><td>application programming interface（API）</td><td>应用程序编程接口</td></tr><tr><td>appraisal</td><td>评估</td><td>architecture baseline</td><td>架构基线</td></tr><tr><td>architecture mechanism</td><td>架构机制</td><td>architecture pattern</td><td>架构模式</td></tr><tr><td>architecture view</td><td>架构视图</td><td>artifact</td><td>工件</td></tr><tr><td>artifact guidelines</td><td>工件指南</td><td>artifact set</td><td>工件集</td></tr><tr><td>association class</td><td>关联类</td><td>association</td><td>关联关系</td></tr><tr><td>association end</td><td>关联关系端</td><td>asynchronous action</td><td>异步动作</td></tr><tr><td>asynchronous review</td><td>异步评审</td><td>attribute</td><td>属性</td></tr><tr><td>base class</td><td>基类</td><td>baseline</td><td>基线</td></tr><tr><td>Bean</td><td>可用于构建应用程序的小构件</td><td>behavior</td><td>行为</td></tr><tr><td>behavioral feature</td><td>行为特性</td><td>behavioral model aspect</td><td>模型的行为侧重面</td></tr><tr><td>beta testing</td><td>Beta 测试</td><td>binary association</td><td>二元关联关系</td></tr><tr><td>binding</td><td>绑定</td><td>boundary class</td><td>边界类</td></tr><tr><td>break point</td><td>断点</td><td>business actor</td><td>业务主角</td></tr><tr><td>business actor class</td><td>业务主角类</td><td>business creation</td><td>业务创建</td></tr><tr><td>business engineering</td><td>业务工程</td><td>business entity</td><td>业务实体</td></tr><tr><td>business improvement</td><td>业务改进</td><td>business object model</td><td>业务对象模型</td></tr><tr><td>business modeling</td><td>业务建模</td><td>business process</td><td>业务进程</td></tr><tr><td>business process engineering</td><td>业务过程工程</td><td>business reengineering</td><td>业务重建</td></tr><tr><td>business rule</td><td>业务规则</td><td>business use case</td><td>业务用例</td></tr><tr><td>business use case instance</td><td>业务用例实例</td><td>business use case model</td><td>业务用例模型</td></tr><tr><td>business use case package</td><td>业务用例包</td><td>business use case realization</td><td>业务用例实现</td></tr><tr><td>business worker</td><td>业务角色</td><td>capsule</td><td>封装体</td></tr><tr><td>cardinality</td><td>基数</td><td>causal analysis</td><td>因果分析</td></tr><tr><td>change control board（CCB）</td><td>变更控制委员会</td><td>change management</td><td>变更管理</td></tr><tr><td>change request（CR）</td><td>变更请求</td><td>checklist</td><td>检查表</td></tr><tr><td>checkpoints</td><td>检查点</td><td>class</td><td>类</td></tr><tr><td>class diagram</td><td>类图</td><td>class hierarchy</td><td>类分层结构</td></tr><tr><td>class library</td><td>类库</td><td>class method</td><td>类方法</td></tr><tr><td>classifier</td><td>分类器</td><td>client</td><td>客户端</td></tr><tr><td>client&#x2F;server</td><td>客户端&#x2F;服务器</td><td>collaboration</td><td>协作</td></tr><tr><td>collaboration diagram</td><td>协作图</td><td>comment</td><td>注释</td></tr><tr><td>commit</td><td>提交</td><td>Common Gateway Interface（CGI）</td><td>公共网关接口</td></tr><tr><td>Common Object Request Broker Architecture （CORBA）</td><td>公共对象请求代理程序体系结构</td><td>communicate-association</td><td>通信关联关系</td></tr><tr><td>communication association</td><td>通信关联关系</td><td>component</td><td>构件</td></tr><tr><td>component diagram</td><td>构件图</td><td>component model</td><td>构件模型</td></tr><tr><td>component-based development（CBD）</td><td>基于构件的开发</td><td>composite aggregation</td><td>组装关系</td></tr><tr><td>composite class</td><td>组装类</td><td>composite state</td><td>组合状态</td></tr><tr><td>composite substate</td><td>组合子状态</td><td>composition</td><td>组装</td></tr><tr><td>concrete</td><td>具体</td><td>concrete class</td><td>具体类</td></tr><tr><td>concurrency</td><td>并行</td><td>concurrent substate</td><td>并行子状态</td></tr><tr><td>configuration</td><td>配置</td><td>configuration item</td><td>配置项</td></tr><tr><td>configuration management</td><td>配置管理</td><td>constraint</td><td>约束</td></tr><tr><td>construction</td><td>构建</td><td>constructor</td><td>构建函数</td></tr><tr><td>container</td><td>容器</td><td>containment hierarchy</td><td>容器分层结构</td></tr><tr><td>context</td><td>环境</td><td>control chart</td><td>控制图</td></tr><tr><td>control class</td><td>控制类</td><td>conversational</td><td>会话式</td></tr><tr><td>critical design review（CDR）</td><td>关键设计评审</td><td>customer</td><td>客户</td></tr><tr><td>cycle</td><td>周期</td><td>database</td><td>数据库</td></tr><tr><td>database management system（DBMS）</td><td>数据库管理系统</td><td>datetype</td><td>数据类型</td></tr><tr><td>deadlock</td><td>死锁</td><td>decision rule</td><td>决策规则</td></tr><tr><td>defect</td><td>缺陷</td><td>defect checklist</td><td>缺陷检查表</td></tr><tr><td>defect density</td><td>缺陷密度</td><td>defect log</td><td>缺陷日志</td></tr><tr><td>defining model</td><td>定义模型</td><td>delegation</td><td>委托</td></tr><tr><td>deliverable</td><td>可交付工作</td><td>de-marshal</td><td>串行化</td></tr><tr><td>demilitarized zone （DMZ）</td><td>隔离带</td><td>dependency</td><td>依赖</td></tr><tr><td>deployment</td><td>部署</td><td>deployment diagram</td><td>部署图</td></tr><tr><td>deployment unit</td><td>部署单元</td><td>deployment view</td><td>部署视图</td></tr><tr><td>derived element</td><td>派生元素</td><td>deserialize</td><td>反串行化</td></tr><tr><td>design</td><td>设计</td><td>design mechanism</td><td>设计机制</td></tr><tr><td>design model</td><td>设计模型</td><td>design patter</td><td>设计模式</td></tr><tr><td>design subsystem</td><td>设计子系统</td><td>developer</td><td>开发人员</td></tr><tr><td>development case</td><td>开发案例</td><td>development process</td><td>开发过程</td></tr><tr><td>device</td><td>设备</td><td>diagram</td><td>图</td></tr><tr><td>disjoint substate</td><td>互斥子状态</td><td>distributed processing</td><td>分布式处理</td></tr><tr><td>document</td><td>文档</td><td>document description</td><td>文档说明</td></tr><tr><td>document template</td><td>文档模板</td><td>domain</td><td>域名</td></tr><tr><td>domain model</td><td>域名模型</td><td>domain name server</td><td>域名服务器</td></tr><tr><td>dynamic classification</td><td>动态分类</td><td>dynamic information</td><td>动态信息</td></tr><tr><td>e-Business</td><td>电子商务</td><td>elaboration</td><td>精化</td></tr><tr><td>element</td><td>元素</td><td>encapsulation</td><td>封装</td></tr><tr><td>enclosed document</td><td>附带文档</td><td>enhancement request</td><td>扩展请求</td></tr><tr><td>entity class</td><td>实体类</td><td>entry action</td><td>进入动作</td></tr><tr><td>error</td><td>错误</td><td>event</td><td>事件</td></tr><tr><td>event-to-methd connection</td><td>事件-方法映射</td><td>evolution</td><td>演进</td></tr><tr><td>evolutionary</td><td>演进方式</td><td>executeable architecture</td><td>可执行框架</td></tr><tr><td>exit action</td><td>退出动作</td><td>exit criteria</td><td>退出条件</td></tr><tr><td>export</td><td>导出</td><td>expression</td><td>表达式</td></tr><tr><td>extend</td><td>扩展</td><td>extend-relationship</td><td>扩展关系</td></tr><tr><td>facade</td><td>外观</td><td>factory</td><td>工厂</td></tr><tr><td>falut</td><td>故障</td><td>feature</td><td>特性</td></tr><tr><td>field</td><td>字段</td><td>file transfer protocl（FTP）</td><td>文件传输协议</td></tr><tr><td>final state</td><td>最终状态</td><td>fire</td><td>击发</td></tr><tr><td>firewall</td><td>防火墙</td><td>flatten</td><td>串行化</td></tr><tr><td>focus of control</td><td>控制焦点</td><td>follow up</td><td>跟踪</td></tr><tr><td>formal review</td><td>正式评审</td><td>formal parameter</td><td>形参</td></tr><tr><td>framework</td><td>框架</td><td>gateway</td><td>网关</td></tr><tr><td>generalizable element</td><td>可泛化元素</td><td>generalization</td><td>泛化关系</td></tr><tr><td>generation</td><td>代</td><td>graphical user interface(GUI)</td><td>图形用户界面</td></tr><tr><td>green-field development</td><td>零起点开发</td><td>guard condition</td><td>警戒条件</td></tr><tr><td>home page</td><td>主页</td><td>hyperlinks</td><td>超链接</td></tr><tr><td>hypertext</td><td>超文本</td><td>hypertext markup language（HTML）</td><td>超文本标记语言</td></tr><tr><td>idiom</td><td>代码模式</td><td>implementation</td><td>实现</td></tr><tr><td>implementation inheritance</td><td>实现继承</td><td>implementation mechanism</td><td>实现机制</td></tr><tr><td>implementation model</td><td>实现模型</td><td>implementation pattern</td><td>实现模式</td></tr><tr><td>implementation subsystem</td><td>实现子系统</td><td>implementation view</td><td>实现视图</td></tr><tr><td>import</td><td>导入</td><td>import-dependency</td><td>导入依赖关系</td></tr><tr><td>inception</td><td>先启</td><td>include</td><td>包含</td></tr><tr><td>include-releationship</td><td>包含关系</td><td>increment</td><td>增量</td></tr><tr><td>incremental</td><td>递增</td><td>informal review</td><td>非正式评审</td></tr><tr><td>inheritance</td><td>继承</td><td>injection rate</td><td>缺陷率</td></tr><tr><td>input</td><td>输入</td><td>inspection</td><td>审查</td></tr><tr><td>inspection effectiveness</td><td>审查有效性</td><td>inspection efficiency</td><td>审查效率</td></tr><tr><td>inspection package</td><td>审查包</td><td>inspection summary report</td><td>审查总结报告</td></tr><tr><td>inspector</td><td>审查者</td><td>issue</td><td>问题</td></tr><tr><td>issue log</td><td>问题日志</td><td>instance</td><td>实例</td></tr><tr><td>integrated development environment（IDE）</td><td>集成开发环境</td><td>integration</td><td>集成</td></tr><tr><td>integration build plan</td><td>集成构建计划</td><td>interaction</td><td>交互</td></tr><tr><td>interaction diagram</td><td>交互图</td><td>interface</td><td>接口</td></tr><tr><td>interface inheritance</td><td>接口继承</td><td>internal transition</td><td>内部转移</td></tr><tr><td>Internet</td><td>互联网</td><td>Internet Protocol（IP）</td><td>Internet协议</td></tr><tr><td>Intranet</td><td>内部网</td><td>iteration</td><td>迭代</td></tr><tr><td>Internet</td><td>邮件扩展</td><td>Java archive（JAR）</td><td>Java 档案文件</td></tr><tr><td>Java database connectivity（JDBC）</td><td>Java数据库连接</td><td>Java Development Kit（JDK）</td><td>Java开发工具包</td></tr><tr><td>Java foundation classes（JFC）</td><td>Java基础类</td><td>key mechanism</td><td>关键机制</td></tr><tr><td>keyword</td><td>关键字</td><td>layer</td><td>层</td></tr><tr><td>link</td><td>链接</td><td>link end</td><td>链接端</td></tr><tr><td>listener</td><td>监听程序</td><td>local area network（LAN）</td><td>局域网</td></tr><tr><td>logical view</td><td>逻辑视图</td><td>major defect</td><td>主要缺陷</td></tr><tr><td>management</td><td>管理</td><td>marshal</td><td>反串行化</td></tr><tr><td>measurement dysfunction</td><td>测量混乱</td><td>mechanism</td><td>机制</td></tr><tr><td>message</td><td>信息</td><td>messaging</td><td>消息传递</td></tr><tr><td>metaclass</td><td>元类</td><td>meta-metamodel</td><td>元-元模型</td></tr><tr><td>metamodel</td><td>元模型</td><td>metaobject</td><td>元对象</td></tr><tr><td>method</td><td>方法</td><td>method call</td><td>方法调用</td></tr><tr><td>metric</td><td>度量</td><td>milestone</td><td>里程碑</td></tr><tr><td>minor defect</td><td>次要缺陷</td><td>model aspect</td><td>模型侧重面</td></tr><tr><td>model elaboration</td><td>模型精化</td><td>model element</td><td>模型元素</td></tr><tr><td>model view controler（MVC）</td><td>模型视图控制器</td><td>modeling convention</td><td>建模约定</td></tr><tr><td>moderator</td><td>评审组长</td><td>module</td><td>模块</td></tr><tr><td>multiple classification</td><td>多重分类</td><td>multiple inheritance</td><td>多重继承</td></tr><tr><td>multiplicity</td><td>多重性</td><td>multipurpose Internet mail extension（MIME）</td><td>多目的网络邮件扩展</td></tr><tr><td>multi-valued</td><td>多值</td><td>mutator methods</td><td>存取器方法</td></tr><tr><td>n-ary association</td><td>多远关联关系</td><td>n-fold inspection</td><td>n重审查</td></tr><tr><td>namespace</td><td>名字空间</td><td>node</td><td>节点</td></tr><tr><td>object</td><td>对象</td><td>object class</td><td>对象类</td></tr><tr><td>object diagram</td><td>对象图</td><td>object flow state</td><td>对象流状态</td></tr><tr><td>object lifeline</td><td>对象生命线</td><td>object model</td><td>对象模型</td></tr><tr><td>object request broker（ORB）</td><td>对象请求代理</td><td>object-oriented programming（OOP）</td><td>面向对象程序设计</td></tr><tr><td>online transaction processing（OLTP）</td><td>联机事务处理</td><td>open database connectivity</td><td>开发数据库连接标准</td></tr><tr><td>operation</td><td>操作</td><td>operating system process</td><td>操作系统进程</td></tr><tr><td>organization unit</td><td>组织单元</td><td>originator</td><td>发起者</td></tr><tr><td>output</td><td>输出</td><td>outside link</td><td>外部链接</td></tr><tr><td>package</td><td>包</td><td>pair programming</td><td>结队编程</td></tr><tr><td>palette</td><td>调色板</td><td>parameter</td><td>参数</td></tr><tr><td>parameter connection</td><td>参数连接</td><td>parameterized element</td><td>参数化元素</td></tr><tr><td>parent</td><td>父</td><td>parent class</td><td>父类</td></tr><tr><td>participates</td><td>参与</td><td>partition</td><td>分区</td></tr><tr><td>passround</td><td>轮查</td><td>pattern</td><td>模式</td></tr><tr><td>peer deskcheck</td><td>同级桌查</td><td>peer review</td><td>同级评审</td></tr><tr><td>peer review coordinator</td><td>同级评审协调者</td><td>persistent object</td><td>永久对象</td></tr><tr><td>phase</td><td>阶段</td><td>port</td><td>端口</td></tr><tr><td>post-condition</td><td>后置条件</td><td>pre-condition</td><td>前置条件</td></tr><tr><td>preliminary design review（PDR）</td><td>初步设计评审</td><td>primitive type</td><td>基础类型</td></tr><tr><td>private</td><td>私有</td><td>process</td><td>进程，过程</td></tr><tr><td>process assets library</td><td>过程资产库</td><td>process owner</td><td>过程拥有者</td></tr><tr><td>process view</td><td>进程视图</td><td>processor</td><td>处理器</td></tr><tr><td>product</td><td>产品</td><td>product champion</td><td>产品推介人</td></tr><tr><td>product-line architecture</td><td>产品线架构</td><td>product requirements document（PRD）</td><td>产品需求文档</td></tr><tr><td>project</td><td>项目</td><td>project manager</td><td>项目经理</td></tr><tr><td>project review authority（PRA）</td><td>项目评审委员会</td><td>projection</td><td>投影</td></tr><tr><td>promotion</td><td>晋升</td><td>property</td><td>特征</td></tr><tr><td>property-to-property connection</td><td>特征-特征连接</td><td>protected</td><td>保护</td></tr><tr><td>Protocol</td><td>协议</td><td>prototype</td><td>原型</td></tr><tr><td>proxy</td><td>代理</td><td>pseudo-state</td><td>伪状态</td></tr><tr><td>published model</td><td>已发布模型</td><td>qualifier</td><td>限定词</td></tr><tr><td>quality assureance（QA）</td><td>质量保证</td><td>race condition</td><td>竞争状态</td></tr><tr><td>rank</td><td>等级</td><td>rationale</td><td>理由</td></tr><tr><td>receive a message</td><td>接收消息</td><td>receiver object</td><td>接收方对象</td></tr><tr><td>reception</td><td>接收</td><td>reference</td><td>引用</td></tr><tr><td>refinement</td><td>改进</td><td>relationship</td><td>关系</td></tr><tr><td>release</td><td>发布版</td><td>release manager</td><td>发布经理</td></tr><tr><td>remote method invocation（RMI）</td><td>远程方法调用</td><td>report</td><td>报告</td></tr><tr><td>repository</td><td>储存库</td><td>requirement</td><td>需求</td></tr><tr><td>requirement attribute</td><td>需求属性</td><td>requirements</td><td>需求</td></tr><tr><td>requirements management</td><td>需求管理</td><td>requirements tracing</td><td>需求跟踪</td></tr><tr><td>requirement type</td><td>需求类型</td><td>resource file</td><td>资源文件</td></tr><tr><td>responsibility</td><td>职责</td><td>result</td><td>结果</td></tr><tr><td>resurrect</td><td>反串行化</td><td>reuse</td><td>复用</td></tr><tr><td>review</td><td>评审</td><td>rework</td><td>返工</td></tr><tr><td>risk</td><td>风险</td><td>role</td><td>角色</td></tr><tr><td>RSA</td><td>非对称密码算法</td><td>rule</td><td>规则</td></tr><tr><td>sanbox</td><td>沙箱</td><td>scenario</td><td>场景</td></tr><tr><td>scope management</td><td>范围管理</td><td>semantic variation point</td><td>语义分歧点</td></tr><tr><td>send a message</td><td>发送消息</td><td>sender object</td><td>发送方对象</td></tr><tr><td>sequence diagram</td><td>序列图</td><td>serialize</td><td>序列化</td></tr><tr><td>server</td><td>服务器</td><td>severity</td><td>严重性</td></tr><tr><td>signal</td><td>信号</td><td>signature</td><td>签名</td></tr><tr><td>single inheritance</td><td>单重继承</td><td>single valued</td><td>单值</td></tr><tr><td>single-byte character set</td><td>单字节字符集</td><td>socket secure</td><td>套接字保护</td></tr><tr><td>software architecture</td><td>软件架构</td><td>software engineering process group（SEPG）</td><td>软件工程过程组</td></tr><tr><td>software requirement</td><td>软件需求</td><td>software requirements specification是（SRS）</td><td>软件需求规约</td></tr><tr><td>software specification review（SSR）</td><td>软件规约评审</td><td>specification</td><td>规约</td></tr><tr><td>stakeholder</td><td>涉众</td><td>stakeholder need</td><td>涉众需要</td></tr><tr><td>stakeholder request</td><td>涉众请求</td><td>start page</td><td>起始页</td></tr><tr><td>state</td><td>状态</td><td>statechart diagram</td><td>状态图</td></tr><tr><td>static artifact</td><td>静态工件</td><td>static classification</td><td>静态分类</td></tr><tr><td>static information</td><td>静态信息</td><td>stereotype</td><td>构造型</td></tr><tr><td>stimulus</td><td>激励</td><td>structural feature</td><td>结构特性</td></tr><tr><td>structural model aspect</td><td>模型的结构侧重面</td><td>stub</td><td>桩模块</td></tr><tr><td>subactivity state</td><td>子活动状态</td><td>subclass</td><td>子类</td></tr><tr><td>submachine state</td><td>子机状态</td><td>substate</td><td>子状态</td></tr><tr><td>subsystem</td><td>子系统</td><td>subtpye</td><td>子类型</td></tr><tr><td>superclass</td><td>超类</td><td>supertype</td><td>超类型</td></tr><tr><td>supplier</td><td>提供端</td><td>swimlane</td><td>泳道</td></tr><tr><td>synch state</td><td>同步状态</td><td>synchronous action</td><td>同步操作</td></tr><tr><td>system</td><td>系统</td><td>system requirements review（SRR）</td><td>系统需求评审</td></tr><tr><td>tagged value</td><td>标注值</td><td>task</td><td>任务</td></tr><tr><td>team leader</td><td>团队负责人</td><td>technical authority</td><td>技术权威</td></tr><tr><td>template</td><td>模板</td><td>test</td><td>测试</td></tr><tr><td>test case</td><td>测试用例</td><td>test coverage</td><td>测试覆盖</td></tr><tr><td>test driver</td><td>测试驱动程序</td><td>test item</td><td>测试项</td></tr><tr><td>test procedure</td><td>测试过程</td><td>thin client</td><td>瘦客户机</td></tr><tr><td>thread</td><td>线程</td><td>time event</td><td>时间事件</td></tr><tr><td>time expression</td><td>时间表达式</td><td>timing mark</td><td>时间标记</td></tr><tr><td>tool mentor</td><td>工具向导</td><td>traceability</td><td>可追踪性</td></tr><tr><td>trace</td><td>追踪</td><td>transaction</td><td>事务</td></tr><tr><td>transaction processing</td><td>事务处理</td><td>transient object</td><td>临时对象</td></tr><tr><td>transition</td><td>产品化&#x2F;转移</td><td>type</td><td>类型</td></tr><tr><td>type expression</td><td>类型表达式</td><td>typo list</td><td>微错清单</td></tr><tr><td>unicode</td><td>统一编码</td><td>unified modeling language（UML）</td><td>统一建模语言</td></tr><tr><td>uniform resource location（URL）</td><td>统一资源定位符</td><td>usage</td><td>用途</td></tr><tr><td>use case</td><td>用例</td><td>use case diagram</td><td>用例图</td></tr><tr><td>use case instance</td><td>用例实例</td><td>use case model</td><td>用例模型</td></tr><tr><td>use case package</td><td>用例包</td><td>use case realization</td><td>用例实现</td></tr><tr><td>use case view</td><td>用例视图</td><td>use interface（UI）</td><td>用户界面</td></tr><tr><td>utility</td><td>实体工具</td><td>validation</td><td>确认</td></tr><tr><td>value</td><td>值</td><td>variable</td><td>变量</td></tr><tr><td>verification</td><td>验证</td><td>version</td><td>版本</td></tr><tr><td>vertex</td><td>顶点</td><td>view</td><td>视图</td></tr><tr><td>view element</td><td>视图元素</td><td>view projection</td><td>视图投影</td></tr><tr><td>virual machine（VM）</td><td>虚拟机</td><td>visibility</td><td>可见性</td></tr><tr><td>vision</td><td>前景</td><td>visual programming tool</td><td>可视化编程工具</td></tr><tr><td>walkthrough</td><td>走查</td><td>web application</td><td>web应用程序</td></tr><tr><td>web browser</td><td>web浏览器</td><td>web server</td><td>web服务器</td></tr><tr><td>web site</td><td>web站点</td><td>web system</td><td>web系统</td></tr><tr><td>widget</td><td>窗口组件</td><td>work breakdown structure</td><td>工作细分结构</td></tr><tr><td>work guideline</td><td>工作指南</td><td>work product</td><td>工作产品</td></tr><tr><td>worker</td><td>角色</td><td>workflow</td><td>工作流程</td></tr><tr><td>workflow detail</td><td>工作流程细节</td><td>workspace</td><td>工作区</td></tr><tr><td>workstations</td><td>工作站</td><td>world wide web（www）</td><td>万维网</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第十三章 法律法规与标准化知识</title>
    <link href="/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96%E7%9F%A5%E8%AF%86/"/>
    <url>/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、知识产权"><a href="#一、知识产权" class="headerlink" title="一、知识产权"></a>一、知识产权</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403213427924.png" alt="image-20240403213427924"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403213510466.png" alt="image-20240403213510466"></p><h1 id="二、保护期限"><a href="#二、保护期限" class="headerlink" title="二、保护期限"></a>二、保护期限</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403213538697.png" alt="image-20240403213538697"></p><h1 id="三、知识产权人确定"><a href="#三、知识产权人确定" class="headerlink" title="三、知识产权人确定 *"></a>三、知识产权人确定 *</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403213847915.png" alt="image-20240403213847915"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214122466.png" alt="image-20240403214122466"></p><h1 id="四、侵权判定"><a href="#四、侵权判定" class="headerlink" title="四、侵权判定"></a>四、侵权判定</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214225771.png" alt="image-20240403214225771"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214300844.png" alt="image-20240403214300844"></p><h1 id="五、标准的分类与标准的编号"><a href="#五、标准的分类与标准的编号" class="headerlink" title="五、标准的分类与标准的编号"></a>五、标准的分类与标准的编号</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214402664.png" alt="image-20240403214402664"></p><h2 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403214425362.png" alt="image-20240403214425362"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第十二章 信息安全和多媒体基础</title>
    <link href="/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80/"/>
    <url>/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、网络安全概念"><a href="#一、网络安全概念" class="headerlink" title="一、网络安全概念"></a>一、网络安全概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205541548.png" alt="image-20240403205541548"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205555043.png" alt="image-20240403205555043"></p><h1 id="二、网络安全威胁"><a href="#二、网络安全威胁" class="headerlink" title="二、网络安全威胁"></a>二、网络安全威胁</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205613604.png" alt="image-20240403205613604"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205722371.png" alt="image-20240403205722371"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205831072.png" alt="image-20240403205831072"></p><h1 id="三、网络攻击"><a href="#三、网络攻击" class="headerlink" title="三、网络攻击"></a>三、网络攻击</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205913691.png" alt="image-20240403205913691"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205936118.png" alt="image-20240403205936118"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403210012220.png" alt="image-20240403210012220"></p><h1 id="四、防火墙技术"><a href="#四、防火墙技术" class="headerlink" title="四、防火墙技术"></a>四、防火墙技术</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403210058585.png" alt="image-20240403210058585"></p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403210208137.png" alt="image-20240403210208137" style="zoom:67%;" /><h1 id="五、加密与数字签名"><a href="#五、加密与数字签名" class="headerlink" title="五、加密与数字签名"></a>五、加密与数字签名</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403210239129.png" alt="image-20240403210239129"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403210315347.png" alt="image-20240403210315347"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403210350841.png" alt="image-20240403210350841"></p><h1 id="六、各个网络层次的安全保障"><a href="#六、各个网络层次的安全保障" class="headerlink" title="六、各个网络层次的安全保障"></a>六、各个网络层次的安全保障</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403212257336.png" alt="image-20240403212257336"></p><h1 id="七、音频相关概念"><a href="#七、音频相关概念" class="headerlink" title="七、音频相关概念"></a>七、音频相关概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403212313872.png" alt="image-20240403212313872"></p><h1 id="八、图像相关概念"><a href="#八、图像相关概念" class="headerlink" title="八、图像相关概念"></a>八、图像相关概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403212332591.png" alt="image-20240403212332591"></p><h1 id="九、多媒体种类"><a href="#九、多媒体种类" class="headerlink" title="九、多媒体种类"></a>九、多媒体种类</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403212349110.png" alt="image-20240403212349110"></p><h1 id="十、多媒体的计算问题"><a href="#十、多媒体的计算问题" class="headerlink" title="十、多媒体的计算问题"></a>十、多媒体的计算问题</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403212411261.png" alt="image-20240403212411261"></p><h2 id="例题-D-C-D"><a href="#例题-D-C-D" class="headerlink" title="例题 D C D"></a>例题 D C D</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403212507630.png" alt="image-20240403212507630"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第十一章 面向对象技术</title>
    <link href="/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/"/>
    <url>/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403194442066.png" alt="image-20240403194442066"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403194719914.png" alt="image-20240403194719914"></p><h2 id="例题-A"><a href="#例题-A" class="headerlink" title="例题 A"></a>例题 A</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403195031616.png" alt="image-20240403195031616"></p><h1 id="二、设计原则"><a href="#二、设计原则" class="headerlink" title="二、设计原则"></a>二、设计原则</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403195155285.png" alt="image-20240403195155285"></p><h1 id="三、设计模式的概念和分类"><a href="#三、设计模式的概念和分类" class="headerlink" title="三、设计模式的概念和分类"></a>三、设计模式的概念和分类</h1><p>设计模式（23种）</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403195333356.png" alt="image-20240403195333356"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403202603327.png" alt="image-20240403202603327"></p><ol><li>工厂方法</li><li>抽象工厂</li><li>构建器模式</li><li>适配器模式</li><li>装饰模式</li><li>外观模式</li><li>命令模式</li><li>中介者模式</li><li>观察者模式</li></ol><h1 id="四、创建型模式"><a href="#四、创建型模式" class="headerlink" title="四、创建型模式"></a>四、创建型模式</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403202754335.png" alt="image-20240403202754335"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403202847241.png" alt="image-20240403202847241"></p><h1 id="五、结构型模式"><a href="#五、结构型模式" class="headerlink" title="五、结构型模式"></a>五、结构型模式</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403202958343.png" alt="image-20240403202958343"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403203038197.png" alt="image-20240403203038197"></p><h1 id="六、行为型模式"><a href="#六、行为型模式" class="headerlink" title="六、行为型模式"></a>六、行为型模式</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403203149029.png" alt="image-20240403203149029"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403204608120.png" alt="image-20240403204608120"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403204715804.png" alt="image-20240403204715804"></p><h1 id="七、Java程序设计"><a href="#七、Java程序设计" class="headerlink" title="七、Java程序设计"></a>七、Java程序设计</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403204737000.png" alt="image-20240403204737000"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403204919947.png" alt="image-20240403204919947"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403204940348.png" alt="image-20240403204940348"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403204956449.png" alt="image-20240403204956449"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205034866.png" alt="image-20240403205034866"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403205104400.png" alt="image-20240403205104400"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第十章 UML建模</title>
    <link href="/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E7%AB%A0-UML%E5%BB%BA%E6%A8%A1/"/>
    <url>/cblog/2024/04/03/%E7%AC%AC%E5%8D%81%E7%AB%A0-UML%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="UML三要素"><a href="#UML三要素" class="headerlink" title="UML三要素"></a>UML三要素</h2><ol><li>UML的基本构造块</li><li>支配这些构造块如何放置在一起的规则</li><li>运用于整个语言的一些公共机制</li></ol><h2 id="UML词汇表包括三种构造块"><a href="#UML词汇表包括三种构造块" class="headerlink" title="UML词汇表包括三种构造块"></a>UML词汇表包括三种构造块</h2><p>事物、关系、图</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403181502463.png" alt="image-20240403181502463"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403181544223.png" alt="image-20240403181544223"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403183656481.png" alt="image-20240403183656481"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403184251410.png" alt="image-20240403184251410"></p><h1 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403190556422.png" alt="image-20240403190556422"></p><h2 id="考察方式"><a href="#考察方式" class="headerlink" title="考察方式"></a>考察方式</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403190651061.png" alt="image-20240403190651061"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403190857148.png" alt="image-20240403190857148"></p><h1 id="三、用例图"><a href="#三、用例图" class="headerlink" title="三、用例图"></a>三、用例图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403191007840.png" alt="image-20240403191007840"></p><h1 id="四、顺序图"><a href="#四、顺序图" class="headerlink" title="四、顺序图"></a>四、顺序图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403192235191.png" alt="image-20240403192235191"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403192340348.png" alt="image-20240403192340348"></p><h1 id="五、活动图"><a href="#五、活动图" class="headerlink" title="五、活动图"></a>五、活动图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403192511490.png" alt="image-20240403192511490"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403193246289.png" alt="image-20240403193246289"></p><h1 id="六、状态图"><a href="#六、状态图" class="headerlink" title="六、状态图"></a>六、状态图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403193307001.png" alt="image-20240403193307001"></p><h1 id="七、通信图"><a href="#七、通信图" class="headerlink" title="七、通信图"></a>七、通信图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403193507402.png" alt="image-20240403193507402"></p><h1 id="八、构件图"><a href="#八、构件图" class="headerlink" title="八、构件图"></a>八、构件图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403193555180.png" alt="image-20240403193555180"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第九章 结构化开发方法(数据流图)</title>
    <link href="/cblog/2024/04/03/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/"/>
    <url>/cblog/2024/04/03/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、系统设计基本原理"><a href="#一、系统设计基本原理" class="headerlink" title="一、系统设计基本原理"></a>一、系统设计基本原理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403171712459.png" alt="image-20240403171712459"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403172911805.png" alt="image-20240403172911805"></p><h1 id="二、系统总体结构设计"><a href="#二、系统总体结构设计" class="headerlink" title="二、系统总体结构设计"></a>二、系统总体结构设计</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403173326403.png" alt="image-20240403173326403"></p><p><strong>扇入系数 ，是指门电路允许的输入端数目</strong>。</p><p><strong>扇出系数 ，是指一个门的输出端所驱动同类型门的个数，或称负载能力。</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403173522803.png" alt="image-20240403173522803"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403173544208.png" alt="image-20240403173544208"></p><h1 id="三、数据流图"><a href="#三、数据流图" class="headerlink" title="三、数据流图"></a>三、数据流图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403173822192.png" alt="image-20240403173822192"></p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403173852385.png" alt="image-20240403173852385"></p><h2 id="数据流图——基本成分"><a href="#数据流图——基本成分" class="headerlink" title="数据流图——基本成分"></a>数据流图——基本成分</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403173926888.png" alt="image-20240403173926888"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403174139189.png" alt="image-20240403174139189"></p><h2 id="数据流图分层"><a href="#数据流图分层" class="headerlink" title="数据流图分层"></a>数据流图分层</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403174309942.png" alt="image-20240403174309942"></p><h2 id="数据流图——对图加工进行编号"><a href="#数据流图——对图加工进行编号" class="headerlink" title="数据流图——对图加工进行编号"></a>数据流图——对图加工进行编号</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403174931570.png" alt="image-20240403174931570"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403174947940.png" alt="image-20240403174947940"></p><h2 id="数据流图——注意的问题"><a href="#数据流图——注意的问题" class="headerlink" title="数据流图——注意的问题"></a>数据流图——注意的问题</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403175029246.png" alt="image-20240403175029246"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403175308897.png" alt="image-20240403175308897"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403175410300.png" alt="image-20240403175410300"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p> <img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403180154878.png" alt="image-20240403180154878"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pandas常用方法</title>
    <link href="/cblog/2024/03/26/pandas%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/cblog/2024/03/26/pandas%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Pandas-简介"><a href="#Pandas-简介" class="headerlink" title="Pandas 简介"></a>Pandas 简介</h1><p>Pandas 是一个开源的数据分析和数据处理库，它是基于 Python 编程语言的。</p><p>Pandas 提供了易于使用的数据结构和数据分析工具，特别适用于处理结构化数据，如表格型数据（类似于Excel表格）。</p><p>Pandas 是数据科学和分析领域中常用的工具之一，它使得用户能够轻松地从各种数据源中导入数据，并对数据进行高效的操作和分析。</p><p>Pandas 主要引入了两种新的数据结构：<strong>DataFrame</strong> 和 <strong>Series</strong>。</p><p><strong>Series</strong>： 类似于一维数组或列表，是由一组数据以及与之相关的数据标签（索引）构成。Series 可以看作是 DataFrame 中的一列，也可以是单独存在的一维数据结构。</p><p><strong>DataFrame</strong>： 类似于一个二维表格，它是 Pandas 中最重要的数据结构。DataFrame 可以看作是由多个 Series 按列排列构成的表格，它既有行索引也有列索引，因此可以方便地进行行列选择、过滤、合并等操作。</p><p>Pandas 提供了丰富的功能，包括：</p><ul><li>数据清洗：处理缺失数据、重复数据等。</li><li>数据转换：改变数据的形状、结构或格式。</li><li>数据分析：进行统计分析、聚合、分组等。</li><li>数据可视化：通过整合 Matplotlib 和 Seaborn 等库，可以进行数据可视化。</li></ul><h1 id="Pandas-数据结构-Series"><a href="#Pandas-数据结构-Series" class="headerlink" title="Pandas 数据结构 - Series"></a>Pandas 数据结构 - Series</h1><p>Pandas Series 类似表格中的一个列（column），类似于一维数组，可以保存任何数据类型。</p><h2 id="Series-特点："><a href="#Series-特点：" class="headerlink" title="Series 特点："></a>Series 特点：</h2><ul><li><strong>索引：</strong> 每个 <code>Series</code> 都有一个索引，它可以是整数、字符串、日期等类型。如果没有显式指定索引，Pandas 会自动创建一个默认的整数索引。</li><li><strong>数据类型：</strong> <code>Series</code> 可以容纳不同数据类型的元素，包括整数、浮点数、字符串等。</li></ul><p>Series 是 Pandas 中的一种基本数据结构，类似于一维数组或列表，但具有标签（索引），使得数据在处理和分析时更具灵活性。</p><p>以下是关于 Pandas 中的 Series 的详细介绍： 创建 Series： 可以使用 pd.Series() 构造函数创建一个 Series 对象，传递一个数据数组（可以是列表、NumPy 数组等）和一个可选的索引数组。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">pandas.Series( <span class="hljs-keyword">data</span>, <span class="hljs-built_in">index</span>, dtype, <span class="hljs-keyword">name</span>, copy)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>data</strong>：一组数据(ndarray 类型)。</li><li><strong>index</strong>：数据索引标签，如果不指定，默认从 0 开始。</li><li><strong>dtype</strong>：数据类型，默认会自己判断。</li><li><strong>name</strong>：设置名称。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul><p>创建一个简单的 Series 实例：<img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/FD659034-1715-4020-A6BF-400FAC9CE849.jpg" alt="img"></p><p>我们可以指定索引值，如下实例：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>a &#x3D; [“Google”, “Runoob”, “Wiki”]</p><p>myvar &#x3D; pd.Series(a, index &#x3D; [“x”, “y”, “z”])</p><p><strong>print</strong>(myvar)</p><p>输出结果如下：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/32B49FA4-ED68-446A-9EBF-C52FCB6D0CD6.jpg" alt="img"></p><p>我们也可以使用 key&#x2F;value 对象，类似字典来创建 Series：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>sites &#x3D; {1: “Google”, 2: “Runoob”, 3: “Wiki”}</p><p>myvar &#x3D; pd.Series(sites)</p><p><strong>print</strong>(myvar)</p><p>输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/C01F8A55-5D06-4FAD-BE34-A569A8B05E2C.jpg" alt="img"></p><p>从上图可知，字典的 key 变成了索引值。</p><p>如果我们只需要字典中的一部分数据，只需要指定需要数据的索引即可，如下实例：</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>sites &#x3D; {1: “Google”, 2: “Runoob”, 3: “Wiki”}</p><p>myvar &#x3D; pd.Series(sites, index &#x3D; [1, 2])</p><p><strong>print</strong>(myvar)</p><p>输出结果如下：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/6CC2CFBA-3CC5-459D-8FE0-D89C1EE1AEB9.jpg" alt="img"></p><p>设置 Series 名称参数：</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>sites &#x3D; {1: “Google”, 2: “Runoob”, 3: “Wiki”}</p><p>myvar &#x3D; pd.Series(sites, index &#x3D; [1, 2], name&#x3D;”RUNOOB-Series-TEST” )</p><p><strong>print</strong>(myvar)</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/1FB6D419-06D7-4229-9148-1F4E79DE6ACF.jpg" alt="img"></p><h1 id="Pandas-数据结构-DataFrame"><a href="#Pandas-数据结构-DataFrame" class="headerlink" title="Pandas 数据结构 - DataFrame"></a>Pandas 数据结构 - DataFrame</h1><p>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）。</p><p><strong>DataFrame 特点：</strong></p><ul><li><strong>列和行：</strong> <code>DataFrame</code> 由多个列组成，每一列都有一个名称，可以看作是一个 <code>Series</code>。同时，<code>DataFrame</code> 有一个行索引，用于标识每一行。</li><li><strong>二维结构：</strong> <code>DataFrame</code> 是一个二维表格，具有行和列。可以将其视为多个 <code>Series</code> 对象组成的字典。</li><li><strong>列的数据类型：</strong> 不同的列可以包含不同的数据类型，例如整数、浮点数、字符串等。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/pandas-DataStructure.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/df-dp.png" alt="img"></p><p>DataFrame 构造方法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pandas.DataFrame( data, <span class="hljs-keyword">index</span>, <span class="hljs-keyword">columns</span>, dtype, <span class="hljs-keyword">copy</span>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>data</strong>：一组数据(ndarray、series, map, lists, dict 等类型)。</li><li><strong>index</strong>：索引值，或者可以称为行标签。</li><li><strong>columns</strong>：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。</li><li><strong>dtype</strong>：数据类型。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul><p>Pandas DataFrame 是一个二维的数组结构，类似二维数组。</p><h2 id="实例-使用列表创建"><a href="#实例-使用列表创建" class="headerlink" title="实例 - 使用列表创建"></a>实例 - 使用列表创建</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; [[‘Google’, 10], [‘Runoob’, 12], [‘Wiki’, 13]]</p><p># 创建DataFrame<br>df &#x3D; pd.DataFrame(data, columns&#x3D;[‘Site’, ‘Age’])</p><p># 使用astype方法设置每列的数据类型<br>df[‘Site’] &#x3D; df[‘Site’].astype(str)<br>df[‘Age’] &#x3D; df[‘Age’].astype(float)</p><p><strong>print</strong>(df)</p><p>也可以使用字典来创建：</p><h2 id="实例-使用字典创建"><a href="#实例-使用字典创建" class="headerlink" title="实例 - 使用字典创建"></a>实例 - 使用字典创建</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; {‘Site’:[‘Google’, ‘Runoob’, ‘Wiki’], ‘Age’:[10, 12, 13]}</p><p>df &#x3D; pd.DataFrame(data)</p><p><strong>print</strong> (df)</p><p>输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/BE773E8F-DEC2-4434-8630-91E660A1DFC0.jpg" alt="img"></p><p>以下实例使用 ndarrays 创建，ndarray 的长度必须相同， 如果传递了 index，则索引的长度应等于数组的长度。如果没有传递索引，则默认情况下，索引将是range(n)，其中n是数组长度。</p><p>ndarrays 可以参考：<a href="https://www.runoob.com/numpy/numpy-ndarray-object.html">NumPy Ndarray 对象</a></p><h2 id="实例-使用-ndarrays-创建"><a href="#实例-使用-ndarrays-创建" class="headerlink" title="实例 - 使用 ndarrays 创建"></a>实例 - 使用 ndarrays 创建</h2><p><strong>import</strong> numpy <strong>as</strong> np<br><strong>import</strong> pandas <strong>as</strong> pd</p><p># 创建一个包含网站和年龄的二维ndarray<br>ndarray_data &#x3D; np.array([<br>  [‘Google’, 10],<br>  [‘Runoob’, 12],<br>  [‘Wiki’, 13]<br>])</p><p># 使用DataFrame构造函数创建数据帧<br>df &#x3D; pd.DataFrame(ndarray_data, columns&#x3D;[‘Site’, ‘Age’])</p><p># 打印数据帧<br><strong>print</strong>(df)</p><p>输出结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/BE773E8F-DEC2-4434-8630-91E660A1DFC0.jpg" alt="img"></p><p>从以上输出结果可以知道， DataFrame 数据类型一个表格，包含 rows（行） 和 columns（列）：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/rows-cloumns.png" alt="img"></p><p>还可以使用字典（key&#x2F;value），其中字典的 key 为列名:</p><h2 id="实例-使用字典创建-1"><a href="#实例-使用字典创建-1" class="headerlink" title="实例 - 使用字典创建"></a>实例 - 使用字典创建</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; [{‘a’: 1, ‘b’: 2},{‘a’: 5, ‘b’: 10, ‘c’: 20}]</p><p>df &#x3D; pd.DataFrame(data)</p><p><strong>print</strong> (df)</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">a</span>   b     c<br><span class="hljs-attribute">0</span>  <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   NaN<br><span class="hljs-attribute">1</span>  <span class="hljs-number">5</span>  <span class="hljs-number">10</span>  <span class="hljs-number">20</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>没有对应的部分数据为 <strong>NaN</strong>。</p><p>Pandas 可以使用 <strong>loc</strong> 属性返回指定行的数据，如果没有设置索引，第一行索引为 <strong>0</strong>，第二行索引为 <strong>1</strong>，以此类推：</p><h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; {<br> “calories”: [420, 380, 390],<br> “duration”: [50, 40, 45]<br>}</p><p># 数据载入到 DataFrame 对象<br>df &#x3D; pd.DataFrame(data)</p><p># 返回第一行<br><strong>print</strong>(df.loc[0])<br># 返回第二行<br><strong>print</strong>(df.loc[1])</p><p>输出结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">calories</span>    <span class="hljs-number">420</span><br><span class="hljs-attribute">duration</span>     <span class="hljs-number">50</span><br><span class="hljs-attribute">Name</span>: <span class="hljs-number">0</span>, dtype: int64<br><span class="hljs-attribute">calories</span>    <span class="hljs-number">380</span><br><span class="hljs-attribute">duration</span>     <span class="hljs-number">40</span><br><span class="hljs-attribute">Name</span>: <span class="hljs-number">1</span>, dtype: int64<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>返回结果其实就是一个 Pandas Series 数据。</p><p>也可以返回多行数据，使用 <strong>[[ … ]]</strong> 格式，**…** 为各行的索引，以逗号隔开：</p><h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; {<br> “calories”: [420, 380, 390],<br> “duration”: [50, 40, 45]<br>}</p><p># 数据载入到 DataFrame 对象<br>df &#x3D; pd.DataFrame(data)</p><p># 返回第一行和第二行<br><strong>print</strong>(df.loc[[0, 1]])</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">calories</span>  duration<br><span class="hljs-attribute">0</span>       <span class="hljs-number">420</span>        <span class="hljs-number">50</span><br><span class="hljs-attribute">1</span>       <span class="hljs-number">380</span>        <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>返回结果其实就是一个 Pandas DataFrame 数据。</p><p>我们可以指定索引值，如下实例：</p><h2 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; {<br> “calories”: [420, 380, 390],<br> “duration”: [50, 40, 45]<br>}</p><p>df &#x3D; pd.DataFrame(data, index &#x3D; [“day1”, “day2”, “day3”])</p><p><strong>print</strong>(df)</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">      <span class="hljs-attribute">calories</span>  duration<br><span class="hljs-attribute">day1</span>       <span class="hljs-number">420</span>        <span class="hljs-number">50</span><br><span class="hljs-attribute">day2</span>       <span class="hljs-number">380</span>        <span class="hljs-number">40</span><br><span class="hljs-attribute">day3</span>       <span class="hljs-number">390</span>        <span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>Pandas 可以使用 <strong>loc</strong> 属性返回指定索引对应到某一行：</p><h2 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D; {<br> “calories”: [420, 380, 390],<br> “duration”: [50, 40, 45]<br>}</p><p>df &#x3D; pd.DataFrame(data, index &#x3D; [“day1”, “day2”, “day3”])</p><p># 指定索引<br><strong>print</strong>(df.loc[“day2”])</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">calories</span>    <span class="hljs-number">380</span><br><span class="hljs-attribute">duration</span>     <span class="hljs-number">40</span><br><span class="hljs-attribute">Name</span>: day2, dtype: int64<br></code></pre></td></tr></table></figure><h1 id="Pandas-CSV-文件"><a href="#Pandas-CSV-文件" class="headerlink" title="Pandas CSV 文件"></a>Pandas CSV 文件</h1><p>CSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p><p>CSV 是一种通用的、相对简单的文件格式，被用户、商业和科学广泛应用。</p><p>Pandas 可以很方便的处理 CSV 文件，本文以 <a href="https://static.jyshare.com/download/nba.csv">nba.csv</a> 为例，你可以<a href="https://static.jyshare.com/download/nba.csv">下载 nba.csv</a> 或<a href="https://static.jyshare.com/download/nba.csv.txt">打开 nba.csv</a> 查看。</p><h2 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_csv(‘nba.csv’)</p><p><strong>print</strong>(df.to_string())</p><p><strong>to_string()</strong> 用于返回 DataFrame 类型的数据，如果不使用该函数，则输出结果为数据的前面 5 行和末尾 5 行，中间部分以 <strong>…</strong> 代替。</p><p>我们也可以使用 <strong>to_csv()</strong> 方法将 DataFrame 存储为 csv 文件：</p><h2 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p># 三个字段 name, site, age<br>nme &#x3D; [“Google”, “Runoob”, “Taobao”, “Wiki”]<br>st &#x3D; [“<a href="http://www.google.com/">www.google.com</a>“, “<a href="http://www.runoob.com/">www.runoob.com</a>“, “<a href="http://www.taobao.com/">www.taobao.com</a>“, “<a href="http://www.wikipedia.org"]">www.wikipedia.org&quot;]</a><br>ag &#x3D; [90, 40, 80, 98]</p><p># 字典<br>dict &#x3D; {‘name’: nme, ‘site’: st, ‘age’: ag}</p><p>df &#x3D; pd.DataFrame(dict)</p><p># 保存 dataframe<br>df.to_csv(‘site.csv’)</p><p>执行成功后，我们打开 site.csv 文件，显示结果如下：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/9758194A-0D8E-4C53-95A0-157C690614E6.jpg" alt="img"></p><hr><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="head"><a href="#head" class="headerlink" title="head()"></a>head()</h3><p><strong>head( *n* )</strong> 方法用于读取前面的 n 行，如果不填参数 n ，默认返回 5 行。</p><h2 id="实例-读取前面-5-行"><a href="#实例-读取前面-5-行" class="headerlink" title="实例 - 读取前面 5 行"></a>实例 - 读取前面 5 行</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_csv(‘nba.csv’)</p><p><strong>print</strong>(df.head())</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache">            <span class="hljs-attribute">Name</span>            Team  Number Position   Age Height  Weight            College     Salary<br><span class="hljs-attribute">0</span>  Avery Bradley  Boston Celtics     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">2</span>   <span class="hljs-number">180</span>.<span class="hljs-number">0</span>              Texas  <span class="hljs-number">7730337</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">1</span>    Jae Crowder  Boston Celtics    <span class="hljs-number">99</span>.<span class="hljs-number">0</span>       SF  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">6</span>   <span class="hljs-number">235</span>.<span class="hljs-number">0</span>          Marquette  <span class="hljs-number">6796117</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">2</span>   John Holland  Boston Celtics    <span class="hljs-number">30</span>.<span class="hljs-number">0</span>       SG  <span class="hljs-number">27</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">5</span>   <span class="hljs-number">205</span>.<span class="hljs-number">0</span>  Boston University        NaN<br><span class="hljs-attribute">3</span>    R.J. Hunter  Boston Celtics    <span class="hljs-number">28</span>.<span class="hljs-number">0</span>       SG  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">5</span>   <span class="hljs-number">185</span>.<span class="hljs-number">0</span>      Georgia State  <span class="hljs-number">1148640</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">4</span>  Jonas Jerebko  Boston Celtics     <span class="hljs-number">8</span>.<span class="hljs-number">0</span>       PF  <span class="hljs-number">29</span>.<span class="hljs-number">0</span>   <span class="hljs-number">6</span>-<span class="hljs-number">10</span>   <span class="hljs-number">231</span>.<span class="hljs-number">0</span>                NaN  <span class="hljs-number">5000000</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="实例-读取前面-10-行"><a href="#实例-读取前面-10-行" class="headerlink" title="实例 - 读取前面 10 行"></a>实例 - 读取前面 10 行</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_csv(‘nba.csv’)</p><p><strong>print</strong>(df.head(10))</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache">            <span class="hljs-attribute">Name</span>            Team  Number Position   Age Height  Weight            College      Salary<br><span class="hljs-attribute">0</span>  Avery Bradley  Boston Celtics     <span class="hljs-number">0</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">2</span>   <span class="hljs-number">180</span>.<span class="hljs-number">0</span>              Texas   <span class="hljs-number">7730337</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">1</span>    Jae Crowder  Boston Celtics    <span class="hljs-number">99</span>.<span class="hljs-number">0</span>       SF  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">6</span>   <span class="hljs-number">235</span>.<span class="hljs-number">0</span>          Marquette   <span class="hljs-number">6796117</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">2</span>   John Holland  Boston Celtics    <span class="hljs-number">30</span>.<span class="hljs-number">0</span>       SG  <span class="hljs-number">27</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">5</span>   <span class="hljs-number">205</span>.<span class="hljs-number">0</span>  Boston University         NaN<br><span class="hljs-attribute">3</span>    R.J. Hunter  Boston Celtics    <span class="hljs-number">28</span>.<span class="hljs-number">0</span>       SG  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">5</span>   <span class="hljs-number">185</span>.<span class="hljs-number">0</span>      Georgia State   <span class="hljs-number">1148640</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">4</span>  Jonas Jerebko  Boston Celtics     <span class="hljs-number">8</span>.<span class="hljs-number">0</span>       PF  <span class="hljs-number">29</span>.<span class="hljs-number">0</span>   <span class="hljs-number">6</span>-<span class="hljs-number">10</span>   <span class="hljs-number">231</span>.<span class="hljs-number">0</span>                NaN   <span class="hljs-number">5000000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">5</span>   Amir Johnson  Boston Celtics    <span class="hljs-number">90</span>.<span class="hljs-number">0</span>       PF  <span class="hljs-number">29</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">9</span>   <span class="hljs-number">240</span>.<span class="hljs-number">0</span>                NaN  <span class="hljs-number">12000000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">6</span>  Jordan Mickey  Boston Celtics    <span class="hljs-number">55</span>.<span class="hljs-number">0</span>       PF  <span class="hljs-number">21</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">8</span>   <span class="hljs-number">235</span>.<span class="hljs-number">0</span>                LSU   <span class="hljs-number">1170960</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">7</span>   Kelly Olynyk  Boston Celtics    <span class="hljs-number">41</span>.<span class="hljs-number">0</span>        C  <span class="hljs-number">25</span>.<span class="hljs-number">0</span>    <span class="hljs-number">7</span>-<span class="hljs-number">0</span>   <span class="hljs-number">238</span>.<span class="hljs-number">0</span>            Gonzaga   <span class="hljs-number">2165160</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">8</span>   Terry Rozier  Boston Celtics    <span class="hljs-number">12</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">2</span>   <span class="hljs-number">190</span>.<span class="hljs-number">0</span>         Louisville   <span class="hljs-number">1824360</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">9</span>   Marcus Smart  Boston Celtics    <span class="hljs-number">36</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">22</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">4</span>   <span class="hljs-number">220</span>.<span class="hljs-number">0</span>     Oklahoma State   <span class="hljs-number">3431040</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail()"></a>tail()</h3><p><strong>tail( *n* )</strong> 方法用于读取尾部的 n 行，如果不填参数 n ，默认返回 5 行，空行各个字段的值返回 <strong>NaN</strong>。</p><h2 id="实例-读取末尾-5-行"><a href="#实例-读取末尾-5-行" class="headerlink" title="实例 - 读取末尾 5 行"></a>实例 - 读取末尾 5 行</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_csv(‘nba.csv’)</p><p><strong>print</strong>(df.tail())</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache">             <span class="hljs-attribute">Name</span>       Team  Number Position   Age Height  Weight College     Salary<br><span class="hljs-attribute">453</span>  Shelvin Mack  Utah Jazz     <span class="hljs-number">8</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">3</span>   <span class="hljs-number">203</span>.<span class="hljs-number">0</span>  Butler  <span class="hljs-number">2433333</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">454</span>     Raul Neto  Utah Jazz    <span class="hljs-number">25</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">1</span>   <span class="hljs-number">179</span>.<span class="hljs-number">0</span>     NaN   <span class="hljs-number">900000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">455</span>  Tibor Pleiss  Utah Jazz    <span class="hljs-number">21</span>.<span class="hljs-number">0</span>        C  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">7</span>-<span class="hljs-number">3</span>   <span class="hljs-number">256</span>.<span class="hljs-number">0</span>     NaN  <span class="hljs-number">2900000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">456</span>   Jeff Withey  Utah Jazz    <span class="hljs-number">24</span>.<span class="hljs-number">0</span>        C  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">7</span>-<span class="hljs-number">0</span>   <span class="hljs-number">231</span>.<span class="hljs-number">0</span>  Kansas   <span class="hljs-number">947276</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">457</span>           NaN        NaN     NaN      NaN   NaN    NaN     NaN     NaN        NaN<br></code></pre></td></tr></table></figure><h2 id="实例-读取末尾-10-行"><a href="#实例-读取末尾-10-行" class="headerlink" title="实例 - 读取末尾 10 行"></a>实例 - 读取末尾 10 行</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_csv(‘nba.csv’)</p><p><strong>print</strong>(df.tail(10))</p><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache">               <span class="hljs-attribute">Name</span>       Team  Number Position   Age Height  Weight   College      Salary<br><span class="hljs-attribute">448</span>  Gordon Hayward  Utah Jazz    <span class="hljs-number">20</span>.<span class="hljs-number">0</span>       SF  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">8</span>   <span class="hljs-number">226</span>.<span class="hljs-number">0</span>    Butler  <span class="hljs-number">15409570</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">449</span>     Rodney Hood  Utah Jazz     <span class="hljs-number">5</span>.<span class="hljs-number">0</span>       SG  <span class="hljs-number">23</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">8</span>   <span class="hljs-number">206</span>.<span class="hljs-number">0</span>      Duke   <span class="hljs-number">1348440</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">450</span>      Joe Ingles  Utah Jazz     <span class="hljs-number">2</span>.<span class="hljs-number">0</span>       SF  <span class="hljs-number">28</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">8</span>   <span class="hljs-number">226</span>.<span class="hljs-number">0</span>       NaN   <span class="hljs-number">2050000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">451</span>   Chris Johnson  Utah Jazz    <span class="hljs-number">23</span>.<span class="hljs-number">0</span>       SF  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">6</span>   <span class="hljs-number">206</span>.<span class="hljs-number">0</span>    Dayton    <span class="hljs-number">981348</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">452</span>      Trey Lyles  Utah Jazz    <span class="hljs-number">41</span>.<span class="hljs-number">0</span>       PF  <span class="hljs-number">20</span>.<span class="hljs-number">0</span>   <span class="hljs-number">6</span>-<span class="hljs-number">10</span>   <span class="hljs-number">234</span>.<span class="hljs-number">0</span>  Kentucky   <span class="hljs-number">2239800</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">453</span>    Shelvin Mack  Utah Jazz     <span class="hljs-number">8</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">3</span>   <span class="hljs-number">203</span>.<span class="hljs-number">0</span>    Butler   <span class="hljs-number">2433333</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">454</span>       Raul Neto  Utah Jazz    <span class="hljs-number">25</span>.<span class="hljs-number">0</span>       PG  <span class="hljs-number">24</span>.<span class="hljs-number">0</span>    <span class="hljs-number">6</span>-<span class="hljs-number">1</span>   <span class="hljs-number">179</span>.<span class="hljs-number">0</span>       NaN    <span class="hljs-number">900000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">455</span>    Tibor Pleiss  Utah Jazz    <span class="hljs-number">21</span>.<span class="hljs-number">0</span>        C  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">7</span>-<span class="hljs-number">3</span>   <span class="hljs-number">256</span>.<span class="hljs-number">0</span>       NaN   <span class="hljs-number">2900000</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">456</span>     Jeff Withey  Utah Jazz    <span class="hljs-number">24</span>.<span class="hljs-number">0</span>        C  <span class="hljs-number">26</span>.<span class="hljs-number">0</span>    <span class="hljs-number">7</span>-<span class="hljs-number">0</span>   <span class="hljs-number">231</span>.<span class="hljs-number">0</span>    Kansas    <span class="hljs-number">947276</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">457</span>             NaN        NaN     NaN      NaN   NaN    NaN     NaN       NaN         NaN<br></code></pre></td></tr></table></figure><h3 id="info"><a href="#info" class="headerlink" title="info()"></a>info()</h3><p>info() 方法返回表格的一些基本信息：</p><h2 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_csv(‘nba.csv’)</p><p><strong>print</strong>(df.info())</p><p>输出结果为：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;<br>RangeIndex:<span class="hljs-number"> 458 </span>entries,<span class="hljs-number"> 0 </span>to<span class="hljs-number"> 457 </span>         <span class="hljs-comment"># 行数，458 行，第一行编号为 0</span><br>Data columns (total<span class="hljs-number"> 9 </span>columns):            <span class="hljs-comment"># 列数，9列</span><br> <span class="hljs-comment">#   Column    Non-Null Count  Dtype       # 各列的数据类型</span><br>---  ------    --------------  -----  <br><span class="hljs-number"> 0 </span>  Name     <span class="hljs-number"> 457 </span>non-null    object <br><span class="hljs-number"> 1 </span>  Team     <span class="hljs-number"> 457 </span>non-null    object <br><span class="hljs-number"> 2 </span>  Number   <span class="hljs-number"> 457 </span>non-null    float64<br><span class="hljs-number"> 3 </span>  Position <span class="hljs-number"> 457 </span>non-null    object <br><span class="hljs-number"> 4 </span>  Age      <span class="hljs-number"> 457 </span>non-null    float64<br><span class="hljs-number"> 5 </span>  Height   <span class="hljs-number"> 457 </span>non-null    object <br><span class="hljs-number"> 6 </span>  Weight   <span class="hljs-number"> 457 </span>non-null    float64<br><span class="hljs-number"> 7 </span>  College  <span class="hljs-number"> 373 </span>non-null    object         <span class="hljs-comment"># non-null，意思为非空的数据    </span><br><span class="hljs-number"> 8 </span>  Salary   <span class="hljs-number"> 446 </span>non-null    float64<br>dtypes: float64(4), object(5)                 <span class="hljs-comment"># 类型</span><br></code></pre></td></tr></table></figure><p>non-null 为非空数据，我们可以看到上面的信息中，总共 458 行，College 字段的空值最多。</p><h1 id="Pandas-JSON"><a href="#Pandas-JSON" class="headerlink" title="Pandas JSON"></a>Pandas JSON</h1><p>JSON（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，JavaScript 对象表示法），是存储和交换文本信息的语法，类似 XML。</p><p>JSON 比 XML 更小、更快，更易解析，更多 JSON 内容可以参考 <a href="https://www.runoob.com/json/json-tutorial.html">JSON 教程</a>。</p><p>Pandas 可以很方便的处理 JSON 数据，本文以 <a href="https://static.jyshare.com/download/sites.json">sites.json</a> 为例，内容如下：</p><h2 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h2><p>[   {   “id”: “A001”,   “name”: “菜鸟教程”,   “url”: “<a href="http://www.runoob.com/">www.runoob.com</a>“,   “likes”: 61   },   {   “id”: “A002”,   “name”: “Google”,   “url”: “<a href="http://www.google.com/">www.google.com</a>“,   “likes”: 124   },   {   “id”: “A003”,   “name”: “淘宝”,   “url”: “<a href="http://www.taobao.com/">www.taobao.com</a>“,   “likes”: 45   } ]</p><h2 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_json(‘sites.json’)</p><p><strong>print</strong>(df.to_string())</p><p><strong>to_string()</strong> 用于返回 DataFrame 类型的数据，我们也可以直接处理 JSON 字符串。</p><h2 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>data &#x3D;[<br>  {<br>   “id”: “A001”,<br>   “name”: “菜鸟教程”,<br>   “url”: “<a href="http://www.runoob.com/">www.runoob.com</a>“,<br>   “likes”: 61<br>  },<br>  {<br>   “id”: “A002”,<br>   “name”: “Google”,<br>   “url”: “<a href="http://www.google.com/">www.google.com</a>“,<br>   “likes”: 124<br>  },<br>  {<br>   “id”: “A003”,<br>   “name”: “淘宝”,<br>   “url”: “<a href="http://www.taobao.com/">www.taobao.com</a>“,<br>   “likes”: 45<br>  }<br>]<br>df &#x3D; pd.DataFrame(data)</p><p><strong>print</strong>(df)</p><p>以上实例输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">     id    name             url  likes<br><span class="hljs-number">0</span>  A001    菜鸟教程  www<span class="hljs-selector-class">.runoob</span><span class="hljs-selector-class">.com</span>     <span class="hljs-number">61</span><br><span class="hljs-number">1</span>  A002  Google  www<span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.com</span>    <span class="hljs-number">124</span><br><span class="hljs-number">2</span>  A003      淘宝  www<span class="hljs-selector-class">.taobao</span><span class="hljs-selector-class">.com</span>     <span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>JSON 对象与 Python 字典具有相同的格式，所以我们可以直接将 Python 字典转化为 DataFrame 数据：</p><h2 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p># 字典格式的 JSON<br>s &#x3D; {<br>  “col1”:{“row1”:1,”row2”:2,”row3”:3},<br>  “col2”:{“row1”:”x”,”row2”:”y”,”row3”:”z”}<br>}</p><p># 读取 JSON 转为 DataFrame<br>df &#x3D; pd.DataFrame(s)<br><strong>print</strong>(df)</p><p>以上实例输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">      <span class="hljs-attribute">col1</span> col2<br><span class="hljs-attribute">row1</span>     <span class="hljs-number">1</span>    x<br><span class="hljs-attribute">row2</span>     <span class="hljs-number">2</span>    y<br><span class="hljs-attribute">row3</span>     <span class="hljs-number">3</span>    z<br></code></pre></td></tr></table></figure><p>从 URL 中读取 JSON 数据：</p><h2 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>URL &#x3D; ‘<a href="https://static.jyshare.com/download/sites.json">https://static.jyshare.com/download/sites.json</a>‘<br>df &#x3D; pd.read_json(URL)<br><strong>print</strong>(df)</p><p>以上实例输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">     id    name             url  likes<br><span class="hljs-number">0</span>  A001    菜鸟教程  www<span class="hljs-selector-class">.runoob</span><span class="hljs-selector-class">.com</span>     <span class="hljs-number">61</span><br><span class="hljs-number">1</span>  A002  Google  www<span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.com</span>    <span class="hljs-number">124</span><br><span class="hljs-number">2</span>  A003      淘宝  www<span class="hljs-selector-class">.taobao</span><span class="hljs-selector-class">.com</span>     <span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><h3 id="内嵌的-JSON-数据"><a href="#内嵌的-JSON-数据" class="headerlink" title="内嵌的 JSON 数据"></a>内嵌的 JSON 数据</h3><p>假设有一组内嵌的 JSON 数据文件 <strong>nested_list.json</strong> ：</p><h2 id="nested-list-json-文件内容"><a href="#nested-list-json-文件内容" class="headerlink" title="nested_list.json 文件内容"></a>nested_list.json 文件内容</h2><p>{<br>  “school_name”: “ABC primary school”,<br>  “class”: “Year 1”,<br>  “students”: [<br>  {<br>    “id”: “A001”,<br>    “name”: “Tom”,<br>    “math”: 60,<br>    “physics”: 66,<br>    “chemistry”: 61<br>  },<br>  {<br>    “id”: “A002”,<br>    “name”: “James”,<br>    “math”: 89,<br>    “physics”: 76,<br>    “chemistry”: 51<br>  },<br>  {<br>    “id”: “A003”,<br>    “name”: “Jenny”,<br>    “math”: 79,<br>    “physics”: 90,<br>    “chemistry”: 78<br>  }]<br>}</p><p>使用以下代码格式化完整内容：</p><h2 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd</p><p>df &#x3D; pd.read_json(‘nested_list.json’)</p><p><strong>print</strong>(df)</p><p>以上实例输出结果为：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">          school_name   <span class="hljs-keyword">class</span>                                           students<br><span class="hljs-number">0</span>  <span class="hljs-type">ABC</span> primary school  <span class="hljs-type">Year</span> <span class="hljs-number">1</span>  &#123;<span class="hljs-symbol">&#x27;id&#x27;</span>: <span class="hljs-symbol">&#x27;A001&#x27;</span>, <span class="hljs-symbol">&#x27;name&#x27;</span>: <span class="hljs-symbol">&#x27;Tom&#x27;</span>, <span class="hljs-symbol">&#x27;math&#x27;</span>: <span class="hljs-number">60</span>, <span class="hljs-symbol">&#x27;phy</span>...<br><span class="hljs-number">1</span>  <span class="hljs-type">ABC</span> primary school  <span class="hljs-type">Year</span> <span class="hljs-number">1</span>  &#123;<span class="hljs-symbol">&#x27;id&#x27;</span>: <span class="hljs-symbol">&#x27;A002&#x27;</span>, <span class="hljs-symbol">&#x27;name&#x27;</span>: <span class="hljs-symbol">&#x27;James&#x27;</span>, <span class="hljs-symbol">&#x27;math&#x27;</span>: <span class="hljs-number">89</span>, <span class="hljs-symbol">&#x27;p</span>...<br><span class="hljs-number">2</span>  <span class="hljs-type">ABC</span> primary school  <span class="hljs-type">Year</span> <span class="hljs-number">1</span>  &#123;<span class="hljs-symbol">&#x27;id&#x27;</span>: <span class="hljs-symbol">&#x27;A003&#x27;</span>, <span class="hljs-symbol">&#x27;name&#x27;</span>: <span class="hljs-symbol">&#x27;Jenny&#x27;</span>, <span class="hljs-symbol">&#x27;math&#x27;</span>: <span class="hljs-number">79</span>, <span class="hljs-symbol">&#x27;p</span>...<br></code></pre></td></tr></table></figure><p>这时我们就需要使用到 <strong>json_normalize()</strong> 方法将内嵌的数据完整的解析出来：</p><h2 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd<br><strong>import</strong> json</p><p># 使用 Python JSON 模块载入数据<br><strong>with</strong> open(‘nested_list.json’,’r’) <strong>as</strong> f:<br>  data &#x3D; json.loads(f.read())</p><p># 展平数据<br>df_nested_list &#x3D; pd.json_normalize(data, record_path &#x3D;[‘students’])<br><strong>print</strong>(df_nested_list)</p><p>以上实例输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">     <span class="hljs-attribute">id</span>   name  math  physics  chemistry<br><span class="hljs-attribute">0</span>  A001    Tom    <span class="hljs-number">60</span>       <span class="hljs-number">66</span>         <span class="hljs-number">61</span><br><span class="hljs-attribute">1</span>  A002  James    <span class="hljs-number">89</span>       <span class="hljs-number">76</span>         <span class="hljs-number">51</span><br><span class="hljs-attribute">2</span>  A003  Jenny    <span class="hljs-number">79</span>       <span class="hljs-number">90</span>         <span class="hljs-number">78</span><br></code></pre></td></tr></table></figure><p><strong>data &#x3D; json.loads(f.read())</strong> 使用 Python JSON 模块载入数据。</p><p><strong>json_normalize()</strong> 使用了参数 <strong>record_path</strong> 并设置为 <strong>[‘students’]</strong> 用于展开内嵌的 JSON 数据 <strong>students</strong>。</p><p>显示结果还没有包含 school_name 和 class 元素，如果需要展示出来可以使用 meta 参数来显示这些元数据：</p><h2 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd<br><strong>import</strong> json</p><p># 使用 Python JSON 模块载入数据<br><strong>with</strong> open(‘nested_list.json’,’r’) <strong>as</strong> f:<br>  data &#x3D; json.loads(f.read())</p><p># 展平数据<br>df_nested_list &#x3D; pd.json_normalize(<br>  data,<br>  record_path &#x3D;[‘students’],<br>  meta&#x3D;[‘school_name’, ‘class’]<br>)<br><strong>print</strong>(df_nested_list)</p><p>以上实例输出结果为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">     id   name  math  physics  chemistry         school_name   <span class="hljs-keyword">class</span><br><span class="hljs-symbol">0</span>  <span class="hljs-symbol">A001</span>    <span class="hljs-symbol">Tom</span>    <span class="hljs-symbol">60</span>       <span class="hljs-symbol">66</span>         <span class="hljs-symbol">61</span>  <span class="hljs-symbol">ABC</span> <span class="hljs-symbol">primary</span> <span class="hljs-symbol">school</span>  <span class="hljs-symbol">Year</span> <span class="hljs-symbol">1</span><br><span class="hljs-symbol">1</span>  <span class="hljs-symbol">A002</span>  <span class="hljs-symbol">James</span>    <span class="hljs-symbol">89</span>       <span class="hljs-symbol">76</span>         <span class="hljs-symbol">51</span>  <span class="hljs-symbol">ABC</span> <span class="hljs-symbol">primary</span> <span class="hljs-symbol">school</span>  <span class="hljs-symbol">Year</span> <span class="hljs-symbol">1</span><br><span class="hljs-symbol">2</span>  <span class="hljs-symbol">A003</span>  <span class="hljs-symbol">Jenny</span>    <span class="hljs-symbol">79</span>       <span class="hljs-symbol">90</span>         <span class="hljs-symbol">78</span>  <span class="hljs-symbol">ABC</span> <span class="hljs-symbol">primary</span> <span class="hljs-symbol">school</span>  <span class="hljs-symbol">Year</span> <span class="hljs-symbol">1</span><br></code></pre></td></tr></table></figure><p>接下来，让我们尝试读取更复杂的 JSON 数据，该数据嵌套了列表和字典，数据文件 <strong>nested_mix.json</strong> 如下：</p><h2 id="nested-mix-json-文件内容"><a href="#nested-mix-json-文件内容" class="headerlink" title="nested_mix.json 文件内容"></a>nested_mix.json 文件内容</h2><p>{<br>  “school_name”: “local primary school”,<br>  “class”: “Year 1”,<br>  “info”: {<br>   “president”: “John Kasich”,<br>   “address”: “ABC road, London, UK”,<br>   “contacts”: {<br>    “email”: “<a href="mailto:&#x61;&#100;&#x6d;&#x69;&#x6e;&#64;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#100;&#x6d;&#x69;&#x6e;&#64;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a>“,<br>    “tel”: “123456789”<br>   }<br>  },<br>  “students”: [<br>  {<br>    “id”: “A001”,<br>    “name”: “Tom”,<br>    “math”: 60,<br>    “physics”: 66,<br>    “chemistry”: 61<br>  },<br>  {<br>    “id”: “A002”,<br>    “name”: “James”,<br>    “math”: 89,<br>    “physics”: 76,<br>    “chemistry”: 51<br>  },<br>  {<br>    “id”: “A003”,<br>    “name”: “Jenny”,<br>    “math”: 79,<br>    “physics”: 90,<br>    “chemistry”: 78<br>  }]<br>}</p><p>nested_mix.json 文件转换为 DataFrame：</p><h2 id="实例-19"><a href="#实例-19" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd<br><strong>import</strong> json</p><p># 使用 Python JSON 模块载入数据<br><strong>with</strong> open(‘nested_mix.json’,’r’) <strong>as</strong> f:<br>  data &#x3D; json.loads(f.read())</p><p>df &#x3D; pd.json_normalize(<br>  data,<br>  record_path &#x3D;[‘students’],<br>  meta&#x3D;[<br>    ‘class’,<br>    [‘info’, ‘president’],<br>    [‘info’, ‘contacts’, ‘tel’]<br>  ]<br>)</p><p><strong>print</strong>(df)</p><p>以上实例输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">     <span class="hljs-attribute">id</span>   name  math  physics  chemistry   class info.president info.contacts.tel<br><span class="hljs-attribute">0</span>  A001    Tom    <span class="hljs-number">60</span>       <span class="hljs-number">66</span>         <span class="hljs-number">61</span>  Year <span class="hljs-number">1</span>    John Kasich         <span class="hljs-number">123456789</span><br><span class="hljs-attribute">1</span>  A002  James    <span class="hljs-number">89</span>       <span class="hljs-number">76</span>         <span class="hljs-number">51</span>  Year <span class="hljs-number">1</span>    John Kasich         <span class="hljs-number">123456789</span><br><span class="hljs-attribute">2</span>  A003  Jenny    <span class="hljs-number">79</span>       <span class="hljs-number">90</span>         <span class="hljs-number">78</span>  Year <span class="hljs-number">1</span>    John Kasich         <span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><h3 id="读取内嵌数据中的一组数据"><a href="#读取内嵌数据中的一组数据" class="headerlink" title="读取内嵌数据中的一组数据"></a>读取内嵌数据中的一组数据</h3><p>以下是实例文件 <strong>nested_deep.json</strong>，我们只读取内嵌中的 <strong>math</strong> 字段：</p><h2 id="nested-deep-json-文件内容"><a href="#nested-deep-json-文件内容" class="headerlink" title="nested_deep.json 文件内容"></a>nested_deep.json 文件内容</h2><p>{<br>  “school_name”: “local primary school”,<br>  “class”: “Year 1”,<br>  “students”: [<br>  {<br>    “id”: “A001”,<br>    “name”: “Tom”,<br>    “grade”: {<br>      “math”: 60,<br>      “physics”: 66,<br>      “chemistry”: 61<br>    }</p><p>  },<br>  {<br>    “id”: “A002”,<br>    “name”: “James”,<br>    “grade”: {<br>      “math”: 89,<br>      “physics”: 76,<br>      “chemistry”: 51<br>    }</p><p>  },<br>  {<br>    “id”: “A003”,<br>    “name”: “Jenny”,<br>    “grade”: {<br>      “math”: 79,<br>      “physics”: 90,<br>      “chemistry”: 78<br>    }<br>  }]<br>}</p><p>这里我们需要使用到 <strong>glom</strong> 模块来处理数据套嵌，<strong>glom</strong> 模块允许我们使用 <strong>.</strong> 来访问内嵌对象的属性。</p><p>第一次使用我们需要安装 glom：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> glom<br></code></pre></td></tr></table></figure><h2 id="实例-20"><a href="#实例-20" class="headerlink" title="实例"></a>实例</h2><p><strong>import</strong> pandas <strong>as</strong> pd<br><strong>from</strong> glom <strong>import</strong> glom</p><p>df &#x3D; pd.read_json(‘nested_deep.json’)</p><p>data &#x3D; df[‘students’].apply(<strong>lambda</strong> row: glom(row, ‘grade.math’))<br><strong>print</strong>(data)</p><p>以上实例输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>    <span class="hljs-number">60</span><br><span class="hljs-attribute">1</span>    <span class="hljs-number">89</span><br><span class="hljs-attribute">2</span>    <span class="hljs-number">79</span><br><span class="hljs-attribute">Name</span>: students, dtype: int64<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sklearn使用方法</title>
    <link href="/cblog/2024/03/26/sklearn%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/cblog/2024/03/26/sklearn%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="sklearn核心概念与快速使用方法"><a href="#sklearn核心概念与快速使用方法" class="headerlink" title="sklearn核心概念与快速使用方法"></a>sklearn核心概念与快速使用方法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194453948.png" alt="image-20240326194453948"></p><h1 id="sklearn核心对象类型：评估器"><a href="#sklearn核心对象类型：评估器" class="headerlink" title="sklearn核心对象类型：评估器"></a>sklearn核心对象类型：评估器</h1><p>评估器：一个一个的机器学习模型</p><h2 id="导入评估器的三种方法"><a href="#导入评估器的三种方法" class="headerlink" title="导入评估器的三种方法"></a>导入评估器的三种方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194644149.png" alt="image-20240326194644149"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194718651.png" alt="image-20240326194718651"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194738512.png" alt="image-20240326194738512"></p><p>默认使用第三种方法</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194822775.png" alt="image-20240326194822775"></p><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>model.fit(X,y)</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194942938.png" alt="image-20240326194942938"></p><h2 id="查看模型自变量参数"><a href="#查看模型自变量参数" class="headerlink" title="查看模型自变量参数"></a>查看模型自变量参数</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">model</span>.coef_<br></code></pre></td></tr></table></figure><h2 id="查看模型截距"><a href="#查看模型截距" class="headerlink" title="查看模型截距"></a>查看模型截距</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">model.<span class="hljs-built_in">int</span>ercept_<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326195827595.png" alt="image-20240326195827595"></p><h2 id="sklearn中的实用函数"><a href="#sklearn中的实用函数" class="headerlink" title="sklearn中的实用函数"></a>sklearn中的实用函数</h2><h3 id="计算MSE"><a href="#计算MSE" class="headerlink" title="计算MSE"></a>计算MSE</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326195926839.png" alt="image-20240326195926839"></p><h3 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326200148202.png" alt="image-20240326200148202"></p><h1 id="sklearn六大功能模块"><a href="#sklearn六大功能模块" class="headerlink" title="sklearn六大功能模块"></a>sklearn六大功能模块</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326200801103.png" alt="image-20240326200801103"></p><h3 id="classfication"><a href="#classfication" class="headerlink" title="classfication"></a>classfication</h3><h3 id="regression"><a href="#regression" class="headerlink" title="regression"></a>regression</h3><h3 id="clustering"><a href="#clustering" class="headerlink" title="clustering"></a>clustering</h3><h3 id="dimensionality-reduction"><a href="#dimensionality-reduction" class="headerlink" title="dimensionality reduction"></a>dimensionality reduction</h3><h3 id="model-selection"><a href="#model-selection" class="headerlink" title="model selection"></a>model selection</h3><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><h1 id="sklearn数据集读取"><a href="#sklearn数据集读取" class="headerlink" title="sklearn数据集读取"></a>sklearn数据集读取</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326201145599.png" alt="image-20240326201145599"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326201202885.png" alt="image-20240326201202885"></p><h1 id="sklearn数据标准化"><a href="#sklearn数据标准化" class="headerlink" title="sklearn数据标准化"></a>sklearn数据标准化</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326202859006.png" alt="image-20240326202859006"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326205600713.png" alt="image-20240326205600713"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326205700303.png" alt="image-20240326205700303"></p><h1 id="sklearn数据归一化"><a href="#sklearn数据归一化" class="headerlink" title="sklearn数据归一化"></a>sklearn数据归一化</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326205759368.png" alt="image-20240326205759368"></p>]]></content>
    
    
    
    <tags>
      
      <tag>sklearn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch的常见使用</title>
    <link href="/cblog/2024/03/26/pytorch%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8/"/>
    <url>/cblog/2024/03/26/pytorch%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326192546417.png" alt="image-20240326192546417"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326192834143.png" alt="image-20240326192834143"></p><h1 id="3-搭建模型"><a href="#3-搭建模型" class="headerlink" title="3 搭建模型"></a>3 搭建模型</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326193532035.png" alt="image-20240326193532035"></p><h1 id="4-读取数据"><a href="#4-读取数据" class="headerlink" title="4 读取数据"></a>4 读取数据</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326193912422.png" alt="image-20240326193912422"></p><h1 id="5-跑模型"><a href="#5-跑模型" class="headerlink" title="5 跑模型"></a>5 跑模型</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240326194036030.png" alt="image-20240326194036030"></p>]]></content>
    
    
    <categories>
      
      <category>pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习调参</title>
    <link href="/cblog/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B0%83%E5%8F%82/"/>
    <url>/cblog/2024/03/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B0%83%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习调参技巧"><a href="#深度学习调参技巧" class="headerlink" title="深度学习调参技巧"></a>深度学习调参技巧</h1>]]></content>
    
    
    
    <tags>
      
      <tag>deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八章 软件工程基础知识</title>
    <link href="/cblog/2024/03/25/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/cblog/2024/03/25/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、软件工程概述"><a href="#一、软件工程概述" class="headerlink" title="一、软件工程概述"></a>一、软件工程概述</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402112520580.png" alt="image-20240402112520580"></p><h2 id="软件工程概述——CMM"><a href="#软件工程概述——CMM" class="headerlink" title="软件工程概述——CMM"></a>软件工程概述——CMM</h2><ol><li>初始级</li><li>可重复级</li><li>已定义级</li><li>已管理级</li><li>优化级</li></ol><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402112635056.png" alt="image-20240402112635056"></p><h2 id="软件工程概述——CMMI：能力成熟度模型"><a href="#软件工程概述——CMMI：能力成熟度模型" class="headerlink" title="软件工程概述——CMMI：能力成熟度模型"></a>软件工程概述——CMMI：能力成熟度模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402112920545.png" alt="image-20240402112920545"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402113204258.png" alt="image-20240402113204258"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402113220133.png" alt="image-20240402113220133"></p><h2 id="软件工程概述——统一过程模型"><a href="#软件工程概述——统一过程模型" class="headerlink" title="软件工程概述——统一过程模型"></a>软件工程概述——统一过程模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402113335759.png" alt="image-20240402113335759"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402145605057.png" alt="image-20240402145605057"></p><h1 id="二、软件开发模型"><a href="#二、软件开发模型" class="headerlink" title="二、软件开发模型"></a>二、软件开发模型</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402145625261.png" alt="image-20240402145625261"></p><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402155712392.png" alt="image-20240402155712392"></p><h2 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402155921370.png" alt="image-20240402155921370"></p><h2 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402160015453.png" alt="image-20240402160015453"></p><h2 id="瀑布模型-1"><a href="#瀑布模型-1" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><h2 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402160145720.png" alt="image-20240402160145720"></p><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240402165642012.png" alt="image-20240402165642012"></p><h2 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403161415815.png" alt="image-20240403161415815"></p><h2 id="基于构建的开发模型"><a href="#基于构建的开发模型" class="headerlink" title="基于构建的开发模型"></a>基于构建的开发模型</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403161723318.png" alt="image-20240403161723318"></p><h1 id="三、软件开发方法"><a href="#三、软件开发方法" class="headerlink" title="三、软件开发方法"></a>三、软件开发方法</h1><h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403163150436.png" alt="image-20240403163150436"></p><h2 id="Jackson方法"><a href="#Jackson方法" class="headerlink" title="Jackson方法"></a>Jackson方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403163317775.png" alt="image-20240403163317775"></p><h2 id="原型化方法"><a href="#原型化方法" class="headerlink" title="原型化方法"></a>原型化方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403163400108.png" alt="image-20240403163400108"></p><h2 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403163503896.png" alt="image-20240403163503896"></p><h2 id="敏捷开发方法"><a href="#敏捷开发方法" class="headerlink" title="敏捷开发方法"></a>敏捷开发方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403163615564.png" alt="image-20240403163615564"></p><h3 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403163717905.png" alt="image-20240403163717905"></p><h1 id="四、需求分析"><a href="#四、需求分析" class="headerlink" title="四、需求分析"></a>四、需求分析</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403164013569.png" alt="image-20240403164013569"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403164029243.png" alt="image-20240403164029243"></p><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403164056014.png" alt="image-20240403164056014"></p><h1 id="五、系统设计"><a href="#五、系统设计" class="headerlink" title="五、系统设计"></a>五、系统设计</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403164121112.png" alt="image-20240403164121112"></p><h2 id="内聚和耦合"><a href="#内聚和耦合" class="headerlink" title="内聚和耦合"></a>内聚和耦合</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403164847857.png" alt="image-20240403164847857"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403164950219.png" alt="image-20240403164950219"></p><h1 id="六、系统测试"><a href="#六、系统测试" class="headerlink" title="六、系统测试"></a>六、系统测试</h1><h2 id="原则和目的"><a href="#原则和目的" class="headerlink" title="原则和目的"></a>原则和目的</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403165207295.png" alt="image-20240403165207295"></p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403165243100.png" alt="image-20240403165243100"></p><h3 id="黑盒测试和白盒测试"><a href="#黑盒测试和白盒测试" class="headerlink" title="黑盒测试和白盒测试"></a>黑盒测试和白盒测试</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403165311942.png" alt="image-20240403165311942"></p><h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403165458133.png" alt="image-20240403165458133"></p><h1 id="七、软件开发项目管理"><a href="#七、软件开发项目管理" class="headerlink" title="七、软件开发项目管理"></a>七、软件开发项目管理</h1><h2 id="Gannt图"><a href="#Gannt图" class="headerlink" title="Gannt图"></a>Gannt图</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170031395.png" alt="image-20240403170031395"></p><p>不能反应任务之间的并发</p><h2 id="PERT图"><a href="#PERT图" class="headerlink" title="PERT图"></a>PERT图</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170152442.png" alt="image-20240403170152442"></p><p>不能反映任务之间的并行</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p> <img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170631163.png" alt="image-20240403170631163"></p><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170658553.png" alt="image-20240403170658553"></p><h1 id="八、软件质量"><a href="#八、软件质量" class="headerlink" title="八、软件质量"></a>八、软件质量</h1><h2 id="软件质量特性"><a href="#软件质量特性" class="headerlink" title="软件质量特性"></a>软件质量特性</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170732669.png" alt="image-20240403170732669"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170845029.png" alt="image-20240403170845029"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170925088.png" alt="image-20240403170925088"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403170956812.png" alt="image-20240403170956812"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403171010456.png" alt="image-20240403171010456"></p><h1 id="九、软件度量"><a href="#九、软件度量" class="headerlink" title="九、软件度量"></a>九、软件度量</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240403171036308.png" alt="image-20240403171036308"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第七章 程序设计语言基础知识</title>
    <link href="/cblog/2024/03/25/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/cblog/2024/03/25/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一-、基本概念"><a href="#一-、基本概念" class="headerlink" title="一 、基本概念"></a>一 、基本概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325110918398.png" alt="image-20240325110918398"></p><h2 id="程序设计语言分类"><a href="#程序设计语言分类" class="headerlink" title="程序设计语言分类"></a>程序设计语言分类</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325114223743.png" alt="image-20240325114223743"></p><h2 id="程序语言的基本成分"><a href="#程序语言的基本成分" class="headerlink" title="程序语言的基本成分"></a>程序语言的基本成分</h2><p>1、数据成分</p><p>2、运算成分</p><p>3、控制成分</p><p>4、函数和函数调用</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325152105475.png" alt="image-20240325152105475"></p><h1 id="二、编译与解释"><a href="#二、编译与解释" class="headerlink" title="二、编译与解释"></a>二、编译与解释</h1><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>汇编语言是一种面向机器的程序设计语言，与机器硬件密切相关，具有自己独特的编程优势和专门的应用领域。</p><h3 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h3><ul><li><strong>指令语句：</strong>包含在指令集中，每一个语句汇编后产生一组二进制数目标代码，可被CPU执行。</li><li><strong>伪指令语句：</strong>汇编后不产生目标代码，用于定义段、子程序、常量、变量，以及给变量分配存储单元。</li><li><strong>宏指令语句：</strong>用户定义的一个指令序列集合， 汇编后在引用的地方展开成相应的指令序列。用于提高编程效率</li></ul><h2 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325152432975.png" alt="image-20240325152432975"></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325152718409.png" alt="image-20240325152718409"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325152842395.png" alt="image-20240325152842395"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325153246967.png" alt="image-20240325153246967"></p><h3 id="编译六个阶段"><a href="#编译六个阶段" class="headerlink" title="编译六个阶段"></a>编译六个阶段</h3><ol><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>中间代码生成</li><li>代码优化</li><li>目标代码生成</li></ol><h2 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325152500581.png" alt="image-20240325152500581"></p><h1 id="三、文法"><a href="#三、文法" class="headerlink" title="三、文法"></a>三、文法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325153533604.png" alt="image-20240325153533604"></p><p>记一下</p><h2 id="文法——语法推导树"><a href="#文法——语法推导树" class="headerlink" title="文法——语法推导树"></a>文法——语法推导树</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325154119515.png" alt="image-20240325154119515"></p><h1 id="四、有限自动机"><a href="#四、有限自动机" class="headerlink" title="四、有限自动机"></a>四、有限自动机</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325154323662.png" alt="image-20240325154323361"></p><h2 id="例题：C"><a href="#例题：C" class="headerlink" title="例题：C"></a>例题：C</h2><p><strong>注：注意初态和终态</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325155317663.png" alt="image-20240325155317663"></p><h1 id="五、正规式"><a href="#五、正规式" class="headerlink" title="五、正规式"></a>五、正规式</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325154343650.png" alt="image-20240325154343650"></p><h2 id="例题D，C"><a href="#例题D，C" class="headerlink" title="例题D，C"></a>例题D，C</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325155047303.png" alt="image-20240325155047303"></p><h1 id="六、表达式"><a href="#六、表达式" class="headerlink" title="六、表达式"></a>六、表达式</h1><p> <img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325155528304.png" alt="image-20240325155528304"></p><h2 id="例题：D"><a href="#例题：D" class="headerlink" title="例题：D"></a>例题：D</h2><h1 id="七、传值与引用"><a href="#七、传值与引用" class="headerlink" title="七、传值与引用"></a>七、传值与引用</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325160316875.png" alt="image-20240325160316875"></p><h2 id="例题：D-1"><a href="#例题：D-1" class="headerlink" title="例题：D"></a>例题：D</h2><p> <img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325160540383.png" alt="image-20240325160540383"></p><h1 id="八、各种程序语言特点"><a href="#八、各种程序语言特点" class="headerlink" title="八、各种程序语言特点"></a>八、各种程序语言特点</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325160607634.png" alt="image-20240325160607634"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VAE</title>
    <link href="/cblog/2024/03/21/VAE/"/>
    <url>/cblog/2024/03/21/VAE/</url>
    
    <content type="html"><![CDATA[<h1 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240325212720365.png" alt="image-20240325212720365"></p><p>VAE对编码后的向量，加了随机性。</p><h2 id="自编码器存在的问题："><a href="#自编码器存在的问题：" class="headerlink" title="自编码器存在的问题："></a>自编码器存在的问题：</h2><ul><li>相似的x(1)和x(2)可能被编码成差异性很大的z(1)和z(2)。</li></ul><h2 id="VAE变分编码器"><a href="#VAE变分编码器" class="headerlink" title="VAE变分编码器:"></a>VAE变分编码器:</h2><ul><li>相似的x(1)和x(2)可能被编码成很接近的z(1)和z(2)。</li><li>相似的z1和z2可以被解码成相似的x1和x2。</li></ul>]]></content>
    
    
    <categories>
      
      <category>解纠缠</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解纠缠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Applications of deep learning to reduce the need for iodinated contrast media for CT</title>
    <link href="/cblog/2024/03/20/Applications-of-deep-learning-to-reduce-the-need-for-iodinated-contrast-media-for-CT/"/>
    <url>/cblog/2024/03/20/Applications-of-deep-learning-to-reduce-the-need-for-iodinated-contrast-media-for-CT/</url>
    
    <content type="html"><![CDATA[<h1 id="Applications-of-deep-learning-to-reduce-the-need-for-iodinated-contrast-media-for-CT-imaging-a-systematic-review"><a href="#Applications-of-deep-learning-to-reduce-the-need-for-iodinated-contrast-media-for-CT-imaging-a-systematic-review" class="headerlink" title="Applications of deep learning to reduce the need for iodinated contrast media for CT imaging: a systematic review"></a>Applications of deep learning to reduce the need for iodinated contrast media for CT imaging: a systematic review</h1><h1 id="深度学习在减少-CT-成像中对碘造影剂需求的应用：系统评价"><a href="#深度学习在减少-CT-成像中对碘造影剂需求的应用：系统评价" class="headerlink" title="深度学习在减少 CT 成像中对碘造影剂需求的应用：系统评价"></a>深度学习在减少 CT 成像中对碘造影剂需求的应用：系统评价</h1><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>ICM 给药的不良反应可能包括肾损伤、危及生命的过敏样反应和环境污染。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>检索发现18篇文献  从2016到2022</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>18篇论文符合分析的纳入标准。其中，10 例从真正的非增强 CT 中产生了合成全剂量 （100%） ICM，而 4 例从低剂量到全剂量的 ICM CT 增强了。三篇论文使用DL从真实的100%ICM CT创建合成的非增强CT，而一篇论文使用DL将100%ICM转换为非增强CT。</p><p>通用网络：生成对抗网络</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403202051069.png" alt="image-20240320205153920"></p><ol><li>第一行：100次三期肺部CT扫描，共37290张图像，均为成年女性，包括非造影、动脉和静脉期。</li><li>第二行：50例成人患者，胸部60层非增强和60层增强CT血管造影。</li><li>第三行：266例成人急性腹痛患者动脉晚期及门静脉早期CT扫描。</li><li>第四行：将非配对对比增强CT扫描转换为非对比CT扫描或相反的新方法。</li><li>第五行：基于多对抗学习的血管造影重建（MALAR）框架，以增强血管强度</li></ol><p>一到三行是三个公开可用的配对增强CT和非增强CT数据集。</p><p>四五行是目前公开的源代码。</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>平扫CT合成增强CT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章 数据库系统基础知识</title>
    <link href="/cblog/2024/03/18/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/cblog/2024/03/18/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181954729.png" alt="image-20240318195443468"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403190936516.png" alt="image-20240319093604432"></p><h1 id="基本概念——DBMS的特征与分类"><a href="#基本概念——DBMS的特征与分类" class="headerlink" title="基本概念——DBMS的特征与分类"></a>基本概念——DBMS的特征与分类</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403190938484.png" alt="image-20240319093835529"></p><h1 id="数据库三级模式两级映像"><a href="#数据库三级模式两级映像" class="headerlink" title="数据库三级模式两级映像"></a>数据库三级模式两级映像</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403190949147.png" alt="image-20240319094937874"></p><h2 id="外模式（也称子模式或用户模式）"><a href="#外模式（也称子模式或用户模式）" class="headerlink" title="外模式（也称子模式或用户模式）"></a>外模式（也称子模式或用户模式）</h2><ul><li>数据库用户使用的局部数据的逻辑结构和特征的描述</li><li>外模时通常是模式的自己、一个模式可以有多个外模式</li><li>一个数据库可以有多个外模式，一个应用程序只能使用一个外模式</li></ul><h2 id="模式（也称概念模式）"><a href="#模式（也称概念模式）" class="headerlink" title="模式（也称概念模式）"></a>模式（也称概念模式）</h2><ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据视图</li><li>一个数据库只有一个概念模式</li></ul><h2 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h2><ul><li>是数据物理结构和存储方式的描述</li><li>是数在数据库内部的表示方式</li><li>一个数据库只有一个内模式</li></ul><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403190954744.png" alt="image-20240319095441983"></p><h2 id="三级模式的关系"><a href="#三级模式的关系" class="headerlink" title="三级模式的关系"></a>三级模式的关系</h2><p>（1）模式是数据库的中心与关键。<br>（2）内模式依赖于模式，独立于外模式和存储设备。<br>（3）外模式面向具体的应用，独立于内模式和存储设备。<br>（4）应用程序依赖于外模式，独立于模式和内模式。</p><h1 id="数据库的分析与设计过程"><a href="#数据库的分析与设计过程" class="headerlink" title="数据库的分析与设计过程"></a>数据库的分析与设计过程</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403190956934.png" alt="image-20240319095646691"></p><h1 id="数据模型——基本概念"><a href="#数据模型——基本概念" class="headerlink" title="数据模型——基本概念"></a>数据模型——基本概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191000363.png" alt="image-20240319100015616"></p><h1 id="数据模型——E-R模型"><a href="#数据模型——E-R模型" class="headerlink" title="数据模型——E-R模型"></a>数据模型——E-R模型</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191001158.png" alt="image-20240319100149461"></p><h1 id="数据模型——关系模型"><a href="#数据模型——关系模型" class="headerlink" title="数据模型——关系模型"></a>数据模型——关系模型</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191006024.png" alt="image-20240319100626607"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191037231.png" alt="image-20240319103745313"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191043361.png" alt="image-20240319104259998"></p><h1 id="关系代数——关系模式相关名词"><a href="#关系代数——关系模式相关名词" class="headerlink" title="关系代数——关系模式相关名词"></a>关系代数——关系模式相关名词</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191043198.png" alt="image-20240319104345503"></p><h1 id="数据库完整性约束"><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191045425.png" alt="image-20240319104537550"></p><ol><li>实体完整性：规定表的每一行在表中是唯一的实体。</li><li>参照完整性：是指两个表的<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%85%B3%E9%94%AE%E5%AD%97/0?fromModule=lemma_inlink">主关键字</a>和<a href="https://baike.baidu.com/item/%E5%A4%96%E5%85%B3%E9%94%AE%E5%AD%97/1239625?fromModule=lemma_inlink">外关键字</a>的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义完整性：不同的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/0?fromModule=lemma_inlink">关系数据库系统</a>根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ol><h1 id="关系代数——关系的三种类型"><a href="#关系代数——关系的三种类型" class="headerlink" title="关系代数——关系的三种类型"></a>关系代数——关系的三种类型</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191050332.png" alt="image-20240319105017021"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191052834.png" alt="image-20240319105236216"></p><h1 id="关系代数——其中基本运算"><a href="#关系代数——其中基本运算" class="headerlink" title="关系代数——其中基本运算"></a>关系代数——其中基本运算</h1><h2 id="并、交、差"><a href="#并、交、差" class="headerlink" title="并、交、差"></a>并、交、差</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191053768.png" alt="image-20240319105359066"></p><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>笛卡尔积不会去掉重复的</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191054758.png"></p><h2 id="投影、选择"><a href="#投影、选择" class="headerlink" title="投影、选择"></a>投影、选择</h2><p>投影操作是对列的操作</p><p>选择操作是对行的操作</p><p>区分符号</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191057213.png" alt="image-20240319105737600"></p><h2 id="联接"><a href="#联接" class="headerlink" title="联接"></a>联接</h2><p><strong>联接是在笛卡尔积中进行。</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191058141.png" alt="image-20240319105836412"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191106134.png" alt="image-20240319110646519"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191107103.png" alt="image-20240319110724459"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191109585.png" alt="image-20240319110905240"></p><h1 id="关系型数据库SQL简介"><a href="#关系型数据库SQL简介" class="headerlink" title="关系型数据库SQL简介"></a>关系型数据库SQL简介</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191109369.png" alt="image-20240319110935850"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403191110692.png" alt="image-20240319111034227"></p><h1 id="关系数据库的规范化"><a href="#关系数据库的规范化" class="headerlink" title="关系数据库的规范化"></a>关系数据库的规范化</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>函数依赖是关系模式中，属性之间的逻辑依赖关系<br>定义如下：<br>设关系R(U,F)，U是属性集，F是函数依赖集，令X、Y是U的两个子集；<br>对于任意R的一个关系r，X的每一个具体值，Y都有唯一值与之对应；<br>则，X决定函数Y，或Y函数依赖于X，记作X→Y（X是自变量，Y是因变量，一个X只能得到一个Y）</p><h2 id="平凡依赖"><a href="#平凡依赖" class="headerlink" title="平凡依赖"></a>平凡依赖</h2><p>定义：</p><p>若X-&gt;Y，且Y是X的子集（对任一关系模式，平凡函数依赖必然成立），就是平凡函数依赖。</p><p>例如：</p><p>在学生表(学号,姓名,年级)中,(学号,姓名)可以推出学号和姓名其中的任何一个,这就是平凡函数依赖.</p><p>直白点说，就是只要Y是X的子集，Y就依赖于X。</p><h2 id="非平凡依赖"><a href="#非平凡依赖" class="headerlink" title="非平凡依赖"></a>非平凡依赖</h2><p>定义：</p><p>若X-&gt;Y，但Y不是X的子集，就是非平凡函数依赖。</p><p>例如：</p><p>在学生表(学号,姓名,年级)中,通过(学号,姓名)可以推出这个学生所在的年级,但年级不是（学号，姓名）的子集，这是非平凡函数依赖.((学号,姓名)就是一个x,学号或者姓名就是一个x’)。</p><h2 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h2><p>定义：</p><p>在R(U)中，如果X-&gt;Y。并且对于X的任何一个真子集X‘，都有X’-&#x2F;-&gt;Y，则称Y对X有完全函数依赖，记作X-&gt;Y（箭头上有个大写F）。</p><p>例如：</p><p>eg：在表（学号，课程号，成绩）中，“成绩”对（学号，课程号）是完全函数依赖。学号和课程号可以确定对应课程成绩，但是学号和课程号它们谁都不能单独确定成绩。</p><p>也就是说X内任意一个真子集（真子集不包含它本身），都不能唯一确定Y。</p><h2 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h2><p>定义：</p><p>若X-&gt;Y,但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X-&gt;Y（箭头上有个大写P）。</p><p>例如：</p><p>eg 1：在学生表(学号,姓名,年级)中,不仅(学号,姓名)可以推出年级，单独通过属性“学号”也可以推出“年级”，这就是部分函数依赖。</p><p>eg 2：“院系”对（学号，课程号）是部分函数依赖。课程号和学号一起可以确定院系，但学号是（学号，课程号）的真子集，并且学号单独可以确定院系。</p><h2 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h2><p>定义：</p><p>在R（U）中，如果X-&gt;Y(Y不是X的子集)，Y-&#x2F;-&gt;X,Y-&gt;Z,Z是Y的子集，则称Z对X传递函数依赖。记为X-&gt;Z（箭头上是汉字 “传递”）</p><p>例如：</p><p>eg：学号-&gt;院系，院系-&gt;院长名</p><p>直白点说就是在一张表中，字段分为 X、Y、Z，如果X可以决定Y，Y可以决定Z，则推出X可以决定Z（这里还必须Y不能决定X，否则就是直接函数依赖），称Z传递函数依赖于X。</p><h1 id="关系数据库的规范化——求候选码"><a href="#关系数据库的规范化——求候选码" class="headerlink" title="关系数据库的规范化——求候选码"></a>关系数据库的规范化——求候选码</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322124949905.png" alt="image-20240322124949905"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322125701819.png" alt="image-20240322125701819"></p><h1 id="关系数据库的规范化——规范化理论"><a href="#关系数据库的规范化——规范化理论" class="headerlink" title="关系数据库的规范化——规范化理论"></a>关系数据库的规范化——规范化理论</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322125755953.png" alt="image-20240322125755953"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322130108270.png" alt="image-20240322130108270"></p><p>掌握1，2，3，BC范式</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322130233473.png" alt="image-20240322130233473"></p><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>定义：关系中每一分量不可再分。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>定义：在1NF基础上，消除非主属性对键的部分依赖，则称它符合2NF。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322131023662.png" alt="image-20240322131023662"></p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>定义：在2NF基础上，消除非主属性对键的传递依赖，则称它符合3NF。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240322131107338.png" alt="image-20240322131107338"></p><p>根据上面对传递依赖的分析，对于Student表，<code>学生编号</code>可以唯一确定他所在的<code>院系</code>，但是注意到这中间存在<code>传递过程</code>，即<code>学生编号</code>唯一确定该学生所对应的<code>班级编号</code>，<code>班级编号</code>对应唯一的<code>院系</code>。我们称，<code>院系</code>对<code>学生编号</code>传递函数依赖。</p><p>把Student表继续进行拆分，可以消除传递依赖。</p><p>其中，学生表Student如下：</p><table><thead><tr><th>学生编号</th><th>学生姓名</th><th>班级编号</th></tr></thead><tbody><tr><td>S01</td><td>杨明</td><td>D01</td></tr><tr><td>S02</td><td>李婉</td><td>D01</td></tr><tr><td>S01</td><td>杨明</td><td>D01</td></tr><tr><td>S03</td><td>刘海</td><td>D02</td></tr><tr><td>S04</td><td>安然</td><td>D02</td></tr><tr><td>S05</td><td>乐天</td><td>D03</td></tr></tbody></table><p>班级-院系表如下：</p><table><thead><tr><th>班级编号</th><th>院系</th></tr></thead><tbody><tr><td>D01</td><td>思齐</td></tr><tr><td>D02</td><td>述圣</td></tr><tr><td>D03</td><td>省身</td></tr></tbody></table><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>若R属于BCNF，则R有：</p><p>1、所有非主属性对每一个码都是完全函数依赖。</p><p>2、所有的主属性对每一个不包含它的码,也是完全函数依赖。</p><p>3、没有任何属性完全函数依赖于非码的任何一组属性。</p><p>举例</p><p>数据库中有如下一张表（其中主键为 <strong>仓库名 和 物品名 的组合</strong>，同时 <strong>管理员 和 物品名 的组合</strong>是候选键 ）</p><table><thead><tr><th>仓库名</th><th>管理员</th><th>物品名</th><th>数量</th></tr></thead><tbody><tr><td>北京仓</td><td>张三</td><td>iPhone XR</td><td>10</td></tr><tr><td>北京仓</td><td>张三</td><td>iPhone 8P</td><td>20</td></tr><tr><td>上海仓</td><td>李四</td><td>iPhone 8</td><td>30</td></tr><tr><td>上海仓</td><td>李四</td><td>iPhone 7</td><td>40</td></tr></tbody></table><p>显然，管理员的名字可以决定仓库名，那么这个候选键中的主属性就影响到主键中的属性了。<br>主键中的主属性对于候选键是部分依赖关系，这可能导致插入、删除和更新数据时产生异常。</p><p>因此，应该把这张表拆分成如下两张表：</p><p><strong>仓库 表</strong></p><table><thead><tr><th>仓库名</th><th>物品名</th><th>数量</th></tr></thead><tbody><tr><td>北京仓</td><td>iPhone XR</td><td>10</td></tr><tr><td>北京仓</td><td>iPhone 8P</td><td>20</td></tr><tr><td>上海仓</td><td>iPhone 8</td><td>30</td></tr><tr><td>上海仓</td><td>iPhone 7</td><td>40</td></tr></tbody></table><p><strong>仓库-管理员 表</strong></p><table><thead><tr><th>仓库名</th><th>管理员</th></tr></thead><tbody><tr><td>北京仓</td><td>张三</td></tr><tr><td>北京仓</td><td>张三</td></tr><tr><td>上海仓</td><td>李四</td></tr><tr><td>上海仓</td><td>李四</td></tr></tbody></table><p>例题</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324162343155.png" alt="image-20240324162343155"></p><h1 id="关系数据库的规范化——关系模式分解"><a href="#关系数据库的规范化——关系模式分解" class="headerlink" title="关系数据库的规范化——关系模式分解"></a>关系数据库的规范化——关系模式分解</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324162507070.png" alt="image-20240324162507070"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324184253716.png" alt="image-20240324184253716"></p><h1 id="数据库的控制功能——事务管理"><a href="#数据库的控制功能——事务管理" class="headerlink" title="数据库的控制功能——事务管理"></a>数据库的控制功能——事务管理</h1><ul><li>事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。</li></ul><ol><li>事务的特性:<br>原子性: 强调事务中的多个操作时一个整体<br>一致性: 强调数据库中不会保存不一致状态<br>隔离性: 强调数据库中事务之间相互不可见<br>持久性: 强调数据库能永久保存数据，一旦提交就不可撤销</li></ol><h1 id="数据库的控制功能——并发控制"><a href="#数据库的控制功能——并发控制" class="headerlink" title="数据库的控制功能——并发控制"></a>数据库的控制功能——并发控制</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324190225972.png" alt="image-20240324190225972"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324190326673.png" alt="image-20240324190326673"></p><p>例题：</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324191238660.png" alt="image-20240324191238660"></p><h1 id="数据库的控制功能——备份和恢复"><a href="#数据库的控制功能——备份和恢复" class="headerlink" title="数据库的控制功能——备份和恢复"></a>数据库的控制功能——备份和恢复</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324191318288.png"></p><h1 id="数据仓库与数据挖掘基础"><a href="#数据仓库与数据挖掘基础" class="headerlink" title="数据仓库与数据挖掘基础"></a>数据仓库与数据挖掘基础</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324191522540.png" alt="image-20240324191522540"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324191641819.png" alt="image-20240324191641819"></p><h1 id="大数据基本概念"><a href="#大数据基本概念" class="headerlink" title="大数据基本概念"></a>大数据基本概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240324191716126.png" alt="image-20240324191716126"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五章 计算机网络基础</title>
    <link href="/cblog/2024/03/18/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/cblog/2024/03/18/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、计算机网络分类"><a href="#一、计算机网络分类" class="headerlink" title="一、计算机网络分类"></a>一、计算机网络分类</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181917799.png" alt="image-20240318191725712"></p><h1 id="二、七层网络体系结构"><a href="#二、七层网络体系结构" class="headerlink" title="二、七层网络体系结构"></a>二、七层网络体系结构</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181943593.png" alt="image-20240318194303395"></p><h1 id="三、网络的设备"><a href="#三、网络的设备" class="headerlink" title="三、网络的设备"></a>三、网络的设备</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181943794.png" alt="image-20240318194332726"></p><h1 id="四、TCP-IP协议族"><a href="#四、TCP-IP协议族" class="headerlink" title="四、TCP&#x2F;IP协议族"></a>四、TCP&#x2F;IP协议族</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181944306.png" alt="image-20240318194400973"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181945686.png" alt="image-20240318194515411"></p><h1 id="五、IP地址和IPv6简介"><a href="#五、IP地址和IPv6简介" class="headerlink" title="五、IP地址和IPv6简介"></a>五、IP地址和IPv6简介</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181946229.png" alt="image-20240318194635046"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181949747.png" alt="image-20240318194901603"></p><h1 id="六、Internet服务"><a href="#六、Internet服务" class="headerlink" title="六、Internet服务"></a>六、Internet服务</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181949645.png" alt="image-20240318194951440"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181951182.png" alt="image-20240318195134076"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四章 操作系统基本原理</title>
    <link href="/cblog/2024/03/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/cblog/2024/03/13/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统的概念（定义）"><a href="#操作系统的概念（定义）" class="headerlink" title="操作系统的概念（定义）"></a>操作系统的概念（定义）</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131811740.png" alt="image-20240313181101574"></p><h1 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131811078.png" alt="image-20240313181142037"></p><h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><ol><li>并发：区别于并行。并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</li><li>共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程中同时使用。</li><li>虚拟：是指一个物理上的实体变为若干个逻辑上的对应物，物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。</li><li>异步：再多道程序环境下，允许多个程序并发的执行，但由于资源有限，进程的执行不是一管到底的，而是走走停停已不可预知的速度向前推进，这就是进程的异步性！</li></ol><h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131824844.png" alt="image-20240313182443800"></p><h1 id="进程管理——状态转换图"><a href="#进程管理——状态转换图" class="headerlink" title="进程管理——状态转换图"></a>进程管理——状态转换图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131825880.png" alt="image-20240313182554696"></p><p>PCB：用来描述和控制进程的运行的一个数据结构——进程控制块PCB(Process Control Block)，是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131833459.png" alt="image-20240313183339267"></p><h1 id="进程管理——前驱图"><a href="#进程管理——前驱图" class="headerlink" title="进程管理——前驱图"></a>进程管理——前驱图</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131926502.png" alt="image-20240313192641462"></p><h1 id="进程管理——进程同步机制"><a href="#进程管理——进程同步机制" class="headerlink" title="进程管理——进程同步机制"></a>进程管理——进程同步机制</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131927807.png" alt="image-20240313192722675"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131930257.png" alt="image-20240313193028193"></p><h1 id="进程管理——进程互斥机制"><a href="#进程管理——进程互斥机制" class="headerlink" title="进程管理——进程互斥机制"></a>进程管理——进程互斥机制</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131931098.png" alt="image-20240313193141941"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403131935476.png" alt="image-20240313193547336"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181515963.png" alt="image-20240318151429328"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181516375.png" alt="image-20240318151607957"></p><ol><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ol><h1 id="进程管理——信号量机制"><a href="#进程管理——信号量机制" class="headerlink" title="进程管理——信号量机制"></a>进程管理——信号量机制</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181521149.png" alt="image-20240318152148928"></p><p>信号量机制：</p><ol><li>实现进程同步</li><li>实现进程互斥</li><li>实现进程的前驱关系</li></ol><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181522538.png" alt="image-20240318152231962"></p><h1 id="进程管理——PV操作"><a href="#进程管理——PV操作" class="headerlink" title="进程管理——PV操作"></a>进程管理——PV操作</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181526460.png" alt="image-20240318152615368"></p><h2 id="前驱操作"><a href="#前驱操作" class="headerlink" title="前驱操作"></a>前驱操作</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181527883.png" alt="image-20240318152706675"></p><p>例题 C A A</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181533082.png" alt="image-20240318153319941"></p><h1 id="进程管理——死锁"><a href="#进程管理——死锁" class="headerlink" title="进程管理——死锁"></a>进程管理——死锁</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181536832.png" alt="image-20240318153652605"></p><h1 id="进程管理——死锁的必要条件"><a href="#进程管理——死锁的必要条件" class="headerlink" title="进程管理——死锁的必要条件"></a>进程管理——死锁的必要条件</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181538296.png" alt="image-20240318153823075"></p><ol><li>互斥条件</li><li>不剥夺条件</li><li>请求和保持条件</li><li>循环等待条件</li></ol><h1 id="进程管理——死锁的处理策略"><a href="#进程管理——死锁的处理策略" class="headerlink" title="进程管理——死锁的处理策略"></a>进程管理——死锁的处理策略</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181540540.png" alt="image-20240318154005422"></p><p>例题</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181544940.png" alt="image-20240318154417744"></p><h1 id="进程管理——银行家算法"><a href="#进程管理——银行家算法" class="headerlink" title="进程管理——银行家算法"></a>进程管理——银行家算法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181545172.png" alt="image-20240318154511013"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181548332.png" alt="image-20240318154851249"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181549208.png" alt="image-20240318154914066"></p><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181555945.png" alt="image-20240318155553808"></p><h1 id="存储管理——内存分配与回收"><a href="#存储管理——内存分配与回收" class="headerlink" title="存储管理——内存分配与回收"></a>存储管理——内存分配与回收</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181557079.png" alt="image-20240318155734018"></p><h1 id="存储管理——首次适应算法"><a href="#存储管理——首次适应算法" class="headerlink" title="存储管理——首次适应算法"></a>存储管理——首次适应算法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181559069.png" alt="image-20240318155902915"></p><h1 id="存储管理——最佳适应算法"><a href="#存储管理——最佳适应算法" class="headerlink" title="存储管理——最佳适应算法"></a>存储管理——最佳适应算法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181605040.png" alt="image-20240318160558839"></p><h1 id="存储管理——最差适应算法"><a href="#存储管理——最差适应算法" class="headerlink" title="存储管理——最差适应算法"></a>存储管理——最差适应算法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181610280.png" alt="image-20240318161036109"></p><h1 id="存储管理——邻近适应算法"><a href="#存储管理——邻近适应算法" class="headerlink" title="存储管理——邻近适应算法"></a>存储管理——邻近适应算法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181611240.png" alt="image-20240318161126084"></p><h1 id="存储管理——分页存储管理"><a href="#存储管理——分页存储管理" class="headerlink" title="存储管理——分页存储管理"></a>存储管理——分页存储管理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181624694.png" alt="image-20240318162443511"></p><p>例题</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181637603.png" alt="image-20240318163725406"></p><h1 id="存储管理——分段存储管理"><a href="#存储管理——分段存储管理" class="headerlink" title="存储管理——分段存储管理"></a>存储管理——分段存储管理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181714845.png" alt="image-20240318171436708"></p><h1 id="存储管理——段页式存储管理"><a href="#存储管理——段页式存储管理" class="headerlink" title="存储管理——段页式存储管理"></a>存储管理——段页式存储管理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181715912.png" alt="image-20240318171533710"></p><h1 id="存储管理——页面置换算法"><a href="#存储管理——页面置换算法" class="headerlink" title="存储管理——页面置换算法"></a>存储管理——页面置换算法</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181720949.png" alt="image-20240318172001717"></p><h1 id="存储管理——最佳OPT"><a href="#存储管理——最佳OPT" class="headerlink" title="存储管理——最佳OPT"></a>存储管理——最佳OPT</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181723372.png" alt="image-20240318172319167"></p><h1 id="存储管理——先进先出FIFO"><a href="#存储管理——先进先出FIFO" class="headerlink" title="存储管理——先进先出FIFO"></a>存储管理——先进先出FIFO</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181723650.png" alt="image-20240318172356475"></p><h1 id="存储管理——最近最久未使用LRU"><a href="#存储管理——最近最久未使用LRU" class="headerlink" title="存储管理——最近最久未使用LRU"></a>存储管理——最近最久未使用LRU</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181724762.png" alt="image-20240318172430553"></p><h1 id="文件管理——初识文件管理"><a href="#文件管理——初识文件管理" class="headerlink" title="文件管理——初识文件管理"></a>文件管理——初识文件管理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181726635.png" alt="image-20240318172607545"></p><h1 id="文件管理——文件目录"><a href="#文件管理——文件目录" class="headerlink" title="文件管理——文件目录"></a>文件管理——文件目录</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181727534.png" alt="image-20240318172707475"></p><p>文件控制块（FCB）：当你建立一个目录或者文件时，会在文件目录中新增一条记录(记录文件的属性)，这样的一条记录就称做一个FCB。FCB中最重要的就是文件名和物理地址的映射，从而实现<strong>按名存取</strong>。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181728699.png" alt="image-20240318172841605"></p><h1 id="文件管理——文件的结构"><a href="#文件管理——文件的结构" class="headerlink" title="文件管理——文件的结构"></a>文件管理——文件的结构</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181729937.png" alt="image-20240318172932861"></p><h1 id="文件管理——索引分配"><a href="#文件管理——索引分配" class="headerlink" title="文件管理——索引分配"></a>文件管理——索引分配</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181743941.png" alt="image-20240318174338691"></p><h1 id="文件管理——空闲存储空间管理"><a href="#文件管理——空闲存储空间管理" class="headerlink" title="文件管理——空闲存储空间管理"></a>文件管理——空闲存储空间管理</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181744539.png" alt="image-20240318174415320"></p><h2 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h2><p>D  B</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181752580.png" alt="image-20240318175259358"></p><h1 id="设备管理——I-O设备基本概念"><a href="#设备管理——I-O设备基本概念" class="headerlink" title="设备管理——I&#x2F;O设备基本概念"></a>设备管理——I&#x2F;O设备基本概念</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181753690.png" alt="image-20240318175357606"></p><h1 id="设备管理——I-O控制方式"><a href="#设备管理——I-O控制方式" class="headerlink" title="设备管理——I&#x2F;O控制方式"></a>设备管理——I&#x2F;O控制方式</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181754189.png" alt="image-20240318175424063"></p><h1 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403181755836.png" alt="image-20240318175531706"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三章 算法分析与设计</title>
    <link href="/cblog/2024/03/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/cblog/2024/03/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、分治法"><a href="#一、分治法" class="headerlink" title="一、分治法"></a>一、分治法</h1><h2 id="分治法基本概念"><a href="#分治法基本概念" class="headerlink" title="分治法基本概念"></a>分治法基本概念</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101031008.png" alt="image-20240310103106060"></p><h2 id="分治法求解步骤"><a href="#分治法求解步骤" class="headerlink" title="分治法求解步骤"></a>分治法求解步骤</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101032786.png" alt="image-20240310103221374"></p><h2 id="分治法——递归"><a href="#分治法——递归" class="headerlink" title="分治法——递归"></a>分治法——递归</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101033925.png" alt="image-20240310103337503"></p><h1 id="二、回溯法——深度优先"><a href="#二、回溯法——深度优先" class="headerlink" title="二、回溯法——深度优先"></a>二、回溯法——深度优先</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101104829.png" alt="image-20240310110452531"></p><h1 id="三、贪心法（局部最优）"><a href="#三、贪心法（局部最优）" class="headerlink" title="三、贪心法（局部最优）"></a>三、贪心法（局部最优）</h1><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101103429.png" alt="image-20240310110331426"></p><h1 id="四、动态规划法"><a href="#四、动态规划法" class="headerlink" title="四、动态规划法"></a>四、动态规划法</h1><h2 id="子问题不独立（区别分治法）"><a href="#子问题不独立（区别分治法）" class="headerlink" title="子问题不独立（区别分治法）"></a>子问题不独立（区别分治法）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101043835.png" alt="image-20240310104328814"></p><h2 id="整体最优（区别贪心法）"><a href="#整体最优（区别贪心法）" class="headerlink" title="整体最优（区别贪心法）"></a>整体最优（区别贪心法）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403101048800.png" alt="image-20240310104833177"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403111713860.png" alt="image-20240311171346493"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403111721475.png" alt="image-20240311172149658"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二章 数据结构与算法基础</title>
    <link href="/cblog/2024/03/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/cblog/2024/03/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306151941599.png" alt="image-20240306151941599"></p><h1 id="2-1-基础概念和算法"><a href="#2-1-基础概念和算法" class="headerlink" title="2.1 基础概念和算法"></a>2.1 基础概念和算法</h1><h2 id="数据结构学什么？"><a href="#数据结构学什么？" class="headerlink" title="数据结构学什么？"></a>数据结构学什么？</h2><p>如何用程序代码把现实世界的问题信息化。</p><p>如何用计算机高效地处理这些信息从而创造价值。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据：数据是<font color='red'>信息的载体</font>，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。<font color='red'>数据是计算机程序加工的原料</font>。</p><p>数据元素：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</p><p>数据项：一个数据元素可由<font color='red'>若干数据项组成</font>，数据项是构成数据元素的不可分割的<font color='red'>最小单位</font>。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306155339668.png" alt="image-20240306155339668"></p><p>数据结构：数据结构是相互存在的一种或多种特定关系的数据元素的集合。</p><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306155501068.png" alt="image-20240306155501068"></p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306155538268.png" alt="image-20240306155538268"></p><p>集合：各个元素同属一个集合，别无其他关系。</p><p>线性结构：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除最后一个元素，所有元素都有唯一后继。</p><p>树形结构：数据元素之间是一对多的关系。</p><p>图结构：数据元素之间是多对多的关系。</p><h3 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306155818943.png" alt="image-20240306155818943"></p><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>程序 &#x3D; 数据结构 + 算法</p><p>算法：如何处理这些信息以解决实际问题。</p><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ol><li><p>有穷性：一个算法必须在执行有穷步之后结束，并且每一步都在有穷时间内完成，不能无限的执行下去；</p></li><li><p>确定性：算法的每一个步骤都应当是有确切定义的，对于每一个过程都不能有二义性，对于<font color = 'red'>相同的输入</font>只能得到<font color='red'>相同的输出</font>。</p></li><li><p>可行性：算法中描述的操作都可以通过已经实现的<font color='red'>基本运算执行有限次</font>来实现。</p></li><li><p>输入：一个算法<font color='red'>有零个或多个输入</font>，这些输入取自于某个特定的对象的集合。</p></li><li><p>输出：一个算法有<font color='red'>一个或多个输出</font>，这些输出是与输入有着某种特定关系的量。</p></li></ol><h3 id="算法——算法效率的度量"><a href="#算法——算法效率的度量" class="headerlink" title="算法——算法效率的度量"></a>算法——算法效率的度量</h3><p>时间复杂度：时间开销与问题规模n之间的关系。</p><p>空间复杂度：空间开销（内存开销）与问题规模n之间的关系。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306163715478.png" alt="image-20240306163715478"></p><h1 id="2-2-线性表、栈和队列、串、数组、矩阵和广义表"><a href="#2-2-线性表、栈和队列、串、数组、矩阵和广义表" class="headerlink" title="2.2 线性表、栈和队列、串、数组、矩阵和广义表"></a>2.2 线性表、栈和队列、串、数组、矩阵和广义表</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306163904579.png" alt="image-20240306163904579"></p><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306163945804.png" alt="image-20240306163945804"></p><h2 id="线性表——存储结构"><a href="#线性表——存储结构" class="headerlink" title="线性表——存储结构"></a>线性表——存储结构</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240306164039592.png" alt="image-20240306164039592"></p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309130338087.png" alt="image-20240309130338087"></p><h2 id="线性表——插入删除操作"><a href="#线性表——插入删除操作" class="headerlink" title="线性表——插入删除操作"></a>线性表——插入删除操作</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309130526874.png" alt="image-20240309130526874"></h3><h2 id="栈和队列——栈定义"><a href="#栈和队列——栈定义" class="headerlink" title="栈和队列——栈定义"></a>栈和队列——栈定义</h2><p>栈和队列都是操作受限的线性表</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309133444989.png" alt="image-20240309133444989"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309133516332.png" alt="image-20240309133516332"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309133611134.png" alt="image-20240309133611134"></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>队空条件：head&#x3D;tail</p><p>队满条件：（tail+1）%size&#x3D;head</p><h2 id="串、数组、矩阵和广义表"><a href="#串、数组、矩阵和广义表" class="headerlink" title="串、数组、矩阵和广义表"></a>串、数组、矩阵和广义表</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309133846083.png" alt="image-20240309133846083"></p><p><a href="https://www.runoob.com/w3cnote/ascii.html">ASCII 表 | 菜鸟教程 (runoob.com)</a></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309134234200.png" alt="image-20240309134234200"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309134338857.png" alt="image-20240309134338857"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309134551797.png" alt="image-20240309134551797"></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="稀疏矩阵-三角矩阵"><a href="#稀疏矩阵-三角矩阵" class="headerlink" title="稀疏矩阵(三角矩阵)"></a>稀疏矩阵(三角矩阵)</h4><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309134612364.png" alt="image-20240309134612364"></p><p>计算存储位置可以用代入法</p><p>先代入A[0,0]</p><p>A[1,0]   A[0,1]</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309134939058.png" alt="image-20240309134939058"></p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309135204084.png" alt="image-20240309135204084"></p><p>例一：长度&#x3D;3，深度&#x3D;2</p><p>例二：head(head(tail(LS1)))</p><p><strong>原子的深度是0</strong></p><p><strong>空表的深度是1</strong></p><p><strong>当广义表LS非空时，称第一个元素为LS的表头；称广义表LS中除去表头后其余元素组成的广义表为LS的表尾。</strong></p><h1 id="2-3-树和二叉树、图"><a href="#2-3-树和二叉树、图" class="headerlink" title="2.3 树和二叉树、图"></a>2.3 树和二叉树、图</h1><h2 id="树和二叉树——树的基本概念"><a href="#树和二叉树——树的基本概念" class="headerlink" title="树和二叉树——树的基本概念"></a>树和二叉树——树的基本概念</h2><ol><li>结点的度：节点的度是指节点的子树个数。</li><li>树的度：树的度是指树中节点的度最大值。</li><li>叶子结点：度为0的结点</li><li>分支结点：</li><li>内部结点：除了分支结点和子结点。</li><li>父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点</li><li>根节点：一棵树中，没有双亲结点的结点</li><li>子结点：一个结点含有的子树的根结点称为该结点的子结点</li><li>兄弟结点：具有相同父结点的结点互称为兄弟结点</li><li>层次：从根开始定义起，根为第1层，根的子结点为第二层</li><li>满二叉树、完全二叉树、非完全二叉树</li></ol><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309144755986.png" alt="image-20240309144755986"></p><h2 id="树和二叉树——二叉树的遍历"><a href="#树和二叉树——二叉树的遍历" class="headerlink" title="树和二叉树——二叉树的遍历"></a>树和二叉树——二叉树的遍历</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309145046452.png" alt="image-20240309145046452"></p><p>前序遍历：（根左右）12457836</p><p>中序遍历：（左根右）42785136</p><p>后续遍历：（左右根）48752631</p><p>层次遍历：12345678</p><h2 id="树和二叉树——反向构造二叉树"><a href="#树和二叉树——反向构造二叉树" class="headerlink" title="树和二叉树——反向构造二叉树"></a>树和二叉树——反向构造二叉树</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309150037874.png" alt="image-20240309150037874"></p><p>根据二叉树的遍历序列，反向构造二叉树；必须有<strong>中序序列和任意前序或后序序列</strong>才能实现</p><h2 id="树和二叉树——树转二叉树"><a href="#树和二叉树——树转二叉树" class="headerlink" title="树和二叉树——树转二叉树"></a>树和二叉树——树转二叉树</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309150226264.png" alt="image-20240309150226264"></p><p><strong>左儿子</strong>，<strong>右兄弟</strong></p><h2 id="树和二叉树——查找二叉树（二叉排序树）"><a href="#树和二叉树——查找二叉树（二叉排序树）" class="headerlink" title="树和二叉树——查找二叉树（二叉排序树）"></a>树和二叉树——查找二叉树（二叉排序树）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309150531339.png" alt="image-20240309150531339"></p><h2 id="树和二叉树——构造霍夫曼树（最优）"><a href="#树和二叉树——构造霍夫曼树（最优）" class="headerlink" title="树和二叉树——构造霍夫曼树（最优）"></a>树和二叉树——构造霍夫曼树（最优）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309150630465.png" alt="image-20240309150630465"></p><h2 id="树和二叉树——线索二叉树"><a href="#树和二叉树——线索二叉树" class="headerlink" title="树和二叉树——线索二叉树"></a>树和二叉树——线索二叉树</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309150938791.png" alt="image-20240309150938791"></p><h2 id="树和二叉树——平衡二叉树"><a href="#树和二叉树——平衡二叉树" class="headerlink" title="树和二叉树——平衡二叉树"></a>树和二叉树——平衡二叉树</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309151849551.png" alt="image-20240309151849551"></p><h2 id="图——基本概念"><a href="#图——基本概念" class="headerlink" title="图——基本概念"></a>图——基本概念</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309152101183.png" alt="image-20240309152101183"></p><h2 id="图——存储结构（邻接矩阵）"><a href="#图——存储结构（邻接矩阵）" class="headerlink" title="图——存储结构（邻接矩阵）"></a>图——存储结构（邻接矩阵）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309152133088.png" alt="image-20240309152133088"></p><h2 id="图——存储结构（邻接表）"><a href="#图——存储结构（邻接表）" class="headerlink" title="图——存储结构（邻接表）"></a>图——存储结构（邻接表）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309152243334.png" alt="image-20240309152243334"></p><h2 id="图——图的遍历"><a href="#图——图的遍历" class="headerlink" title="图——图的遍历"></a>图——图的遍历</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309152404243.png" alt="image-20240309152404243"></p><h2 id="图——拓扑排序"><a href="#图——拓扑排序" class="headerlink" title="图——拓扑排序"></a>图——拓扑排序</h2><p><strong>AOV网络</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309152514097.png" alt="image-20240309152514097"></p><h2 id="图——最小生成树"><a href="#图——最小生成树" class="headerlink" title="图——最小生成树"></a>图——最小生成树</h2><h3 id="prime算法"><a href="#prime算法" class="headerlink" title="prime算法"></a>prime算法</h3><ol><li>从源点出发，将所有与源点连接的点加入一个待处理的集合中</li><li>从集合中找出与源点的边中权重最小的点，从待处理的集合中移除标记为确定的点</li><li>将找到的点按照步骤1的方式处理</li><li>重复2，3步直到所有的点都被标记</li><li><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309152929026.png" alt="image-20240309152929026"></li></ol><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><ol><li>将边按照权重从小到大排列</li><li>枚举第一个边，加入MST里，判断是否成环</li><li>如果成环则跳过，否则确定这条边为MST里的</li><li>继续枚举下一条边，直到所有的边都枚举完</li></ol><h1 id="2-4-查找、排序"><a href="#2-4-查找、排序" class="headerlink" title="2.4 查找、排序"></a>2.4 查找、排序</h1><h2 id="查找——基本概念"><a href="#查找——基本概念" class="headerlink" title="查找——基本概念"></a>查找——基本概念</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309153325388.png" alt="image-20240309153325388"></p><p>查找：静态查找、动态查找、哈希表</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309153356171.png" alt="image-20240309153356171"></p><h2 id="查找——顺序查找"><a href="#查找——顺序查找" class="headerlink" title="查找——顺序查找"></a>查找——顺序查找</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309153513171.png" alt="image-20240309153513171"></p><h2 id="查找——折半查找"><a href="#查找——折半查找" class="headerlink" title="查找——折半查找"></a>查找——折半查找</h2><p>折半查找仅限于有序顺序表</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309153650581.png" alt="image-20240309153650581"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309155258028.png" alt="image-20240309155258028"></p><h2 id="查找——分块查找"><a href="#查找——分块查找" class="headerlink" title="查找——分块查找"></a>查找——分块查找</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309155322450.png" alt="image-20240309155322450"></p><h2 id="查找——哈希表-散列表"><a href="#查找——哈希表-散列表" class="headerlink" title="查找——哈希表(散列表)"></a>查找——哈希表(散列表)</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309155653577.png" alt="image-20240309155653577"></p><h2 id="排序——基本概念"><a href="#排序——基本概念" class="headerlink" title="排序——基本概念"></a>排序——基本概念</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309155820905.png" alt="image-20240309155820905"></p><p>內部排序：内存中的排序</p><p>外部排序：用到外部存储器的排序</p><p><strong>稳定排序与不稳定排序</strong>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1&#x3D;A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403091652142.png"></p><h2 id="排序——直接插入排序（稳定）"><a href="#排序——直接插入排序（稳定）" class="headerlink" title="排序——直接插入排序（稳定）"></a>排序——直接插入排序（稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309160213064.png" alt="image-20240309160213064"></p><h2 id="排序——希尔排序（不稳定）"><a href="#排序——希尔排序（不稳定）" class="headerlink" title="排序——希尔排序（不稳定）"></a>排序——希尔排序（不稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309160307132.png" alt="image-20240309160307132"></p><h2 id="排序——冒泡排序（稳定）"><a href="#排序——冒泡排序（稳定）" class="headerlink" title="排序——冒泡排序（稳定）"></a>排序——冒泡排序（稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309163225119.png" alt="image-20240309163225119"></p><h2 id="排序——快速排序（不稳定）"><a href="#排序——快速排序（不稳定）" class="headerlink" title="排序——快速排序（不稳定）"></a>排序——快速排序（不稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309163408830.png" alt="image-20240309163408830"></p><h2 id="排序——简单选择排序（不稳定）"><a href="#排序——简单选择排序（不稳定）" class="headerlink" title="排序——简单选择排序（不稳定）"></a>排序——简单选择排序（不稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240309164826776.png" alt="image-20240309164826776"></p><h2 id="排序——堆排序（不稳定）"><a href="#排序——堆排序（不稳定）" class="headerlink" title="排序——堆排序（不稳定）"></a>排序——堆排序（不稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403091654448.png" alt="image-20240309165415258"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403091655784.png" alt="image-20240309165509585"></p><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点；将其与末尾元素进行交换，此时末尾就为最大值，可称为有序区。 然后将剩余 n-1个元素重新构造成一个堆，估且称为堆区 (未排序)，这样会得到 n个元素的次小值（将开始的第一个堆顶也算进去了，所以还是n个数）。 重复执行，有序区从:1—&gt;n，堆区：n–&gt;0，便能得到一个有序序列了</p><h2 id="排序——归并排序（稳定）"><a href="#排序——归并排序（稳定）" class="headerlink" title="排序——归并排序（稳定）"></a>排序——归并排序（稳定）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403091658522.png" alt="image-20240309165850372"></p><h2 id="排序——基数排序"><a href="#排序——基数排序" class="headerlink" title="排序——基数排序"></a>排序——基数排序</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403091659155.png" alt="image-20240309165924000"></p><h2 id="排序——评价指标"><a href="#排序——评价指标" class="headerlink" title="排序——评价指标"></a>排序——评价指标</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/202403091701808.png" alt="image-20240309170102724"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章 计算机组成原理与体系结构基础知识</title>
    <link href="/cblog/2024/02/29/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/cblog/2024/02/29/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1数据的表示和校验码"><a href="#1-1数据的表示和校验码" class="headerlink" title="1.1数据的表示和校验码"></a>1.1数据的表示和校验码</h1><p>低电平：0</p><p>高电平：1</p><h2 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h2><p>进制的转换 ：任意进制转化为十进制</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229205341108.png" alt="image-20240229205341108"></p><p>二进制转八进制：三位一组</p><p>二进制转十六进制：四位一组</p><p>十进制转二进制：短除法</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229205553401.png" alt="image-20240229205553401"></p><p>真值：符合人类习惯的数字</p><p>机器数：数字实际存到机器里的形式，正负号需要被“数字化”</p><p>定点数：小数点的位置固定</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229210013784.png" alt="image-20240229210013784"></p><p>浮点数：小数点的位置不固定</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229210045209.png" alt="image-20240229210045209"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229210106394.png" alt="image-20240229210106394"></p><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>原码：用数值部分表示真值的绝对值，符号位“0&#x2F;1”对应“正&#x2F;负”    0正1负</p><p>真值有+0和-0两种形式</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302173448590.png" alt="image-20240302173448590"></p><p>反码：若符号位为0，则反码和原码相同，若符号位为1，则数值位全部取反。</p><p>补码：正数的补码&#x3D;原码</p><p>​           负数的补码&#x3D;反码末位+1</p><p>​          将负数补码转回原码，尾数取反，末位加一</p><p>正0和负0的补码只有一种表现形式</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302173534826.png" alt="image-20240302173534826"></p><p>移码：补码的基础上将符号位取反。注意：移码只能用于表示整数。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302173731770.png" alt="image-20240302173731770"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302173836884.png" alt="image-20240302173836884"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302174052910.png" alt="image-20240302174052910"></p><p>其中，M称为尾数，R称为基数，E称为阶码</p><p>阶码：决定浮点数所能表示的数值范围</p><p>尾数：决定浮点数所能表示的数值精度</p><h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>常用的奇偶校验码：水平奇偶校验码、垂直奇偶校验码、水平垂直奇偶校验码</p><h4 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h4><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><p>海明码构成方法：在数据位之间插入k个校验码，通过扩大码距实现检错和纠错。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302174608641.png" alt="image-20240302174608641"></p><h1 id="1-2计算机体系结构和指令系统"><a href="#1-2计算机体系结构和指令系统" class="headerlink" title="1.2计算机体系结构和指令系统"></a>1.2计算机体系结构和指令系统</h1><p>计算机体系结构——五大部件：</p><p>1、输入设备</p><p>2、输出设备</p><p>3、运算器</p><p>4、存储器</p><p>5、控制器</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302175351354.png" alt="image-20240302175351354"><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302175512012.png" alt="image-20240302175512012"></p><h2 id="计算机体系结构——主存储器"><a href="#计算机体系结构——主存储器" class="headerlink" title="计算机体系结构——主存储器"></a>计算机体系结构——主存储器</h2><p>存储单元：每个存储单元存放一串二进制代码</p><p>存储字：存储单元中二进制代码的组合</p><p>存储字长：存储单元中二进制代码的位数</p><p>存储元：存储二进制的电子元件，每个存储元可存储1bit</p><p><font color='red'>MAR：</font>地址寄存器</p><p><font color='red'>MAR：</font>数据寄存器</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302181208464.png" alt="image-20240302181208464"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302181258266.png" alt="image-20240302181258266"></p><h2 id="计算机体系结构——运算器"><a href="#计算机体系结构——运算器" class="headerlink" title="计算机体系结构——运算器"></a>计算机体系结构——运算器</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302181427773.png" alt="image-20240302181427773"></p><h2 id="计算机体系结构——控制器"><a href="#计算机体系结构——控制器" class="headerlink" title="计算机体系结构——控制器"></a>计算机体系结构——控制器</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302181545252.png" alt="image-20240302181545252"></p><h2 id="计算机体系结构——Flynn分类法"><a href="#计算机体系结构——Flynn分类法" class="headerlink" title="计算机体系结构——Flynn分类法"></a>计算机体系结构——Flynn分类法</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302183620331.png" alt="image-20240302183620331"></p><h2 id="指令系统——指令"><a href="#指令系统——指令" class="headerlink" title="指令系统——指令"></a>指令系统——指令</h2><p>指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。</p><p>一台计算机的所有指令的集合构成该机的<font color='red'>指令系统</font>，也称指令集。</p><h2 id="指令系统——指令格式"><a href="#指令系统——指令格式" class="headerlink" title="指令系统——指令格式"></a>指令系统——指令格式</h2><p>一条指令就是机器语言的一个语句，它是一组<font color='red'>有意义</font>的二进制代码。</p><p>一条指令包括<font color='red'>操作码字段</font>和<font color='red'>地址码字段</font></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302193206601.png" alt="image-20240302193206601"></p><h2 id="指令系统——寻址方式"><a href="#指令系统——寻址方式" class="headerlink" title="指令系统——寻址方式"></a>指令系统——寻址方式</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302193321339.png" alt="image-20240302193321339"></p><p>数据寻址</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302193921567.png" alt="image-20240302193921567"></p><h2 id="指令系统——CISC和RISC"><a href="#指令系统——CISC和RISC" class="headerlink" title="指令系统——CISC和RISC"></a>指令系统——CISC和RISC</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302194758440.png" alt="image-20240302194758440"></p><h2 id="指令系统——指令的流水处理"><a href="#指令系统——指令的流水处理" class="headerlink" title="指令系统——指令的流水处理"></a>指令系统——指令的流水处理</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302194924283.png" alt="image-20240302194924283"></p><h2 id="指令系统——流水线的计算"><a href="#指令系统——流水线的计算" class="headerlink" title="指令系统——流水线的计算"></a>指令系统——流水线的计算</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302195327805.png" alt="image-20240302195327805"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302195411787.png" alt="image-20240302195411787"></p><p>加速比</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302195742525.png" alt="image-20240302195742525"></p><h1 id="1-3存储系统、总线系统、输入输出和可靠性"><a href="#1-3存储系统、总线系统、输入输出和可靠性" class="headerlink" title="1.3存储系统、总线系统、输入输出和可靠性"></a>1.3存储系统、总线系统、输入输出和可靠性</h1><h2 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302200846922.png" alt="image-20240302200846922"></p><p>cache：处理cpu和主存之间速度不匹配的问题  </p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302201217170.png" alt="image-20240302201217170"></p><p>cache由硬件自动完成。</p><h2 id="存储系统——存储器分类"><a href="#存储系统——存储器分类" class="headerlink" title="存储系统——存储器分类"></a>存储系统——存储器分类</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302202903975.png" alt="image-20240302202903975"></p><p><img src="/cblog/" alt="image-20240302202945235"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302204116163.png" alt="image-20240302204116163"></p><p><img src="/cblog/" alt="image-20240302204149037"></p><h2 id="存储系统——高速缓存Cache"><a href="#存储系统——高速缓存Cache" class="headerlink" title="存储系统——高速缓存Cache"></a>存储系统——高速缓存Cache</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302204358990.png" alt="image-20240302204358990"></p><h3 id="直接映像"><a href="#直接映像" class="headerlink" title="直接映像"></a>直接映像</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302204516454.png" alt="image-20240302204516454"></p><h3 id="全相联映像"><a href="#全相联映像" class="headerlink" title="全相联映像"></a>全相联映像</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302204651524.png" alt="image-20240302204651524"></p><h3 id="组相联映像"><a href="#组相联映像" class="headerlink" title="组相联映像"></a>组相联映像</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302204801322.png" alt="image-20240302204801322"></p><h3 id="选择替换算法"><a href="#选择替换算法" class="headerlink" title="选择替换算法"></a>选择替换算法</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302204909710.png" alt="image-20240302204909710"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302205217437.png" alt="image-20240302205217437"></p><p>cache对程序员来说是透明的，内容是主存内容的副本，既可以存放程序，又可以存放数据。  </p><h2 id="存储系统——主存的编址"><a href="#存储系统——主存的编址" class="headerlink" title="存储系统——主存的编址"></a>存储系统——主存的编址</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302212247094.png" alt="image-20240302212247094"></p><p>​                                                                                                               位扩展                             字扩展</p><h2 id="存储系统——硬盘（磁盘）"><a href="#存储系统——硬盘（磁盘）" class="headerlink" title="存储系统——硬盘（磁盘）"></a>存储系统——硬盘（磁盘）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302214135757.png" alt="image-20240302214135757"></p><h2 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302214249995.png" alt="image-20240302214249995"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302214330843.png" alt="image-20240302214330843"></p><h2 id="输入输出技术"><a href="#输入输出技术" class="headerlink" title="输入输出技术"></a>输入输出技术</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302214354111.png" alt="image-20240302214354111"></p><h2 id="可靠性（计算）"><a href="#可靠性（计算）" class="headerlink" title="可靠性（计算）"></a>可靠性（计算）</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240302214849493.png" alt="image-20240302214849493"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软考介绍</title>
    <link href="/cblog/2024/02/29/%E8%BD%AF%E8%80%83%E4%BB%8B%E7%BB%8D/"/>
    <url>/cblog/2024/02/29/%E8%BD%AF%E8%80%83%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="上午考点"><a href="#上午考点" class="headerlink" title="上午考点"></a>上午考点</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229195455560.png" alt="image-20240229195455560"></p><h3 id="下午考点"><a href="#下午考点" class="headerlink" title="下午考点"></a>下午考点</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229195532494.png" alt="image-20240229195532494"></p><h3 id="章节安排"><a href="#章节安排" class="headerlink" title="章节安排"></a>章节安排</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229200343592.png" alt="image-20240229200343592"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240229200557509.png" alt="image-20240229200557509"></p>]]></content>
    
    
    <categories>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>增强CT分期</title>
    <link href="/cblog/2024/01/27/%E5%A2%9E%E5%BC%BACT%E5%88%86%E6%9C%9F/"/>
    <url>/cblog/2024/01/27/%E5%A2%9E%E5%BC%BACT%E5%88%86%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>动脉期（Arterial Phase）      缩写：A</p><p>在注射造影剂后，动脉早期是造影剂刚刚进入动脉内的时期，大约在注射对比剂后15<del>20秒或触发扫描开始时。而动脉晚期则是造影剂在动脉内流动一段时间后，大约在注射对比剂后35</del>40秒，也被称为“早期静脉门脉期”，此时部分强化门静脉可见。在动脉期，多血供肿瘤会强化，而正常肝脏无强化或轻度强化，肿瘤与正常肝脏组织形成明显对比，有利于发现多血供肿瘤。</p><p>增强CT的动脉期可以清晰地观察到肿瘤。在动脉期，造影剂进入动脉血管，此时可以清晰地显示肿瘤与其周围正常组织的供血情况，有助于判断肿瘤的性质和分期。然而，不同的肿瘤在不同的时期表现不同，具体情况还需结合临床检查结果进行综合判断。</p></li><li><p>门脉期（Portal Venous Phase）    缩写：V</p><p>这是造影剂进入静脉血管的时期，可以观察病变静脉血供情况。</p></li><li><p>延迟期（Delayed Phase）   缩写：D</p><p>随着时间的推移，造影剂在血管中的浓度下降。但是如果存在肿瘤等丰富的血管组织，则造影剂在这个阶段下降较慢。</p></li><li><p>平扫 plain CT scan    缩写：P</p></li><li><p>A：动脉期（Arterial Phase）：大约在注射对比剂后15~20秒或触发扫描开始时。主要观察肝动脉血供情况或肿物的血供。</p></li><li><p>V：门脉期（Portal Venous Phase）：大约在注射对比剂后35~40秒。此时期是观察肝实质最好的时期。</p></li><li><p>D：延迟期（Delayed Phase）：注射造影剂3-5分钟延迟期主要观察肿瘤组织血流的消退情况，以及病灶是否完全充填。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>肾肿瘤</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IOU</title>
    <link href="/cblog/2024/01/21/IOU/"/>
    <url>/cblog/2024/01/21/IOU/</url>
    
    <content type="html"><![CDATA[<p>IoU是一种测量在特定数据集中检测相应物体准确度的一个标准。IoU是一个简单的测量标准，只要是在输出中得出一个预测范围(bounding boxex)的任务都可以用IoU来进行测量。为了可以使IoU用于测量任意大小形状的物体检测，我们需要：</p><p>ground-truth bounding boxes（人为在训练集图像中标出要检测物体的大概范围）<br>我们的算法得出的结果范围。</p><h4 id="IoU的计算"><a href="#IoU的计算" class="headerlink" title="IoU的计算"></a>IoU的计算</h4><p><strong>IoU是两个区域重叠的部分除以两个区域的集合部分得出的结果，通过设定的阈值，与这个IoU计算结果比较。</strong></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/20190114221649458.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>machine learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Confusion Matrix</title>
    <link href="/cblog/2024/01/21/Confusion-Matrix/"/>
    <url>/cblog/2024/01/21/Confusion-Matrix/</url>
    
    <content type="html"><![CDATA[<h4 id="混淆矩阵（Confusion-Matrix）"><a href="#混淆矩阵（Confusion-Matrix）" class="headerlink" title="混淆矩阵（Confusion Matrix）"></a>混淆矩阵（Confusion Matrix）</h4><p>在机器学习领域，混淆矩阵（Confusion Matrix），又称为可能性矩阵或错误矩阵。混淆矩阵是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。</p><h4 id="混淆矩阵要表达的含义："><a href="#混淆矩阵要表达的含义：" class="headerlink" title="混淆矩阵要表达的含义："></a>混淆矩阵要表达的含义：</h4><ul><li>混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；</li><li>每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目；每一列中的数值表示真实数据被预测为该类的数目。</li></ul><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/2020032322325750.jfif" alt="img"></p><p>True Positive（TP）：真正类。样本的真实类别是正类，并且模型识别的结果也是正类。</p><p> False Negative（FN）：假负类。样本的真实类别是正类，但是模型将其识别为负类。</p><p> False Positive（FP）：假正类。样本的真实类别是负类，但是模型将其识别为正类。</p><p> True Negative（TN）：真负类。样本的真实类别是负类，并且模型将其识别为负类。 </p>]]></content>
    
    
    <categories>
      
      <category>machine learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.1 语义分割与实例分割</title>
    <link href="/cblog/2024/01/20/1-1-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"/>
    <url>/cblog/2024/01/20/1-1-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://www.bilibili.com/video/BV1U94y1R71P/?spm_id_from=333.337.search-card.all.click&vd_source=f4ba3dd772b06290b305fb6123f66e1d">稀缺！人工智能必备【图像分割+语义分割】经典项目实战，同济大牛手把手教你做unet医学细胞分割实战，草履虫都说简单！-人工智能&#x2F;计算机视觉&#x2F;深度学习&#x2F;AI_哔哩哔哩_bilibili</a></p><p>语义分割：将每个像素都打上标签（语义分割只区分类别，不区分类别中的具体单位）</p><p>实例分割：不仅要区分类别，还要区分类别中的每一个个体</p>]]></content>
    
    
    <categories>
      
      <category>图像分割</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于轻量级网络和知识蒸馏的腹部CT三维图像多器官分割</title>
    <link href="/cblog/2024/01/02/%E5%9F%BA%E4%BA%8E%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%92%8C%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F%E7%9A%84%E8%85%B9%E9%83%A8CT%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%83%8F%E5%A4%9A%E5%99%A8%E5%AE%98%E5%88%86%E5%89%B2/"/>
    <url>/cblog/2024/01/02/%E5%9F%BA%E4%BA%8E%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E7%BB%9C%E5%92%8C%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F%E7%9A%84%E8%85%B9%E9%83%A8CT%E4%B8%89%E7%BB%B4%E5%9B%BE%E5%83%8F%E5%A4%9A%E5%99%A8%E5%AE%98%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Efficient-Multi-Organ-Segmentation-From-3DAbdominal-CT-Images-With-Lightweight"><a href="#Efficient-Multi-Organ-Segmentation-From-3DAbdominal-CT-Images-With-Lightweight" class="headerlink" title="Efficient Multi-Organ Segmentation From 3DAbdominal CT Images With Lightweight"></a>Efficient Multi-Organ Segmentation From 3DAbdominal CT Images With Lightweight</h2><p>Network and Knowledge Distillation</p><h2 id="高效的三维多器官分割腹部CT图像轻量网络与知识蒸馏"><a href="#高效的三维多器官分割腹部CT图像轻量网络与知识蒸馏" class="headerlink" title="高效的三维多器官分割腹部CT图像轻量网络与知识蒸馏"></a>高效的三维多器官分割腹部CT图像轻量网络与知识蒸馏</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>腹部CT图像多器官分割</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li>3D卷积神经网络（CNN）在自动医学图像分割任务中取得了令人鼓舞的性能。然而，大多数现有的3D CNN具有较大的参数集和巨大的浮点运算（FLOP），并且3D CT体积具有较大的尺寸，导致较高的计算成本，这限制了它们的临床应用。</li><li>从3D医学图像中手动分割多个器官耗时太差。</li></ol><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ol><li>LCOV-Net在计算成本和准确性方面优于现有的轻量级3D分割模型</li><li>KD策略有效地提高了轻量级网络的性能，并且优于现有的KD方法。</li><li>LCOV-Net和KD策略相结合，实现了比最先进的3D nnU-Net更好的性能，并且只使用了五分之一的参数。</li></ol><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102163131290.png" alt="image-20240102163131290"></p><p>提出两种新的KD策略：MSKD（多尺度蒸馏）和CAKD（类亲和蒸馏）</p><p>使用LACB块代替传统3D卷积块</p><p>Teacher Model使用3D nnU-Net    Student Model使用LCOV-Net网络</p><h3 id="LACB块"><a href="#LACB块" class="headerlink" title="LACB块"></a>LACB块</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102165210802.png" alt="image-20240102165210802"></p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102165414310.png" alt="image-20240102165414310"></p><p>基于注意力的卷积块(LACB)来取代标准的3D卷积操作。LACB由一个分支与时空可分离的3D卷积组成，以减少参数，另一个分支与基于注意力的特征校准组成，以增强块的学习能力。</p><p>特征标定分支以F′为输入，由四层组成，首先下采样层将F′的分辨率降低一半，然后使用逐点卷积进行具有通道间交互的特征映射，然后是上采样层以恢复分辨率，并将输出发送到Sigmoid激活函数以获得注意力系数α。</p><p>（1）LACB-H中额外的下采样层使得特征图太小而无法保持空间细节，（2）LACB-H中标准的3 × 3 × 1卷积由于通道数很大而导致大量参数。因此，我们提出了LACB-L，这是LACB-H在瓶颈处的变体。如图2（B）所示，在特征校准分支中，由于低空间分辨率，我们去除了下采样和上采样操作，并且仅保留逐点卷积。此外，第一分支中的3 × 3 × 1卷积使用分组卷积。具体地，特征图F′沿通道维度被划分为g个沿着组，并且每个组具有独立的卷积运算，组之间没有相互作用。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h4 id="基本的KD模块"><a href="#基本的KD模块" class="headerlink" title="基本的KD模块"></a>基本的KD模块</h4><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102165931770.png" alt="image-20240102165931770"></p><p>P表示学生网络的softmax预测，QS和QT分别表示教师和学生的软概率图。</p><p>其中Lce和Ldice分别是交叉熵（CE）损失和Dice损失。Lkd是通过CE损失实现的QS和QT之间的知识蒸馏损失。Lsup是P和实际分割图Y之间的标准监督损失。λ ∈ [0，1]是调整Lkd和Lsup的贡献的权重。</p><h4 id="类亲和知识蒸馏"><a href="#类亲和知识蒸馏" class="headerlink" title="类亲和知识蒸馏"></a>类亲和知识蒸馏</h4><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102171618845.png" alt="image-20240102171618845"></p><p>假设有K个类别进行分割，教师QT的软预测图具有K × W × H × D的形状。它首先被整形为K ×（WHD），然后乘以它的转置版本，其形状为（WHD）× K，导致类亲和矩阵MT ∈ RK×K，如图1（d）所示。类似地，学生模型的类亲和度矩阵也可以表示为MS ∈ RK×K。对于多类分割任务，矩阵表示任何一对不同类之间的关系。建议CAKD损失以鼓励学生生成类似于教师的类亲和矩阵。CAKD损失的提出是为了鼓励学生生成一个类似于教师的类亲和矩阵。其中sim表示余弦相似度。</p><h4 id="多尺度知识蒸馏"><a href="#多尺度知识蒸馏" class="headerlink" title="多尺度知识蒸馏"></a>多尺度知识蒸馏</h4><p>设S 表示解码器中考虑的全部尺度数(本文中 S &#x3D; 4)。请注意，s &#x3D; 0 表示网络的最末端，s 越大，说明我们越接近瓶颈。教师和学生的软预测图分别表示为 QsS 和QsT。我们用MSs和MTs 分别表示相应的类亲和映射。多尺度KD损失为</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102175436446.png" alt="image-20240102175436446"></p><p>γs 为尺度 s 的损失权重，s &#x3D; 0表示最高分辨率，即最终输出，s &gt; 0表示较低分辨率。</p><h4 id="总损失函数"><a href="#总损失函数" class="headerlink" title="总损失函数"></a>总损失函数</h4><p>Lsup是P和Ground Truth分割图Y之间的标准监督损失。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102175619117.png" alt="image-20240102175619117"></p><p>最终的损失函数    λ是超参数，平衡两个损失函数</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102181422289.png" alt="image-20240102181422289"></p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h4 id="DICE"><a href="#DICE" class="headerlink" title="DICE"></a>DICE</h4><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102181837369.png" alt="image-20240102181837369"></p><p>Dice系数定义为两倍的交集除以像素和，也叫F1 score。Dice 系数与 IoU 非常相似，它们是正相关的。这意味着如果一个人说模型 A 在分割图像方面比模型 B 更好，那么另一个人也会这么说。</p><h4 id="HD"><a href="#HD" class="headerlink" title="HD"></a>HD</h4><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102181941758.png" alt="image-20240102181941758"></p><p>Hausdorff distance（豪斯道夫距离）， HD 用于分割指标，主要是用来度量边界的分割准确度。</p><p>在实际计算中，我们并不是选取的不是最大距离，而是将距离从大到小排列后，取排名为5%的距离。这么做的目的是为了排除一些离群点所造成的不合理的距离，保持整体数值的稳定性。所以也叫HD95。</p><p>其中Sa和Sb分别表示由CNN和Ground Truth分割的一个器官的表面点的集合。</p><h4 id="ASSD"><a href="#ASSD" class="headerlink" title="ASSD"></a>ASSD</h4><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102182245940.png" alt="image-20240102182245940"></p><p>ASSD是平均表面距离</p><p>其中d（i，Sa）是点k和表面Sa之间的最短欧几里得距离。</p><p>表面距离：设P为prediction的表面点集，G为ground truth的Volume表面点集，P中任意一点的表面距离为该体素到G中所有体素的欧式距离的最小值，依次遍历P中所有的点即可得到表面距离。</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol><li><p>公开数据集WORD包括150名直肠癌、前列腺癌或宫颈癌患者在放疗前的CT扫描。图像的平面内分辨率为 0.976 mm×0.976 mm，切片间距 2.5-3.0 mm，基体尺寸512 × 512 .有16个器官进行分割，包括肝、脾、肾（L）、肾（R）、胃、胆囊、食道、胰腺、十二指肠、结肠、肠、肾上腺、直肠、膀胱、股骨头（L）和股骨头（R）。将数据集随机拆分为 100、20 和 30 个案例，分别用于训练、验证和测试。</p></li><li><p>（2）TCIA (43次扫描)和 BTCV(47次扫描) 数据集。平面内像素尺寸范围为0.6-0.9 mm，切片间距范围为0.5-5.0 mm。这两个数据集的融合有 90 次腹部 CT 扫描，有八个器官进行分割：脾脏、左肾、胆囊、食道、肝脏、胃、胰腺和十二指肠。将数据集随机分成 60、10 和 20 次扫描，分别用于训练、验证和测试。</p></li></ol><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102182537467.png" alt="image-20240102182537467"></p><p>表1显示了对这些方法的定量评估，其中第一部分是模型大小和计算成本的比较，第二部分显示了分割结果的Dice分数。我们按照[30]中的方法评估模型大小。可以看出，ESPNet[10]获得的Dice得分最低。这主要是因为ESPNet[10]是针对自然RGB图像提出的，而自然RGB图像与CT图像具有不同的特征和强度分布。</p><p>LCOV-Net（-A）仅使用LACB中的时空可分离卷积分支，LCOV-Net（-B）将时空可分离卷积分支与跳过连接相结合，而不使用LACB中的特征校准分支，以及LCOV-Net（-C）在瓶颈处使用LACB-H而不是LACB-L。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102191946483.png" alt="image-20240102191946483"></p><p>图3显示了三种轻量级网络与重量级3D nnU-Net的视觉对比[3]。</p><p>可以看出，3D nnU-Net[3]比轻量化模型获得了更好的结果。对于轻量级模型，我们的LCOV-Net优于DMFNet[32]和ESPNet[10]，特别是在第一行所示的脾脏和第三行所示的肿瘤肝脏中。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102191955618.png" alt="image-20240102191955618"></p><p>图4呈现了这些KD方法对于不同器官的Dice方面的定量比较。结果表明，KD方法能有效地提高轻量级模型的性能。特别是对于胃、胆囊、十二指肠、结肠、肾上腺和直肠等硬组织的分割精度有了很大的提高。可以观察到，对于16个器官中的大多数，所提出的KD方法优于现有的KD方法。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102192009738.png" alt="image-20240102192009738"></p><p>表II显示了这些方法之间平均Dice、HD95和ASSD的比较。在WORD数据集上，与不使用KD相比，我们的方法将平均HD95从10.16 mm减少到5.96 mm，平均ASSD从2.94 mm减少到1.86 mm，并且优于Attention KD [46]，在现有KD方法中实现了最佳性能。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102192028033.png" alt="image-20240102192028033"></p><p>T是控制输出概率的软度的参数</p><p>我们的KD方法的消融研究：为了验证我们提出的KD方法的每个组成部分（等式1）。10)将CAKD和MSKD与FNKD组合（等式11）。6），我们将其与使用这些组件的一部分的不同变体进行了比较。</p><p>定量结果见表III。可以观察到，初始KD [14]和FNKD [39]分别将平均Dice从83.90%提高到84.32%和84.93%。FNKD和MSKD的平均Dice提高到84.96%。最后，FNKD + MSKD + CAKD的方法导致最高的性能</p><p>FNKD ：特征归一化KD（FNKD）     q中T被设置为z的L2范数，以获得可靠的软预测，而不管特征的规模如何。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102192246153.png" alt="image-20240102192246153"></p><p>图5显示了我们的KD方法的不同变体之间的视觉比较。可以观察到，我们的蒸馏模块有助于减少脾脏、结肠和肠道等具有挑战性区域的错误分割。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102192321174.png" alt="image-20240102192321174"></p><p>TABLE IV</p><p>TCIA和BTCV数据集上不同KD方法之间的DICE（%）比较。表示性能显著低于我们（p值&lt; 0.05）</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102192337029.png" alt="image-20240102192337029"></p><p>图6显示了不同CNN在TCIA+BTCV数据集上实现的Dice得分。这表明我们的LCOV-Net与脾脏、左肾和肝脏上的3D nnU-Net [3]相当。ESPNet [10]在大多数器官上的表现最差，DMFNet [32]优于ESPNet，但劣于我们的LCOV-Net。图6还示出了LCOV-Net优于LCOV-Net（-A）、LCOVNet（-B）和LCOV-Net（-C），尤其是在难以分割的十二指肠、食道和胃上。</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20240102192349274.png" alt="image-20240102192349274"></p><p>图7显示了我们的KD方法在TCIA和BTCV数据集上的消融研究，其分别证明了我们提出的CAKD和MSKD所获得的性能改善。</p><h4 id="亲和矩阵"><a href="#亲和矩阵" class="headerlink" title="亲和矩阵"></a>亲和矩阵</h4><p>Affinity Matrix 可以用来干什么？<br>智能信息检索：亲和矩阵是搜索引擎的驱动力，它为你提取你甚至不知道你需要的额外相关信息。<br>数据挖掘：相似矩阵可以快速准确地在充满未标记信息的数据库中识别任何的隐藏关系模式。<br>无监督学习：如果没有相似度矩阵来确保网络自学内容的最低准确性标准，那么创建能够从原始无组织数据中获取结构和含义的机器学习算法是不可能的。</p><h4 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h4><p>知识蒸馏就是把一个大的教师模型的知识萃取出来，把他浓缩到一个小的学生模型，可以理解为一个大的教师神经网络把他的知识教给小的学生网络，这里有一个知识的迁移过程，从教师网络迁移到了学生网络身上，教师网络一般是比较臃肿，所以教师网络把知识教给学生网络，学生网络是一个比较小的网络，这样就可以用学生网络去做一些轻量化网络做的事情。</p><p>知识蒸馏使用的是Teacher—Student模型，其中teacher是“知识”的输出者，student是“知识”的接受者。知识蒸馏的过程分为2个阶段:</p><ol><li>原始模型训练: 训练”Teacher模型”, 简称为Net-T，它的特点是模型相对复杂，也可以由多个分别训练的模型集成而成。我们对”Teacher模型”不作任何关于模型架构、参数量、是否集成方面的限制，唯一的要求就是，对于输入X, 其都能输出Y，其中Y经过softmax的映射，输出值对应相应类别的概率值。</li><li>精简模型训练: 训练”Student模型”, 简称为Net-S，它是参数量较小、模型结构相对简单的单模型。同样的，对于输入X，其都能输出Y，Y经过softmax映射后同样能输出对应相应类别的概率值。</li><li>Teacher学习能力强，可以将它学到的知识迁移给学习能力相对弱的Student模型，以此来增强Student模型的泛化能力。复杂笨重但是效果好的Teacher模型不上线，就单纯是个导师角色，真正部署上线进行预测任务的是灵活轻巧的Student小模型。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">liver:肝<br>duodenum：十二指肠<br>spleen：脾<br>colon：结肠<br>kidney：肾<br><span class="hljs-built_in">int</span>estine：肠<br>adrenal：肾上腺<br>stomach：胃<br>rectum：直肠<br>gallbladder：胆囊<br>bladder：膀胱<br>head femur：头股骨<br>pancreas：胰腺<br>esophagus：食管<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MB-FSGAN</title>
    <link href="/cblog/2023/12/18/MB-FSGAN/"/>
    <url>/cblog/2023/12/18/MB-FSGAN/</url>
    
    <content type="html"><![CDATA[<h1 id="MB-FSGAN-Joint-segmentation-and-quantification-of-kidney-tumor-on-CT-by-the-multi-branch-feature-sharing-generative-adversarial-network"><a href="#MB-FSGAN-Joint-segmentation-and-quantification-of-kidney-tumor-on-CT-by-the-multi-branch-feature-sharing-generative-adversarial-network" class="headerlink" title="MB-FSGAN: Joint segmentation and quantification of kidney tumor on CT by the multi-branch feature sharing generative adversarial network"></a>MB-FSGAN: Joint segmentation and quantification of kidney tumor on CT by the multi-branch feature sharing generative adversarial network</h1><h1 id="MB-FSGAN：基于多分支特征共享生成对抗网络的CT肾脏肿瘤联合分割和量化"><a href="#MB-FSGAN：基于多分支特征共享生成对抗网络的CT肾脏肿瘤联合分割和量化" class="headerlink" title="MB-FSGAN：基于多分支特征共享生成对抗网络的CT肾脏肿瘤联合分割和量化"></a>MB-FSGAN：基于多分支特征共享生成对抗网络的CT肾脏肿瘤联合分割和量化</h1>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>肾肿瘤分割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>肾肿瘤概念</title>
    <link href="/cblog/2023/12/17/%E8%82%BE%E8%82%BF%E7%98%A4/"/>
    <url>/cblog/2023/12/17/%E8%82%BE%E8%82%BF%E7%98%A4/</url>
    
    <content type="html"><![CDATA[<p>数据详情：无功能   125人       有功能  70人</p><p>皮质醇激素很高的（300左右）   5人；  醛固酮激素100+   4人</p><p>方案：激素水平分类       醛固酮，皮质醇，无功能</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">皮质醇：属于肾上腺分泌的肾上腺皮质激素之中的糖皮质激素，在应付压力中扮演重要角色，故又被称为“压力荷尔蒙”。皮质醇会提高血压、血糖水平和产生免疫抑制作用。<br><br>醛固酮：是一种类固醇类激素（盐皮质激素家族），由肾上腺皮质所产生，主要作用于肾脏，进行钠离子及水分的再吸收，以维持血压的稳定。整体来说，醛固酮为一种增进肾脏对于离子及水分再吸收作用的一种激素，为肾素-血管紧张素系统的一部分。<br><br>无功能腺瘤：无功能腺瘤，主要是良性肿瘤，与激素分泌过多综合征无关。<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">皮质醇偏高：<br>1、慢性病：长期增加皮质醇可能会增加患高血压、心脏病、2 型糖尿病、骨质疏松症和其他慢性疾病的风险。<br>2、体重增加：皮质醇可能会增加食欲，向身体发出信号，改变代谢以储存脂肪。<br>3、缺乏能量/难以入睡：会干扰睡眠激素，可能会影响睡眠质量和长度。<br>4、难以集中注意力：也被称为“脑雾”，有些人报告说难以集中注意力和缺乏清晰思路。<br>5、免疫系统受损：皮质醇增加会阻碍免疫系统，更难抵抗感染。<br>6、库欣综合征：在极少数情况下，非常高的皮质醇水平会导致库欣综合征，这是一种罕见但严重的疾病。<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">醛固酮是由肾上腺皮质球状带分泌的一种激素，以调节水、盐代谢为主，醛固酮具有保钠排钾的作用。醛固酮增高的危害主要有以下几点：<br>1、高血压。长期醛固酮增多、保钠作用增强、血容量负荷过重容易引起高血压，而且常规降压药物效果不明显。<br>2、低血钾。醛固酮具有促进尿钾排泄的作用，可以出现低钾血症，临床表现为肌无力、发作性软瘫甚至是低钾性麻痹。严重的低钾血症影响心脏呼吸肌，可以导致心跳、呼吸骤停。<br>3、长期低钾可以影响糖代谢甚至发生糖尿病。<br>4、长期低钾可以形成低钾性肾病，容易形成尿路感染等。<br></code></pre></td></tr></table></figure><p>增强CT的三个期相都可以用于肾肿瘤的诊断。动脉期可以观察肿瘤的血流情况，有助于判断肿瘤的性质和分期；门脉期可以观察肿瘤与周围组织的关系，有助于判断肿瘤是否侵犯周围组织；延迟期可以观察肿瘤是否发生转移。</p>]]></content>
    
    
    <categories>
      
      <category>肾肿瘤</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>误差基本概念</title>
    <link href="/cblog/2023/11/22/%E8%AF%AF%E5%B7%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/cblog/2023/11/22/%E8%AF%AF%E5%B7%AE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="测量方法分类"><a href="#测量方法分类" class="headerlink" title="测量方法分类"></a>测量方法分类</h1><ol><li>直接测量</li><li>间接测量</li><li>组合测量</li></ol><h1 id="误差定义及其基本概念"><a href="#误差定义及其基本概念" class="headerlink" title="误差定义及其基本概念"></a>误差定义及其基本概念</h1><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">误差<span class="hljs-operator">=</span>测量结果-被测量的真值<br></code></pre></td></tr></table></figure><p>真值的特性：（1）近似可知性  （2）可变性</p><p>真值类型：<font color=red>（1）理论类型   （2）约定真值</font></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">测量误差的基本方法<br><span class="hljs-number">1</span>.绝对误差 = 测量结果 - 真值  （有单位）<br>  修正值 = -绝对误差<br>  测量结果 + 修正值 = 真值<br><span class="hljs-number">2</span>.相对误差（无单位）<br>  相对误差 = 绝对误差<span class="hljs-regexp">/真值 = 绝对误差/</span>约定真值<br>  相对误差 = 绝对误差/测量结果<br><span class="hljs-number">3</span>.引用误差 = 示值误差/特定值<br>  引用误差 = 示值误差/特定值<br>  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>误差</category>
      
    </categories>
    
    
    <tags>
      
      <tag>期末复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo下载、安装、配置</title>
    <link href="/cblog/2023/11/15/PicGo%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/"/>
    <url>/cblog/2023/11/15/PicGo%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="PicGo下载"><a href="#PicGo下载" class="headerlink" title="PicGo下载"></a>PicGo下载</h1><p>PicGo：一个用于快速上传图片并获取图片 URL 链接的工具。</p><p>官网地址：<a href="https://picgo.github.io/PicGo-Doc/">https://picgo.github.io/PicGo-Doc/</a></p><p>官网下载地址：Release 2.3.0 · Molunerfinn&#x2F;PicGo<br><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接打开.exe，安装即可</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li><p>注册Gitee账号</p></li><li><p>在gitee上新建仓库（公开）</p></li><li><p>生成私人令牌</p></li><li><p>配置PicGo</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231121205133669.png" alt="image-20231121205133669"></p></li></ol><p>在图床设置中选择 gitee，配置如下图所示</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231121205619842.png" alt="image-20231121205619842"></p><ol start="5"><li><p>在 Typora 中使用</p><p>文件——&gt;偏好设置——&gt;图像</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231121212136943.png" alt="image-20231121212136943"></p></li><li><p>验证是否能够上传成功</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231121212530016.png" alt="image-20231121212530016"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>hexo+gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客部署到gitee</title>
    <link href="/cblog/2023/11/15/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee/"/>
    <url>/cblog/2023/11/15/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee/</url>
    
    <content type="html"><![CDATA[<h1 id="本地博客部署到gitee"><a href="#本地博客部署到gitee" class="headerlink" title="本地博客部署到gitee"></a>本地博客部署到gitee</h1><p>hexo在本地创建了博客</p><h2 id="1-注册gitee账号"><a href="#1-注册gitee账号" class="headerlink" title="1.注册gitee账号"></a>1.注册gitee账号</h2><h2 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2.新建仓库"></a>2.新建仓库</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231119214707744.png" alt="image-20231119214707744"></p><h2 id="3-填写信息创建仓库"><a href="#3-填写信息创建仓库" class="headerlink" title="3.填写信息创建仓库"></a>3.填写信息创建仓库</h2><ol><li><p>公有</p></li><li><p>使用Readme文件初始化这个仓库</p></li></ol><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231119214731197.png" alt="image-20231119214731197"></p><h2 id="4-打开Git-Pages"><a href="#4-打开Git-Pages" class="headerlink" title="4.打开Git Pages"></a>4.打开Git Pages</h2><p>部署静态服务</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231119215015137.png" alt="image-20231119215015137"></p><h2 id="5-修改本地配置"><a href="#5-修改本地配置" class="headerlink" title="5.修改本地配置"></a>5.修改本地配置</h2><p>找到根目录下的_config.yml中的url 和 root</p><p>url修改为你码云中的地址</p><p>root修改为仓库名 我的为  cblog</p><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231120144224537.png" alt="image-20231120144224537"></p><h2 id="7-安装淘宝镜像"><a href="#7-安装淘宝镜像" class="headerlink" title="7.安装淘宝镜像"></a>7.安装淘宝镜像</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> install -g cnpm --registry=https://registry.<span class="hljs-built_in">npm</span>.taobao.org<br></code></pre></td></tr></table></figure><h2 id="8-安装hexo-deployer-git插件"><a href="#8-安装hexo-deployer-git插件" class="headerlink" title="8.安装hexo-deployer-git插件"></a>8.安装<code>hexo-deployer-git</code>插件</h2><p><img src="https://raw.githubusercontent.com/cuixinx/picgo/master/cblog/image-20231120151716400.png" alt="image-20231120151716400"></p><h2 id="9-部署"><a href="#9-部署" class="headerlink" title="9.部署"></a>9.部署</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo clean<br>hexo g<br>hexo d  <span class="hljs-comment">--推送到远程仓库 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>hexo+gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CKD-TransBTS</title>
    <link href="/cblog/2023/11/14/CKD-TransBTS/"/>
    <url>/cblog/2023/11/14/CKD-TransBTS/</url>
    
    <content type="html"><![CDATA[<h1 id="CKD-TransBTS-Clinical-Knowledge-Driven-Hybrid-Transformer-With-Modality-Correlated-Cross-Attention-for-Brain-Tumor-Segmentation"><a href="#CKD-TransBTS-Clinical-Knowledge-Driven-Hybrid-Transformer-With-Modality-Correlated-Cross-Attention-for-Brain-Tumor-Segmentation" class="headerlink" title="CKD-TransBTS: Clinical Knowledge-Driven Hybrid Transformer With Modality-Correlated Cross-Attention for Brain Tumor Segmentation"></a>CKD-TransBTS: Clinical Knowledge-Driven Hybrid Transformer With Modality-Correlated Cross-Attention for Brain Tumor Segmentation</h1><p>CKD-TransBTS：临床知识驱动的混合Transformer和模态相关交叉注意的脑肿瘤分割</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
